<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on e3b0c442.io</title>
    <link>/post/</link>
    <description>Recent content in Posts on e3b0c442.io</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The ThinkPad experiment: a post-mortem</title>
      <link>/post/thinkpad-post-mortem/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/thinkpad-post-mortem/</guid>
      <description>&lt;p&gt;After a week of tweaking, fixing, and just generally trying to get up to full productivity with it, I packed the ThinkPad X1 Extreme up to return this morning.&lt;/p&gt;

&lt;p&gt;There are some really nice things about this computer. The keyboard is top-notch. The computer seems to be very solid and durable (though this is hard to measure after just one week). The screen is utterly amazing in its sharpness, color accuracy and saturation, and contrast and brightness, and I ended up suprising myself with how much I used the touch functionality. On paper, and at first glance, it is a great machine. I just couldn&amp;rsquo;t get up to 100% productivity on it.&lt;/p&gt;

&lt;p&gt;I can&amp;rsquo;t really quantify how much of my time I spent trying to get things just right. I&amp;rsquo;ll admit, I&amp;rsquo;m a bit of a perfectionist in that regard, but I feel like I have a right to be. I expect to be productive on my laptops; I have a desktop at home for when I want to tweak.&lt;/p&gt;

&lt;p&gt;So, what exactly went wrong? At the end of the week, there were three blockers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In Linux, I was still trying to get the trackpad behavior just right. In particular, there was a very annoying issue with the trackpad not correctly detecting my thumb, making click-and-drag nearly impossible. Given enough time, I probably could have gotten it there, but it was a painful process.&lt;/li&gt;
&lt;li&gt;Because of the trackpad issue, I probably spent more time than I otherwise would have trying to get my Yubikey working seamlessly in Windows. I thought I was finally there last night, through a convoluted process involving no less than three tools that I wouldn&amp;rsquo;t otherwise actively use, that all needed to be running. And then I discovered that the SSH agent wasn&amp;rsquo;t forwarding even though I had configured it to, and by that point I had lost my will to continue, because&amp;hellip;&lt;/li&gt;
&lt;li&gt;UI performance was downright awful. It took me a couple of days to really notice it, but when I did, it was &lt;a href=&#34;https://www.youtube.com/watch?v=BcmFkmDcFac&#34; target=&#34;_blank&#34;&gt;like the glass-breaking scenes from How I Met Your Mother&lt;/a&gt;. It became like nails on a chalkboard, and I spent the better part of Friday and Saturday trying to resolve it through a series of voltage and performance tweaks. I knew Windows could do better; Windows runs like a champ on my desktop which has similar specs. The breaking point, though, was when I needed to pick my old MacBook Pro up to do something while I was waiting for Windows to reboot on the other machine. My MacBook Pro is 6 years old, and compared to the ThinkPad, it felt brand new. The UI was responsive, animations were silky-smooth&amp;hellip; I couldn&amp;rsquo;t believe how stark the difference was. Would my little-MacBook-Pro-That-Could keep up with the ThinkPad on compute-intensive tasks? No. But at least for now, I have the option of offloading most of those onto my desktop at the sacrifice of some convenience, so to me the day-to-day user experience is far more valuable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first issue: I could have resolved with enough time. The second issue: was annoying, but working and I&amp;rsquo;m sure I could have figured out the agent forwarding. The third issue: despite the hours I spent, I didn&amp;rsquo;t feel like I made much ground, and I&amp;rsquo;m just not sure I could have fixed it in the first place. There were three likely culprits: thermal transfer issues, bad drivers, and a screen that was just too much for the GPU. I could have only helped one of those.&lt;/p&gt;

&lt;p&gt;Even if I had managed to get across the finish line with all of these problems&amp;hellip; what if I needed to reinstall the OS for some reason? Then I need to figure it all out again (or figure out how to effectively back up and restore it).&lt;/p&gt;

&lt;p&gt;In addition to those show-stoppers, there were a number of minor annoyances, many of which I expected. The trackpad just wasn&amp;rsquo;t as good as a Mac trackpad. I couldn&amp;rsquo;t open the screen with one hand, and it didn&amp;rsquo;t stay put through the whole range of being open if I let go. I sorely missed some of the Apple ecosystem integrations (Messages, I&amp;rsquo;m talking to you).&lt;/p&gt;

&lt;p&gt;Before I made the decision to pack everything up, I thought back on the reasons I decided to attempt this switch in the first place, and the keyboard is the only reason on that list that still holds up. On upgradeability, I realized it was a false justification, because I&amp;rsquo;ve had my MacBook Pro now for 6 years, and neither memory nor storage is the reason I&amp;rsquo;m looking to upgrade. On the value proposition, if I applied a monetary value to the amount of time I spent this week just trying to get to my previous level of productivity, I would have nearly wiped out the difference. On the matter of hardware/software and ecosystem integration, I&amp;rsquo;m not proud to say I was flat-out wrong.&lt;/p&gt;

&lt;p&gt;In my previous article, my thesis was &amp;ldquo;the value proposition of a Mac notebook no longer makes sense.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Apparently, it still does.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Passing the torch</title>
      <link>/post/thinkpad/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/thinkpad/</guid>
      <description>&lt;p&gt;After 18 years of exclusively using Mac laptops, I ordered a ThinkPad today.&lt;/p&gt;

&lt;p&gt;Why? In short, the value proposition of a Mac notebook no longer makes sense.&lt;/p&gt;

&lt;p&gt;As Mac computers have made up a progressively smaller slice of Apple&amp;rsquo;s revenue pie, the effort put into innovation has waned, and with it, a lot of the magic of Apple&amp;rsquo;s unique ability to control both the hardware and software stacks. Couple this with advancements in hardware quality by other vendors, and improvements in the usability of both Windows and Linux operating systems, Apple&amp;rsquo;s lead in this space has narrowed significantly. This is compounded by Apple&amp;rsquo;s insistence on pushing form over function.&lt;/p&gt;

&lt;p&gt;The end result? A machine which at the hardware level is functionally inferior at a greater price, without the Apple magic.&lt;/p&gt;

&lt;p&gt;The ThinkPad I ordered is a half-inch wider, two-tenths of an inch deeper, and one-tenth of an inch thicker than a current 15-inch MacBook Pro and weighs the same svelte 4 pounds, yet there is no glue, almost everything is repairable, and the expected parts are upgradeable (2 SO-DIMM slots and &lt;em&gt;two&lt;/em&gt; NVMe M.2 slots). It doesn&amp;rsquo;t force me to use a port which, while superior, still has a dearth of released hardware. It has a fantastic keyboard with full travel. It is Mil-Spec tested for durability. It has all of this &lt;em&gt;in spite of&lt;/em&gt; its relative thinness and lightness, and &lt;em&gt;in spite of&lt;/em&gt; the fact that it costs two-thirds the price of a comparable MacBook Pro.&lt;/p&gt;

&lt;p&gt;My current MacBook Pro has served me well for six years, but I couldn&amp;rsquo;t keep waiting for Apple to figure out that thin and light doesn&amp;rsquo;t need to mean expensive and disposable.&lt;/p&gt;

&lt;p&gt;I want to say I&amp;rsquo;ll miss macOS, but honestly, Linux and Windows have both come a long way in recent years, and macOS has stagnated. Given that iDevices have become more independent, and Apple is expanding its services to other platforms to extend their service revenue, the only thing one really &lt;em&gt;needs&lt;/em&gt; a Mac for anymore is writing code for macOS/iOS, which I haven&amp;rsquo;t done for nearly a decade at this point.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not giving up my iPhone or iPad anytime soon, they are very clearly superior devices and I don&amp;rsquo;t expect that to change in the near term. But for general-purpose computers, I just can&amp;rsquo;t justify paying a 50% premium for a less-capable machine that I don&amp;rsquo;t even have the future option of making more capable.&lt;/p&gt;

&lt;p&gt;Apple is showing glimmers of understanding that they have swung the needle too far on the form/function scale. The modularity and expandability of the new Mac Pro sets a new standard in the space. They have eschewed the proprietary Lightning port for a standard USB-C on the iPad Pro. Maybe in a few years when it&amp;rsquo;s time to look at upgrading again, the Apple magic will be back.&lt;/p&gt;

&lt;p&gt;In the meantime, I&amp;rsquo;m going to enjoy that sweet, sweet Thinkpad keyboard.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 7: Some Assembly Required</title>
      <link>/post/advent-2015-c-7/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-7/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a few weeks, but I&amp;rsquo;m glad to be able to pick up the Advent of Code series again. In the last post, I took a bit of a digression to discuss hash tables. In today&amp;rsquo;s post, we&amp;rsquo;ll see why. Let&amp;rsquo;s see what we have in store for day 7:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This year, Santa brought little Bobby Tables a set of wires and &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34; target=&#34;_blank&#34;&gt;bitwise logic gates&lt;/a&gt;! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.&lt;/p&gt;

&lt;p&gt;Each wire has an identifier (some lowercase letters) and can carry a &lt;a href=&#34;https://en.wikipedia.org/wiki/16-bit&#34; target=&#34;_blank&#34;&gt;16-bit&lt;/a&gt; signal (a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;65535&lt;/code&gt;). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.&lt;/p&gt;

&lt;p&gt;The included instructions booklet describes how to connect the parts together: &lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means to connect wires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to an AND gate, and then connect its output to wire &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 -&amp;gt; x&lt;/code&gt; means that the signal &lt;code&gt;123&lt;/code&gt; is provided to wire &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#AND&#34; target=&#34;_blank&#34;&gt;bitwise AND&lt;/a&gt; of wire &lt;code&gt;x&lt;/code&gt; and wire &lt;code&gt;y&lt;/code&gt; is provided to wire &lt;code&gt;z&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p LSHIFT 2 -&amp;gt; q&lt;/code&gt; means that the value from wire &lt;code&gt;p&lt;/code&gt; is &lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;left-shifted&lt;/a&gt; by &lt;code&gt;2&lt;/code&gt; and then provided to wire &lt;code&gt;q&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT e -&amp;gt; f&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#NOT&#34; target=&#34;_blank&#34;&gt;bitwise complement&lt;/a&gt; of the value from wire &lt;code&gt;e&lt;/code&gt; is provided to wire &lt;code&gt;f&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other possible gates include &lt;code&gt;OR&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#OR&#34; target=&#34;_blank&#34;&gt;bitwise OR&lt;/a&gt;) and &lt;code&gt;RSHIFT&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;right-shift&lt;/a&gt;). If, for some reason, you&amp;rsquo;d like to &lt;strong&gt;emulate&lt;/strong&gt; the circuit instead, almost all programming languages (for example, &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operations_in_C&#34; target=&#34;_blank&#34;&gt;C&lt;/a&gt;, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;, or &lt;a href=&#34;https://wiki.python.org/moin/BitwiseOperators&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt;) provide operators for these gates.&lt;/p&gt;

&lt;p&gt;For example, here is a simple circuit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 123 -&amp;gt; x
&amp;gt; 456 -&amp;gt; y
&amp;gt; x AND y -&amp;gt; d
&amp;gt; x OR y -&amp;gt; e
&amp;gt; x LSHIFT 2 -&amp;gt; f
&amp;gt; y RSHIFT 2 -&amp;gt; g
&amp;gt; NOT x -&amp;gt; h
&amp;gt; NOT y -&amp;gt; i
&amp;gt; ```

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After it is run, these are the signals on the wires:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In little Bobby&amp;rsquo;s kit&amp;rsquo;s instructions booklet (provided as your puzzle input), what signal is ultimately provided to &lt;strong&gt;wire &lt;code&gt;a&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a fairly complex problem, and in contrast to previous days&amp;rsquo; entries, there is more than one way to go about solving it successfully and efficiently. I chose to solve this problem by creating &lt;em&gt;hash tables&lt;/em&gt; with the gate statements, and then recursively calling an operator function to find the gate value. Hash tables are approprate for this task for two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Accessing the gate instructions will effectively be random-access since there is no linearity to how the instructions are arranged. Hash tables on average have &lt;em&gt;O(1)&lt;/em&gt; time complexity for searches.&lt;/li&gt;
&lt;li&gt;The gates are named by strings, allowing us to translate them directly into hash table keys.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will utilize the &lt;a href=&#34;/post/esht/&#34; target=&#34;_blank&#34;&gt;esht&lt;/a&gt; implementation discussed in the prior article. As noted in that article, while there is a POSIX hash table implementation, it is non-reentrant, and a re-entrant version included as part of the GNU C library is not present in many UNIX flavors, including macOS. In this case, reentrancy is important as we will soon see that we need to maintain two tables.&lt;/p&gt;

&lt;p&gt;As we examine this problem, what might immediately jump out is that each of these gates is a function that takes one or two 16-bit input values and outputs another value. Indeed, it would be possible, and some might consider elegant, to parse the inputs into a linked tree of function pointers using function pointers. However, I feel like this adds some unnecessary complexity and does not avoid the need for an additional caching mechanism, which is necessary due to the fact that we cannot guarantee that the gates are a true tree.&lt;/p&gt;

&lt;p&gt;Given this, it is much simpler and cleaner to parse the gate definitions into a data structure and make recursive calls to a single executor function to accomplish the goal of the task.&lt;/p&gt;

&lt;p&gt;With that lengthy discussion out of the way, let&amp;rsquo;s break the problem down a bit as we have done in previous weeks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Parse the individual gates into a hash table&lt;/li&gt;
&lt;li&gt;Execute the gates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As gates can also be inputs to another gate, we will need to call the gate executor recursively, so we will make this a separate function. We&amp;rsquo;ll start our coding here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t do_op(esht *instrs, esht *cache, char *key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our gate execution function takes three arguments: the hash table with the gate instructions keyed by gate name, a cache of already-resolved values also keyed by the gate name, and the gate key itself. The return value is &lt;code&gt;uint16_t&lt;/code&gt;, which is an unsigned 16-bit integer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we are going to do is check for a cached value. We use the provided key and cache table pointer to call &lt;code&gt;esht_get()&lt;/code&gt;; we cast the return value to a pointer to &lt;code&gt;uint16_t&lt;/code&gt; as the values are stored in the hash table as void pointers. If a result is found in the cache, we copy the value, clean up the allocated memory (remember that with &lt;code&gt;esht&lt;/code&gt;, the caller is responsible for cleanup of returned values), and return the retrieved value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no value in the cache for the key, it is time to start solving the gate value. We&amp;rsquo;ll first pull the gate definition from the hash table where we&amp;rsquo;ve already stored it. We then declare an array of four matches; the instruction parsing expression has three submatches in addition to the whole string match, which we will discuss later. For now, it is sufficient to know that we are capturing the three components of the gate expression. Finally, we execute the regular expression to populate the match variables. If either the instruction lookup fails or the regular expression execution returns no match, &lt;code&gt;errno&lt;/code&gt; is set appropriately and execution jumps to the error cleanup handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start working on the gate values. First, we set up temporary buffers for the string representations of each of the components of the gate expression: the left operand, the operation, and the right operand. The buffer sizes are chosen specifically; since l and r can be no larger than 65536, we know that 5 characters is the max storage; likewise, the longest gate operation is 6 characters. All buffers have the extra byte for the null terminator, and are initialized appropriately. We then additionally define a &lt;code&gt;char&lt;/code&gt; pointer which is used as part of the &lt;code&gt;strtoul&lt;/code&gt; error check, and finally integral values for the left and right operands of the gate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our variable initalization complete, we&amp;rsquo;ll start checking the values. For the left operand, the first thing we will check is that it is actually there, since some gates only have a single (right) operand. One useful properties of regular expressions in this case is that even if a submatch is conditional, its position in the results is still
preserved, so we know that the right operand will always have match index 3, regardless of whether the left operand and operator exist at all. If the submatch does not actually exist, member &lt;code&gt;rm_so&lt;/code&gt; of the &lt;code&gt;regmatch_t&lt;/code&gt; returned by &lt;code&gt;regexec&lt;/code&gt; will be -1.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve verified the submatch exists, we will copy just the submatch value to our temporary buffer by using the offests returned in the &lt;code&gt;regmatch_t&lt;/code&gt;. We will then attempt to convert the buffer to an unsigned long using &lt;code&gt;strtoul&lt;/code&gt;. We pass &lt;code&gt;check&lt;/code&gt; into the function; if the value of &lt;code&gt;check&lt;/code&gt; is the same as the string pointer once the operation is done and the return value is 0, we know that no number was actually found in the string and we can assume that rather than a value, it is the key to another gate and we can consequently make the recursive call. If the call returns the sentinel value and &lt;code&gt;errno&lt;/code&gt; is set, we&amp;rsquo;ll propogate that up.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we do the same for the right operand; the only difference being that we always expect the right operand to be there; if it is absent, that is considered an error and we will return appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will parse the operator. We know what the expected values are here; if the operator does not exist, we know that we are just returning the value provided by the right operand; else, we find one of the known bitwise operations and perform it, setting the return value accordingly. If the operator exists but is not an expected value, this is an error condition and we jump appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have gotten this far, we now have a final value for this gate that can be cached. We will add the value to the cache table with the gate&amp;rsquo;s key so that future calls to this gate can just return the cached value. Then we will go to the cleanup, where we make sure to free the instruction we retrieved from the hash table and free our iretrieved instruction.&lt;/p&gt;

&lt;p&gt;Now that we have our operation function implemented, we can look at the containing function for the problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identically to previous days, we parse the arguments, open the file, and copy it into memory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then compile the regular expression that splits the gate operation from its key. If this returns an unexpected result, we will jump to the error cleanup. This is a fairly simple regex, that captures two submatches: anything to the left of &lt;code&gt;-&amp;gt;&lt;/code&gt;, and then a gate key to the right of &lt;code&gt;-&amp;gt;&lt;/code&gt;, which is only letters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will set up some variables in preparation for looping over the input, including our line cursor and an array of &lt;code&gt;regmatch_t&lt;/code&gt; for capturing the gate operations and keys, which we initialize to all zeroes on declaration. Then we create the table that will hold all of the gates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        int res;
        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we loop over the input, parsing the input lines into the hash table. We first check that there is actually length ta the line; if so, then we zero out the match objects (since we aren&amp;rsquo;t declaring them inside the loop) and execute the regular expression against the line. If there is no match, we&amp;rsquo;ll break the loop and error out.&lt;/p&gt;

&lt;p&gt;Assuming all goes well, we will then declare temporary buffors for the key and value; we chose a sane length for both to avoid the need to allocate on the heap. We then use the offsets in the &lt;code&gt;regmatch_t&lt;/code&gt; to copy the key and gate operation into the buffers. Finally, we add the gate to the hash table, erroring out if there is an unexpected return from the update operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then create the expression for parsing the gate operations, which is stored in a file-local manner as mentioned before. This expression searches for an optional alphanumeric value, followed by an optional operator from the list provided in the problem specification, followed by a &lt;em&gt;required&lt;/em&gt; alphanumeric expression. If there is a problem compiling the regular expression, we&amp;rsquo;ll jump to the error handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we allocate another table to cache values. This is required due to the fact that the connections between the gates form more of a web than a tree, which can cause, if not complete short-circuits, unnecessary multiple executions of the gate to find the value. We call the operation function with the key &amp;ldquo;a&amp;rdquo; as defined in the problem statement, which will recursively call itself with the appropriate gates to calculate the final value at wire &amp;ldquo;a&amp;rdquo;, which we will then print.&lt;/p&gt;

&lt;p&gt;Now that we have solved the first problem, let&amp;rsquo;s see what the second problem will require:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, take the signal you got on wire &lt;code&gt;a&lt;/code&gt;, override wire &lt;code&gt;b&lt;/code&gt; to that signal, and reset the other wires (including wire &lt;code&gt;a&lt;/code&gt;). What new signal is ultimately provided to wire &lt;code&gt;a&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s a good thing we made that cache table! Since we didn&amp;rsquo;t alter the original instructions, all we need to do is destroy the old cache, then set value &amp;ldquo;b&amp;rdquo; in the new cache as directed in the instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once Solution 2 is printed, we can clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting the whole thing together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;pcreposix.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;
#include &amp;quot;esht.h&amp;quot;

static regex_t instr_r;

uint16_t do_op(esht *instrs, esht *cache, char *key)
{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }

    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;

    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }

    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }

    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;

    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}

int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);

    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;

    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;

    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is by far the most complex problem we have dealt with, requiring both a new data structure and the use of recursion to solve.&lt;/p&gt;

&lt;p&gt;As always, feel free to leave a comment if you have constructive feedback. We&amp;rsquo;ll be back for day 8 shortly!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>In which Nick creates a hash table</title>
      <link>/post/esht/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/esht/</guid>
      <description>&lt;p&gt;&lt;em&gt;The code discussed here can be found &lt;a href=&#34;https://github.com/e3b0c442/esht&#34; target=&#34;_blank&#34;&gt;on Github&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Before we tackle Day 7, we need to talk a bit about data structures. Choosing the proper data structures for your program&amp;rsquo;s data is extremely important in making your application both performant and easily understood.&lt;/p&gt;

&lt;p&gt;As we will see in Day 7&amp;rsquo;s discussion, we will need to be able to access an item by a provided string key. Storing these items in a linked list or array would work, but would be unnecessarily slow as the array would need to be iterated each time we try to find the item we are searching for. While there are ways to optimize this, such as by using binary search on a sorted array, these still only achieve an average time complexity of O(log(n)).&lt;/p&gt;

&lt;p&gt;The solution in this case is to use a hash table. Hash tables allow for a quick access given a piece of data (generally a string) as a key. This is accomplished by using a hashing algorithm to convert the key into a numerical value which can then be used as an array index. Given a well designed hash table, average search time can be constant time.&lt;/p&gt;

&lt;p&gt;Unfortunately, the C standard library comes with neither a hash table implementation nor a hash algorithm. POSIX defines a hash table, but it is defined and stored globally, making it effectively &lt;em&gt;non-reentrant&lt;/em&gt;. While this is of only a minor concern for us at this time, it also means that only one such table can be defined at a given time, which will likely be an issue in all but the most simple programs. GNU provides an extension which contains reentrant versions of the POSIX algorithm, but it is not available on even all UNIX platforms, most notably macOS.&lt;/p&gt;

&lt;p&gt;For these reasons, we will take some time and thought in this post to design and construct a hash table that gets around these limitations. We will have two primary design motivations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The table will be universal, so it must compile on standard C. I&amp;rsquo;m going to take this a step further and make it valid ANSI C.&lt;/li&gt;
&lt;li&gt;The table will be simple for end users. We will make a clear demarcation of responsibility for memory; each time the user adds something to the table, the key and value are copied, and the hash table owns those copies. When an item is retrieved, it is copied out. Therefore the end user is responsible for freeing all items provided to or retrieved from the table, but &lt;em&gt;not&lt;/em&gt; the copies in the table.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Regardless of platform, there are two important design decisions that need to be made when designing a hash table:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hashing algorithm&lt;/strong&gt;. The choice of hashing algorithm is very important. If a slow algorithm is used, the speed benefits of the hash table are reduced as the time to calculate hashes is high. If an algorithm with poor distributions are used, there will be additional collisions and therefore additional need to iterate over the hash buckets to find the requested item. Realistically, we need a hash algorithm which will produce a hash that fits in a standard numerical data type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Collision handling&lt;/strong&gt;. Even with a proper hash algorithm, unless you are using the full value of a modern cryptographic hash (Hint: don&amp;rsquo;t do this, they are slow and unnecessary, and you can&amp;rsquo;t use the full value anyway!), you will inevitably have collisions &amp;ndash; two identical keys which produce the same hash digest. There are two common ways to handle this: using &lt;em&gt;chaining&lt;/em&gt;, i.e. each hash key points to an array or linked list instead of a single item; or by using &lt;em&gt;open addressing&lt;/em&gt;, in which we make the primary array larger and, if an item already occupies the hash slot, iterating along the array until an open position is found.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For our hash table, we will use Daniel J. Bernstein&amp;rsquo;s DJB2a algorithm. This algorithm is simple and extremely fast, yet has reasonably good distribution. To handle collisions, we will use chaining with a singly-linked list. This reduces the complexity of adding and removing items from the chain with little to no performance penalty over an array iteration.&lt;/p&gt;

&lt;p&gt;In order to implement our hash table, we need to handle five different operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Allocating and initializing the table&lt;/li&gt;
&lt;li&gt;Inserting items into the table (or updating items already in the table)&lt;/li&gt;
&lt;li&gt;Searching for items in the table&lt;/li&gt;
&lt;li&gt;Deleting items from the table&lt;/li&gt;
&lt;li&gt;Destroying the table when we are done using it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on one&amp;rsquo;s use case, there may be a desire to separate the &lt;em&gt;adding&lt;/em&gt; and &lt;em&gt;updating&lt;/em&gt; functions. As we are trying to keep things simple though, we will keep them as one function under the assumption that if an item exists for the key, it will be updated.&lt;/p&gt;

&lt;p&gt;To start things off, we will need to create structures for the data in the table. In addition to the data itself, we need to track the key used to access the data and, since we will not be assuming a data type, the size of the data. In addition, since we are using linked-list chaining to handle collisions, we will need to have a pointer to the next item in the chain.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct esht_entry
{
    char *k;                /* key */
    void *v;                /* value */ 
    size_t l;               /* size */
    struct esht_entry *n;   /* pointer to next item in chain */
} esht_entry;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this structure defined, we can then define the structure for the table. This structures tracks both the current number of entries in the table, and the current size of the array backing the table, as well as the array itself. The size and capacity are used to calculate the &lt;em&gt;load factor&lt;/em&gt;. Generally speaking, the load factor of a hash table should be kept below 80% to ensure minimal collisions, thus keeping performance high.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct esht
{
    size_t len;             /* current size */
    size_t cap;             /* current size of backing array */
    esht_entry **entries;   /* array of pointers to entries */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these structs defined, we now have a place for all of the information that needs to be stored as part of our hash table. Now, we want to define our hash function. As mentioned before, this is Daniel J. Bernstein&amp;rsquo;s DJB2a algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned long esht_hash(char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++))
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) ^ c;

    return hash;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get down to the business of allocating and initializing the hash table. For simplicity&amp;rsquo;s sake, we are going to design our table with an initial capacity of 1. We will allocate the memory for the table struct, set the capacity and length, and allocate the memory for the backing array. We will check for errors after each allocation and return NULL on error, or return a pointer to the table struct if everything goes as planned. Note that we will use an array of pointers to item structs, rather than making an array of item structs themselves; this will simplify the addition and removal of items later on. We also use &lt;code&gt;malloc&lt;/code&gt; to allocate the table, but &lt;code&gt;calloc&lt;/code&gt; to allocate the array. This is because we will explicitly initialize the table members, but the array will just have &lt;code&gt;NULL&lt;/code&gt; pointers to start since there are no items. (The value of a &lt;code&gt;NULL&lt;/code&gt; pointer is &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;esht *esht_create()
{
    esht *table;

    table = malloc(sizeof(esht)); 
    if (table == NULL)
        return NULL;

    table-&amp;gt;cap = 1;
    table-&amp;gt;len = 0;
    table-&amp;gt;entries = calloc(1, sizeof(esht_entry *));
    if (table-&amp;gt;entries == NULL)
    {
        free(table);
        return NULL;
    }

    return table;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a table, we can start doing operations on it. However, there is one common piece of code that can be factored out, and that is the &lt;em&gt;resize&lt;/em&gt; operation, which will resize the backing array and redistribute the elements.&lt;/p&gt;

&lt;p&gt;A bit of explanation: In order to not consume an inordinate amount of memory (e.g. 2**32 * sizeof(esht_entry *)), we don&amp;rsquo;t actually use the full hash value, but the modulus of the hash value against the capacity of the array. The size of the array then becomes the second operand of the modulus. The side effect of this is that the array lookup index will change any time the array is resized, so we need to recompute the lookup index by re-hashing and modulizing the key.&lt;/p&gt;

&lt;p&gt;What this means is that you want to be judicious with resizing, as there will be a performance hit while the entirety of the table&amp;rsquo;s keys are hashed again. For our table, we are setting a maximum load factor of 0.75 and a minimum load factor of 0.25, and then either doubling or cutting in half the size once those limits are breached. This allows for a bit of hysteresis, so that if there are several insert or delete operatinos close to either limit, the table wouldn&amp;rsquo;t be resized on every insert/delete. If we wanted to simplify further, we could remove the minimum load factor and only allow the table to grow, but this potentially causes a memory leak.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_resize(esht *table, size_t new_cap)
{
    /* declare variables at the beginning to conform with ANSI C */
    int i, ii;
    esht_entry *cur, *next, **old;

    /* allocate and zero out a new backing array */
    esht_entry **new_entries = calloc(new_cap, sizeof(esht_entry *));
    if (new_entries == NULL)
        return 1;

    /* iterate over the old array... */
    for (i = 0; i &amp;lt; table-&amp;gt;cap; i++)
    {
        /* ...and then over the chains, recompute the hash index for each item, 
           and insert the item into the new array */
        next = table-&amp;gt;entries[i];
        while (next != NULL)
        {
            cur = next;
            next = cur-&amp;gt;n;

            ii = esht_hash(cur-&amp;gt;k) % new_cap;
            cur-&amp;gt;n = new_entries[ii];
            new_entries[ii] = cur;
        }
    }

    /* replace the old array with the new array, and free the old array */
    old = table-&amp;gt;entries;
    table-&amp;gt;entries = new_entries;
    table-&amp;gt;cap = new_cap;
    free(old);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One additional factored-out operation is finding the value for a key. This is used both by our searching and adding (read: updating) operations, and returns a pointer to the table entry for either updating or copying out a value to return.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;esht_entry *esht_get_entry(esht *table, char *key)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;

    /* hash the key and perform a modulus against the table capacity to get the
       lookup index */
    i = esht_hash(key) % table-&amp;gt;cap;

    /* iterate the chain until a matching key is found and return the entry */
    e = table-&amp;gt;entries[i];
    while (e != NULL)
    {
        if (!strcmp(key, e-&amp;gt;k))
            return e;
        e = e-&amp;gt;n;
    }

    /* if no entry is found, return NULL */
    return NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get down to the meat and potatoes: adding (updating), finding, and removing items from the table. First, we will write our insertion function. This function searches for an existing item with the same key and updates it; absent an existing item for the key, it allocates a new item and inserts it into the table. Finally, if the insertion causes the load factor to be exceeded, the table is resized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_update(esht *table, char *key, void *value, size_t len)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;
    void *v, *k, *old;

    /* find an existing entry for the key... */
    e = esht_get_entry(table, key);
    if (e != NULL)
    {
        /* allocate memory for and copy the value */
        v = malloc(len);
        if (v == NULL)
            return 1;
        memcpy(v, value, len);

        /* replace the value, update the value size, and free the old value */
        old = e-&amp;gt;v;
        e-&amp;gt;l = len;
        e-&amp;gt;v = v;
        free(old);

        return 0;
    }

    /* ...or allocate memory for a new entry */
    e = malloc(sizeof(esht_entry));
    if (e == NULL)
        return 1;

    /* allocate for and copy the value */
    v = malloc(len);
    if (v == NULL)
    {
        free(e);
        return 1;
    }
    memcpy(v, value, len);

    /* allocate for and copy the key */
    k = malloc(strlen(key) + 1);
    if (k == NULL)
    {
        free(e);
        free(v);
        return 1;
    }
    strcpy(k, key);

    /* set the entry variables */
    e-&amp;gt;k = k;
    e-&amp;gt;v = v;
    e-&amp;gt;l = len;

    /* hash the key and perform a modulus against the table capacity to get the
       lookup index */
    i = esht_hash(key) % table-&amp;gt;cap;

    /* insert the item into the table and update the size */
    e-&amp;gt;n = table-&amp;gt;entries[i];
    table-&amp;gt;entries[i] = e;
    table-&amp;gt;len++;

    /* if the load factor has been exceeded, resize the backing array */
    if ((float)table-&amp;gt;len / (float)table-&amp;gt;cap &amp;gt; ESHT_MAX_FACTOR)
        if (esht_resize(table, table-&amp;gt;cap * 2))
            return 1;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve already written most of the logic for finding an item; we&amp;rsquo;ll use that to find the item, then copy the value out to the end user. For end-user friendliness, we return a pointer to the value and not an entry struct. If the caller needs to know the size of the data (i.e. it is not a &lt;code&gt;NULL&lt;/code&gt;-terminated string or known data size), they can pass a pointer to a &lt;code&gt;size_t&lt;/code&gt; value, in which we can place the size of the data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *esht_get(esht *table, char *key, size_t *len)
{
    /* declare variables for ANSI C conformance */
    esht_entry *e;
    void *r;

    /* find an existing entry. If there is no entry matching the key, set the 
       value of the length pointer to 0 and return NULL */
    e = esht_get_entry(table, key);
    if (e == NULL)
    {
        if (len != NULL)
            *len = 0;
        return NULL;
    }

    /* allocate memory for and copy the value of the table entry */
    r = malloc(e-&amp;gt;l);
    if (r == NULL)
    {
        if (len != NULL)
            *len = 0;
        return NULL;
    }
    memcpy(r, e-&amp;gt;v, e-&amp;gt;l);

    /* if a valid pointer was provided, set the length of the return data, then
       return a pointer to the copied value */
    if (len != NULL)
        *len = e-&amp;gt;l;
    return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we will provide a way for end users to remove items from the table that are no longer needed. This function takes the key as an argument and returns &lt;code&gt;1&lt;/code&gt; if no item was found, or &lt;code&gt;0&lt;/code&gt; if the item was found and successfully removed. Then the table is resized if the load factor exceeds the minimum value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_remove(esht *table, char *key)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;

    /* hash and modulus the key. Note: we are not reusing the esht_get_entry
       function here because we need to know the previous item in the chain */
    i = esht_hash(key) % table-&amp;gt;cap;
    e = table-&amp;gt;entries[i];

    /* if the initial lookup is NULL, the item does not exist */
    if (e == NULL)
        return 1;

    /* otherwise, check the first key, and if the key matches, adjust the chain */
    if (!strcmp(e-&amp;gt;k, key))
    {
        table-&amp;gt;entries[i] = e-&amp;gt;n;
        goto cleanup;
    }

    /* If the first key did not match, iterate the table until it is found and
       adjust the chain */
    while (e-&amp;gt;n != NULL)
    {
        if (!strcmp(e-&amp;gt;n-&amp;gt;k, key))
        {
            e-&amp;gt;n = e-&amp;gt;n-&amp;gt;n;
            goto cleanup;
        }
    }

    return 1;

    /* This jump is only taken if a valid entry is found */
cleanup:
    /* Free the key, value, and entry struct */
    free(e-&amp;gt;k);
    free(e-&amp;gt;v);
    free(e);

    /* adjust the table size and resize if needed */
    table-&amp;gt;len--;
    if ((float)table-&amp;gt;len / (float)table-&amp;gt;cap &amp;lt; ESHT_MIN_FACTOR)
        if (esht_resize(table, table-&amp;gt;cap / 2))
            return 1;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a table to which we can add, find, and remove items. Now, we need to be able to clean the table up. The destroy function iterates the backing array and chains, frees the key and value of every entry and then the entry itself, frees the backing array, then finally frees the table struct.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void esht_destroy(esht *table)
{
    /* declare variables for ANSI C conformance */
    int i;
    esht_entry *e, *n;

    /* iterate the backing array... */
    for (i = 0; i &amp;lt; table-&amp;gt;cap; i++)
    {
        /* and then the chains, freeing all keys, values, and entries */
        e = table-&amp;gt;entries[i];
        while (e != NULL)
        {
            n = e-&amp;gt;n;
            free(e-&amp;gt;k);
            free(e-&amp;gt;v);
            free(e);
            e = n;
        }
    }

    /* free the backing array and then the table itself */
    free(table-&amp;gt;entries);
    free(table);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an ANSI-C compliant, end-user-friendly hash table. The end user is  responsible for managing items provided to or retrieved from the table, and is insulated from accidentally changing internal table values. The end user only needs to know about the table struct itself; the entry struct is internal-only and the find operation returns a pointer to a copy of the value with an optional length.&lt;/p&gt;

&lt;p&gt;We will use this table to complete Day 7 in the next post. Until then, your
comments, criticisms, and inputs are appreciated in the comments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The YubiKey; or, why are you still using a password in 2019?</title>
      <link>/post/yubikey/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/yubikey/</guid>
      <description>&lt;p&gt;&lt;em&gt;Note: I am not receiving any compensation either for what I&amp;rsquo;m saying here or
for the product links on this page. I think the YubiKey is a great product, and
I want to share why.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With the upcoming release of macOS Catalina &amp;ndash; and with it, the end of the last
major browser holdout from the &lt;a href=&#34;https://fidoalliance.org&#34; target=&#34;_blank&#34;&gt;FIDO&lt;/a&gt; standards, I
wanted to take a moment to talk about the YubiKey and the promise of the
standards that it supports for secure internet authentication.&lt;/p&gt;

&lt;p&gt;Before we dive into the YubiKey itself, I&amp;rsquo;d like to explain why this is
important to me. The economic impact of compromised accounts is astronomical;
according to a 2018 &lt;a href=&#34;https://www.mcafee.com/us/resources/reports/restricted/economic-impact-cybercrime.pdf?utm_source=Press&amp;amp;utm_campaign=bb9303ae70-EMAIL_CAMPAIGN_2018_02_21&amp;amp;utm_medium=email&amp;amp;utm_term=0_7623d157be-bb9303ae70-&#34; target=&#34;_blank&#34;&gt;study&lt;/a&gt;
by the &lt;a href=&#34;https://csis.org&#34; target=&#34;_blank&#34;&gt;Center for Strategic and International Studies&lt;/a&gt; in
collaboration with McAfee, the economic impact of cyber crime is nearly $600
billion per year, or 1% of total global GDP. At the same time, password security
is either misunderstood or ignored by both end users and system administrators
alike; &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_the_most_common_passwords&#34; target=&#34;_blank&#34;&gt;according to multiple sources&lt;/a&gt;,
the most commonly-used password in recent years is &lt;code&gt;123456&lt;/code&gt;. In addition,
password requirements vary greatly amongst services, with many still enforcing
maximum length limits and the use of special characters (or limitation of
characters) &lt;a href=&#34;https://xkcd.com/936/&#34; target=&#34;_blank&#34;&gt;despite mathematical evidence&lt;/a&gt; that the use
of easy-to-remember long passphrases is far more secure than requiring multiple
special characters in a shorter password. Simply put - passwords need to be put
out to pasture.&lt;/p&gt;

&lt;p&gt;With what do we replace passwords? Public key cryptography has been widely-used
and battle-tested for decades &amp;ndash; every time you visit a site with the &lt;code&gt;https&lt;/code&gt;
URL scheme, you are using it! &amp;ndash; and while some implementations have been shown
to have weaknesses over time, the basic concepts are solid. As long as the
private key can be protected, public key cryptograhy is an effective method of
authenticating an end user and encrypting communications, which is where the
YubiKey comes in.&lt;/p&gt;

&lt;p&gt;If you are not familiar with the YubiKey, it is a multi-protocol hardware
cryptographic token. The premise behind this kind of token is that the secret
key is stored on the token and the token itself performs cryptographic
operations using the key without making it accessible to the host system, thus
preventing the key from being siphoned off by an unscrupulous actor. The latest
generation YubiKey 5 family has support for the following protocols:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;USB HID&lt;/strong&gt;: these protocols take advantage of the capability of the YubiKey
to act as a keyboard and send data as keystrokes:

&lt;ul&gt;
&lt;li&gt;Static password: The YubiKey can generate a secure password that can be
combined with an easy-to-remember value to simulate a 2nd-factor auth.&lt;/li&gt;
&lt;li&gt;Yubico OTP: A custom OTP implementation that relies on a shared key known
by the YubiKey and the server. Yubico provides this service for all
fresh-from-factory YubiKeys; if you don&amp;rsquo;t trust Yubico with your key, you can
run the service by yourself and reprogram your YubiKey with a new shared key.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OTP (One-time password)&lt;/strong&gt;: These protocols allow for time- or event-based
one-time passwords:

&lt;ul&gt;
&lt;li&gt;OATH-TOTP: This is the same protocol utilized by the nearly-ubiquitous
mobile authenticators out there. In the case of the YubiKey, the one-time
password values are read from the key with a special Yubico Authenticator
application.&lt;/li&gt;
&lt;li&gt;OATH-HOTP: This one-time password mechanism is not nearly as commonly used
due to its reliance on counters and susceptibility to synchronization
issues.&lt;/li&gt;
&lt;li&gt;HMAC-SHA1 Challenge/Response: This protocol relies on a shared secret. The
remote party sends a challenge, and the YubiKey calculates the HMAC-SHA1 code
of the challenge using the shared secret, and returns it to the remote party.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CCID (Smart cards)&lt;/strong&gt;: These protocols allow the YubiKey to emulate smart
cards:

&lt;ul&gt;
&lt;li&gt;OpenPGP: The YubiKey acts as an OpenPGP smart card, with three key slots
available. The YubiKey then performs all sign/encrypt/decrypt operations using
the stored keys.&lt;/li&gt;
&lt;li&gt;PIV: The YubiKey acts as a PIV card and can be accessed using the standard
PKCS#11 protocols. In addition to raw keys, the PIV applet can store
certificates and generate CSRs, allowing for the keys to be certified and have
enforced expiration and revocation capabilities.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIDO (web authentication)&lt;/strong&gt;: These protocols allow for the usage of public
key cryptography for authentication in the Web browser:

&lt;ul&gt;
&lt;li&gt;U2F, aka CTAP1: This protocol allows for 2nd-factor authentication using the
private key stored on the YubiKey. It was never standardized beyond FIDO and
thus there are implementation and support issues across common browsers.&lt;/li&gt;
&lt;li&gt;FIDO2, aka CTAP2: This protocol is backwards-compatible with CTAP1, and
works in concert with the W3C WebAuthn standard to allow not only 2nd-factor
authentication, but completely passwordless authentication. This is the future
of web authentication.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to the fully-featured Yubikey 5 line, Yubico offers a &amp;ldquo;Security Key&amp;rdquo;
line which only support the FIDO protocols. For the majority of people out
there, this is sufficient.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.w3.org/TR/webauthn/&#34; target=&#34;_blank&#34;&gt;WebAuthn&lt;/a&gt; is a recently ratified standard by
the W3C specifying a JavaScript API for facilitating authentication with public
key cryptography. This works together with the &lt;a href=&#34;https://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html&#34; target=&#34;_blank&#34;&gt;CTAP device protocols&lt;/a&gt;
to enable the web browser to communicate with a CTAP-compatible USB device and
use it to securely authenticate a user to a service. Per the &lt;a href=&#34;https://fidoalliance.org/fido2&#34; target=&#34;_blank&#34;&gt;FIDO2&lt;/a&gt;
website: &lt;code&gt;FIDO2 cryptographic login credentials are unique across every website, never leave the user’s device and are never stored on a server. This security model eliminates the risks of phishing, all forms of password theft and replay attacks.&lt;/code&gt; The FIDO2 protocol also supports requiring a local second
factor such as physical presence (push the button) or a PIN. In the case of a
PIN, this can be a simpler value as it is never transmitted over the Internet
nor stored outside of the device.&lt;/p&gt;

&lt;p&gt;I utilize my YubiKey 4 as much as possible. I use the PIV applet to log in
locally to my computers; the OpenPGP  applet to store my PGP auth, signing, and
encryption keys that I use for signing git commits or remotely logging into
servers. I utilize Yubico OTP as a second factor on my most sensitive servers as
well as the secnod factor on my password manager. I utilize FIDO U2F wherever
possible (Google, AWS, Facebook). I understand I am a power user, and that many
of these use cases are quite advanced, but I simply see too much value in
eschewing the world of the password and moving exclusively to public-key
cryptography, now that I have the tools to do it. I only wish more things
supported it, e.g. LUKS, which still requires a passphrase.&lt;/p&gt;

&lt;p&gt;Regardless of your level of expertise, I hope you are at least using a
&lt;a href=&#34;https://www.yubico.com/products/security-key-3/&#34; target=&#34;_blank&#34;&gt;Security Key&lt;/a&gt;. If not, get
one ASAP, and pressure every provider that does not yet support WebAuthn/FIDO2
to build that support as soon as possible. Hopefully we can start seeing that
$600 billion number trend downward as more people adopt YubiKeys or other
FIDO2-compliant devices.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 6: Probably a Fire Hazard</title>
      <link>/post/advent-2015-c-6/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-6/</guid>
      <description>&lt;p&gt;Welcome back to my Advent of Code series. I hope you&amp;rsquo;re enjoying exploring these
problems in depth in C. Let&amp;rsquo;s take a look at the problem for day 6:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because your neighbors keep defeating you in the holiday house decorating contest year after year, you&amp;rsquo;ve decided to deploy one million lights in a 1000x1000 grid.&lt;/p&gt;

&lt;p&gt;Furthermore, because you&amp;rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.&lt;/p&gt;

&lt;p&gt;Lights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at &lt;code&gt;0,0&lt;/code&gt;, &lt;code&gt;0,999&lt;/code&gt;, &lt;code&gt;999,999&lt;/code&gt;, and &lt;code&gt;999,0&lt;/code&gt;. The instructions include whether to &lt;code&gt;turn on&lt;/code&gt;, &lt;code&gt;turn off&lt;/code&gt;, or &lt;code&gt;toggle&lt;/code&gt; various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like &lt;code&gt;0,0 through 2,2&lt;/code&gt; therefore refers to 9 lights in a 3x3 square. The lights all start turned off.&lt;/p&gt;

&lt;p&gt;To defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 999,999&lt;/code&gt; would turn on (or leave on) every light.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,0&lt;/code&gt; would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;turn off 499,499 through 500,500&lt;/code&gt; would turn off (or leave off) the middle four lights.&lt;/li&gt;
&lt;li&gt;After following the instructions, &lt;strong&gt;how many lights are lit&lt;/strong&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s look at our constituent problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Set up a grid&lt;/li&gt;
&lt;li&gt;Parse the input lines&lt;/li&gt;
&lt;li&gt;Follow the input instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We already know how to read our file into memory, so we&amp;rsquo;ll move onto setting up
the grid. As with &lt;a href=&#34;/post/advent-2015-c-3/&#34; target=&#34;_blank&#34;&gt;Day 3&lt;/a&gt;, we will use a
two-dimensional array to represent the grid. Unlike day 3, we know in advance
what the size of the grid is, so we don&amp;rsquo;t need to do an extra loop to size it;
we can just declare &lt;code&gt;bool grid[1000][1000]&lt;/code&gt;, initialize, and move on.&lt;/p&gt;

&lt;p&gt;Likewise, parsing the input lines is also a situation we have previously
encountered. In previous days, we have used &lt;a href=&#34;/post/advent-2015-c-2/&#34; target=&#34;_blank&#34;&gt;scanners&lt;/a&gt; and &lt;a href=&#34;/post/advent-2015-c-5/&#34; target=&#34;_blank&#34;&gt;regular expressions&lt;/a&gt;. While using scanners is ideal for simple situations,
we have to remember the downsides: scanners are tokenized by any whitespace, and
scanners cannot safely be used to scan into strings. Both of these cases are
disqualifiers for our input; we have a component of the input that might have a
space in it, and we also need to scan into a string. For this reason, we&amp;rsquo;ll use
regular expressions to parse our input. Because we can only parse into strings
with regular expressions, we will also need to convert our number strings to
numerical values.&lt;/p&gt;

&lt;p&gt;Once we have our values, we can use them to set up a nested loop to update the
values on the grid.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 6:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is our now familiar check for argument, read input, and print preamble,
included only for completeness at this point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t inst_r;
    int result = regcomp(&amp;amp;inst_r, &amp;quot;\\(turn on\\|turn off\\|toggle\\) \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\) through \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we compile the regular expression to match against. Without the escape
characters, this expression looks like: &lt;code&gt;(turn on|turn off|toggle) ([[:digit:]]{1,}),([[:digit:]]{1,}) through ([[:digit:]]{1,}),([[:digit:]]{1,})&lt;/code&gt;.
Reading this expression aloud, we get &lt;em&gt;Capture a group containing &amp;ldquo;turn on&amp;rdquo;,
&amp;ldquo;turn off&amp;rdquo;, or &amp;ldquo;toggle&amp;rdquo;. Find a space. Capture a group of one or more digits,
then find a comma, then capture a group of one or more digits. Find the phrase
&amp;ldquo; through &amp;ldquo;. Capture a group of one or more digits, then find a comma, then
capture a group of one or more digits.&lt;/em&gt; At the end of it, we have captured five submatches; one for the command, and then one each for the low and high X and Y coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now prepare to start our loop. We create the cursor variable and get the
first line, declare an array to hold the regular expression match coordinates
and initialize it, and declare and initialize the grid array. Note that we use
&lt;code&gt;memset&lt;/code&gt; for the grid array because the &lt;code&gt;{0}&lt;/code&gt; initialization shorthand cannot be
used with multidimensional arrays. Also note that we declared a six member array
for the regular expression matches; the first match is always the full matched
string, so we need room for this plus the five submatches that we actually care
about.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 6 * sizeof(regmatch_t));
        result = regexec(&amp;amp;inst_r, line, 6, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char instr[9] = {0};
        char oxs[4] = {0};
        char oys[4] = {0};
        char dxs[4] = {0};
        char dys[4] = {0};

        strncpy(instr, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(oxs, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);
        strncpy(oys, line + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        strncpy(dxs, line + matches[4].rm_so, matches[4].rm_eo - matches[4].rm_so);
        strncpy(dys, line + matches[5].rm_so, matches[5].rm_eo - matches[5].rm_so);

        unsigned long ox = strtoul(oxs, NULL, 10);
        if (ox == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long oy = strtoul(oys, NULL, 10);
        if (oy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dx = strtoul(dxs, NULL, 10);
        if (dx == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dy = strtoul(dys, NULL, 10);
        if (dy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;

        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = true;
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = false;
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = !grid[x][y];
        }
        else
        {
            goto err_cleanup;
        }

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we perform our loop on each of the input lines, parsing and following the
directions. We&amp;rsquo;ll zero out the match array, then execute the compiled regular
expression against the input line. We then initialize destination variables for
each of the five submatch values, and use the match coordinates to copy the
matched substrings into the destination variables.&lt;/p&gt;

&lt;p&gt;Once the destination variables are populated, we&amp;rsquo;ll use &lt;code&gt;strtoul&lt;/code&gt; to parse the
four numerical values into integral equivalents, giving us the final set of
parsed values to handle our input.&lt;/p&gt;

&lt;p&gt;At this point, we use strcmp to compare the instruction string against the known
instructions, and then set up a nested loop using the X and Y values. Finally,
the interior of the loop sets the value of that coordinate per the instruction.
You&amp;rsquo;ll notice that we parsed the instruction first, requiring the loop to be
specified multiple times, seemingly breaking the &lt;em&gt;don&amp;rsquo;t-repeat-yourself&lt;/em&gt; rule.
In this case, however, this is justified, as if we reversed things, the string
comparison would need to be done for each position, which would be prohibitvely
computationally expensive. Once the loop is complete, the values of the grid
are set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
            if (grid[x][y])
                on++;

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get our solution, we set up a counter variable and then another
nested loop over the entire two-dimensional surface. Each time we encounter
a &lt;code&gt;true&lt;/code&gt; value, we increment the counter. We then print our solution.&lt;/p&gt;

&lt;p&gt;After submitting the solution, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You just finish implementing your winning light pattern when you realize you mistranslated Santa&amp;rsquo;s message from Ancient Nordic Elvish.&lt;/p&gt;

&lt;p&gt;The light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn on&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn off&lt;/code&gt; actually means that you should decrease the brightness of those lights by &lt;code&gt;1&lt;/code&gt;, to a minimum of zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;toggle&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What is the &lt;strong&gt;total brightness&lt;/strong&gt; of all lights combined after following Santa&amp;rsquo;s instructions?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 0,0&lt;/code&gt; would increase the total brightness by 1.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,999&lt;/code&gt; would increase the total brightness by 2000000.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with previous problems, this one is simalar, and we can implement it in the
existing loop to avoid the need to loop the input a second time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    int grid2[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
    memset(grid2, 0, 1000 * 1000 * sizeof(int));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will declare a second grid variable, this time of type &lt;code&gt;int[][]&lt;/code&gt;, since we
need to track more than just on or off.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = true;
                    grid2[x][y]++;
                }
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = false;
                    grid2[x][y] = grid2[x][y] &amp;gt; 0 ? grid2[x][y] - 1 : 0;
                }
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = !grid[x][y];
                    grid2[x][y] += 2;
                }
        }
        else
        {
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The instructions are equivalent for both loops; we just need to add the
application of the instructions to the second grid following the second
transation&amp;rsquo;s directions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    int bright = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
        {
            if (grid[x][y])
                on++;
            bright += grid2[x][y];
        }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, bright);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll add a second counter variable and perform the addition during the same
nested loop as the first solution, and then print both solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    regfree(&amp;amp;inst_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we will clean up. As before, we need to call &lt;code&gt;regfree&lt;/code&gt; to free the
compiled regular expression in addition to freeing the input.&lt;/p&gt;

&lt;p&gt;Our problems are gradually getting more difficult, but we&amp;rsquo;re almost a week
through! Day seven&amp;rsquo;s solution requires implementing a new data structure, so our
next article will take a break to discuss this in detail.&lt;/p&gt;

&lt;p&gt;As always, comments, criticism, and banter are welcome, just leave a comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 5: Doesn&#39;t He Have Intern-Elves For This?</title>
      <link>/post/advent-2015-c-5/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-5/</guid>
      <description>&lt;p&gt;Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we
are going to look at day 5:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa needs help figuring out which strings in his text file are naughty or nice.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;nice string&lt;/strong&gt; is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains at least three vowels (&lt;code&gt;aeiou&lt;/code&gt; only), like &lt;code&gt;aei&lt;/code&gt;, &lt;code&gt;xazegov&lt;/code&gt;, or &lt;code&gt;aeiouaeiouaeiou&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It contains at least one letter that appears twice in a row, like &lt;code&gt;xx&lt;/code&gt;, &lt;code&gt;abcdde&lt;/code&gt; (&lt;code&gt;dd&lt;/code&gt;), or &lt;code&gt;aabbccdd&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;bb&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt;, or &lt;code&gt;dd&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;It does &lt;strong&gt;not&lt;/strong&gt; contain the strings &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;pq&lt;/code&gt;, or &lt;code&gt;xy&lt;/code&gt;, even if they are part of one of the other requirements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ugknbfddgicrmopn&lt;/code&gt; is nice because it has at least three vowels (&lt;code&gt;u...i...o...&lt;/code&gt;), a double letter (&lt;code&gt;...dd...&lt;/code&gt;), and none of the disallowed substrings.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aaa&lt;/code&gt; is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jchzalrnumimnmhp&lt;/code&gt; is naughty because it has no double letter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;haegwjzuvuyypxyu&lt;/code&gt; is naughty because it contains the string &lt;code&gt;xy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dvszwmarrgswjxmb&lt;/code&gt; is naughty because it contains only one vowel.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s begin by breaking down the problem. We need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Split the input into its components&lt;/li&gt;
&lt;li&gt;Determine whether the string meets the naughty or nice requirements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first two parts of this problem are familiar, and generally speaking,
identical. We&amp;rsquo;ll use the variable &lt;code&gt;good&lt;/code&gt; to track the good strings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part, however, is the most difficult problem that has yet been
presented. How are we going to check the strings?&lt;/p&gt;

&lt;p&gt;While it might be tempting to loop over the strings and implement tracking
variables to check these conditions (and, depending on the implementation, might
be faster), the more appropriate tool in this situation is regular expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the three rules can be checked using a valid POSIX basic regular
expression (note that in the code snippet above, the appropriate escape
characters have been added):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;at least 3 vowels: &lt;code&gt;[aeiou].*[aeiou].*[aeiou]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a letter a, e, i, o, or u. Then find
zero or more of any character, then a letter a,e,i,o,u, then zero or more of
any character, then a, e, i, o, or u.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;at least one letter that occurs twice in a row: &lt;code&gt;(.)\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression uses a backreference to refer to a prior character.
It says: &lt;em&gt;find a group containing any one character, then find the first
group&lt;/em&gt;. In this case, the first group is the matched one character.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;does not contain ab, cd, pq, xy: &lt;code&gt;(ab|cd|pq|xy)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;ll actually be looking for a negative result on this one because it is
simpler than trying to do the negation in the expression itself. This
expression says, &lt;em&gt;find the strings ab or cd or pq or xy&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We compile the expressions once to be used to quickly match the strings as we
loop through the input:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);

    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If rule 3 does not match (we put this one in front to short-circuit, since if
it matches the string is automatically invalid) and rules 1 and 2 match, then
the string is a good string. Note that this appears backwards due to &lt;code&gt;regexec&lt;/code&gt;
returning 0 on match and 1 on no match. We output the counted good strings for
our solution.&lt;/p&gt;

&lt;p&gt;Then, we just need to clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our solution submitted, we then get our second problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.&lt;/p&gt;

&lt;p&gt;Now, a nice string is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains a pair of any two letters that appears at least twice in the string without overlapping, like &lt;code&gt;xyxy&lt;/code&gt; (&lt;code&gt;xy&lt;/code&gt;) or &lt;code&gt;aabcdefgaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;), but not like &lt;code&gt;aaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, but it overlaps).&lt;/li&gt;
&lt;li&gt;It contains at least one letter which repeats with exactly one letter between them, like &lt;code&gt;xyx&lt;/code&gt;, &lt;code&gt;abcdefeghi&lt;/code&gt; (&lt;code&gt;efe&lt;/code&gt;), or even &lt;code&gt;aaa&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qjhvhtzxzqqjkmpb&lt;/code&gt; is nice because is has a pair that appears twice (&lt;code&gt;qj&lt;/code&gt;) and a letter that repeats with exactly one letter between them (&lt;code&gt;zxz&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xxyxx&lt;/code&gt; is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uurcxstgmygtbstg&lt;/code&gt; is naughty because it has a pair (&lt;code&gt;tg&lt;/code&gt;) but no repeat with a single letter between them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ieodomkazucvgmuy&lt;/code&gt; is naughty because it has a repeating letter with one between (&lt;code&gt;odo&lt;/code&gt;), but no pair that appears twice.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice under these new rules?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As expected, the problem is very similar, if slightly more complicated. The good
news is that these rules can also be checked with valid POSIX basic regular
expressions, so we can easily add the new rules to the existing loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two new rules are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pair of two letters that appear at least twice in the string without
overlapping: &lt;code&gt;(..).*\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with two of any character, then
find zero or more of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;one letter which repeats with exactly one letter between: &lt;code&gt;(.).\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with one of any character, then
find one of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are again compiled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add a second check for the two new rules, with a separate counter, then print
the second result after the first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we clean up the new compiled regexes in addition to the previous ones.&lt;/p&gt;

&lt;p&gt;All together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);

    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;

    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);

    goto cleanup;

err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just one instance where a problem that is potentially complex can be
simplified with regular expressions (note: this goes both ways!)&lt;/p&gt;

&lt;p&gt;As always, if you have questions, comments, or suggestions, feel free to leave
a comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 4: The Ideal Stocking Stuffer</title>
      <link>/post/advent-2015-c-4/</link>
      <pubDate>Tue, 10 Sep 2019 03:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-4/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m back for a second time today since this puzzle is fairly straightforward:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.&lt;/p&gt;

&lt;p&gt;To do this, he needs to find MD5 hashes which, in hexadecimal, start with at least &lt;strong&gt;five zeroes&lt;/strong&gt;. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &amp;hellip;) that produces such a hash.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If your secret key is &lt;code&gt;abcdef&lt;/code&gt;, the answer is &lt;code&gt;609043&lt;/code&gt;, because the MD5 hash of &lt;code&gt;abcdef609043&lt;/code&gt; starts with five zeroes &lt;code&gt;(000001dbbfa...&lt;/code&gt;), and it is the lowest such number to do so.&lt;/li&gt;
&lt;li&gt;If your secret key is &lt;code&gt;pqrstuv&lt;/code&gt;, the lowest number it combines with to make an MD5 hash starting with five zeroes is &lt;code&gt;1048970&lt;/code&gt;; that is, the MD5 hash of &lt;code&gt;pqrstuv1048970&lt;/code&gt; looks like &lt;code&gt;000006136ef...&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As always, we&amp;rsquo;ll start with breaking down the problem into discrete parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input&lt;/li&gt;
&lt;li&gt;Convert a number to a string&lt;/li&gt;
&lt;li&gt;Combine the input and the number string&lt;/li&gt;
&lt;li&gt;Get the MD5 digest of the combined string&lt;/li&gt;
&lt;li&gt;Check that the first five digits of the digest are &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rather than write our own MD5 hashing implementation, we will use the well-known
and commonly-installed OpenSSL library&amp;rsquo;s implementation. You&amp;rsquo;ll need to make
sure that your linker pulls in the OpenSSL library.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s write some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the sake of completion, this is our standard prelude of verifying the
command-line argument and reading the input file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 4:\n&amp;quot;);

    /* initialize variables */
    int i = 1;
    char buf[strlen(input) + 11];
    memset(buf, 0, strlen(input) + 11);
    strcpy(buf, input);
    unsigned char digest[16];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We print our preamble, then initialize some variables. Note that I&amp;rsquo;m doing this
outside of a loop so that we do not incur this cost in the loop. Our code will
be written in such a way that the variables do not need to be reinitialized on
every pass. Step by step we have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The declaration of the iteration index &lt;code&gt;i&lt;/code&gt;, which is the number that will be
added to the input string on each pass&lt;/li&gt;
&lt;li&gt;The declaration of the buffer which stores the whole string to be hashed. We
size from the input and then add 11 &amp;ndash; 10 for the maximum number of digits in a
32-bit integer, and 1 for the null terminator.&lt;/li&gt;
&lt;li&gt;The initialization of the string buffer. Ensuring all bytes are set to &lt;code&gt;0&lt;/code&gt; now
will help us not need to re-initialize the variable on every loop&lt;/li&gt;
&lt;li&gt;Copying the input into the buffer&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Creating a buffer for the MD5 digest. MD5 digests are 128 bits, so we need a
16-byte buffer. Note that we do &lt;em&gt;not&lt;/em&gt; have a null terminator here because this
is not a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we begin the loop. W se formatted print to append the string representation
of &lt;code&gt;i&lt;/code&gt; to the buffer. Notice that we are using pointer arithmetic to point to
the first index in the buffer after the original input string. Because the
numbers will only ever increase, we will overwrite this on each loop and not
need to reinitialize the variable. We then get the MD5 digest of the constructed
string.&lt;/p&gt;

&lt;p&gt;At this point, one might be tempted to use formatted print to output the
hexadecimal representation of the digest. &lt;em&gt;Don&amp;rsquo;t!&lt;/em&gt; String formatting operations
are computationally expensive, and we have the information we need to solve
the problem without doing it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] &amp;lt; 16)
            break;
        i++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the ratio of bytes to hex characters is 1:2; that is, each byte of the
digest would translate to two hex characters. With this in mind, remember that
this digest is just one big number; so, rather than convert the number back to
a string, let&amp;rsquo;s just check the number.&lt;/p&gt;

&lt;p&gt;We are searching for a digest where the first five digits of the hexadecimal
representation of the digest are &lt;code&gt;0&lt;/code&gt;. For bytes 0 and 1, this is easy: the value
of the byte must be 0. For byte 2, it requires a little bit more thought, since
only the first digit must be zero. In this case, it&amp;rsquo;s just a matter of places
like in decimal math. There are 16 possible hexadecimal digits, so any value
of the byte that is less than 16 will have the first hex digit as 0.&lt;/p&gt;

&lt;p&gt;By checking this way and avoiding the string conversion, we cut our compute
usage down by 10-100x, which is important in this exercise as hashing is not a
fast operation, relatively speaking.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have our solution, which is the current value of &lt;code&gt;i&lt;/code&gt;. Once this is
validated, our second puzzle appears:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now find one that starts with six zeroes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, that&amp;rsquo;s succinct, isn&amp;rsquo;t it? Literally all we need to do at this point is
resume the loop right where we left off, making one change: we can check that
byte 2 of the digest is equal to zero, rather than less than 16:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (1)
    {
        sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
        MD5((const unsigned char *)buf, strlen(buf), digest);

        if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] == 0)
            break;
        i++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t even need to reset &lt;code&gt;i&lt;/code&gt; here, since by definition a digest can&amp;rsquo;t start
with six zeroes without starting with five. In the circumstance that the first
digest that begins with five zeroes also begins with six zeroes, the first
iteration of our loop will catch it because we broke out of the previous loop
before incrementing the index, and we don&amp;rsquo;t increment until the end of the loop.&lt;/p&gt;

&lt;p&gt;We now have our solution, and can print it and clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, i);

    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we put it all together, we have:&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;c
#include &lt;errno.h&gt;
#include &lt;openssl/md5.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &amp;ldquo;common.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;int main(int argc, char const &lt;em&gt;argv[])
{
    /&lt;/em&gt; check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;ldquo;Must provide filename of input file\n&amp;rdquo;);
        return -1;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* read the file into memory */
char *input;
int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
if (filesize &amp;lt; 0)
{
    fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
    return -1;
}

printf(&amp;quot;Day 4:\n&amp;quot;);

/* initialize variables */
int i = 1;
char buf[strlen(input) + 11];
memset(buf, 0, strlen(input) + 11);
strcpy(buf, input);
unsigned char digest[16];

/* find the first matching digest */
while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);

    if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] &amp;lt; 16)
        break;
    i++;
}

printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, i);

/* find the first matching digest */
while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);

    if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] == 0)
        break;
    i++;
}

printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, i);

free(input);
return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum</title>
      <link>/post/advent-2015-c-3/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-3/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve made it this far, so either nobody&amp;rsquo;s reading this, you&amp;rsquo;re all masochists,
or I&amp;rsquo;m doing OK. Let&amp;rsquo;s take a look at day 3:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa is delivering presents to an infinite two-dimensional grid of houses.&lt;/p&gt;

&lt;p&gt;He begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (&lt;code&gt;^&lt;/code&gt;), south (&lt;code&gt;v&lt;/code&gt;), east (&lt;code&gt;&amp;gt;&lt;/code&gt;), or west (&lt;code&gt;&amp;lt;&lt;/code&gt;). After each move, he delivers another present to the house at his new location.&lt;/p&gt;

&lt;p&gt;However, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; delivers presents to &lt;code&gt;2&lt;/code&gt; houses: one at the starting location, and one to the east.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; delivers presents to &lt;code&gt;4&lt;/code&gt; houses in a square, including twice to the house at his starting/ending location.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; delivers a bunch of presents to some very lucky children at only 2 houses.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;This problem seems pretty simple on the face of it, but let&amp;rsquo;s break it down. We
will need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input from the file&lt;/li&gt;
&lt;li&gt;Iterate over the input&lt;/li&gt;
&lt;li&gt;Track which locations have been visited&lt;/li&gt;
&lt;li&gt;Count the visited locations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to track the location, we&amp;rsquo;ll need to use a slightly more advanced data
structure. Since we are working with quantities in 2D space, a 2D array makes
sense. Thankfully, in newer versions of the C standard, the array sizes do not
need to be known at compile time, so we can avoid some messy pointer arithmetic.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get to work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this looks familiar, you&amp;rsquo;re catching on. We check that the filename is
provided, read the input file to memory, and handle any errors.&lt;/p&gt;

&lt;p&gt;Now we&amp;rsquo;re ready to get started&amp;hellip; but are we? We still have no idea how big
our grid array needs to be. We could guess, but we run the danger of either
making the arrays too small and going out-of-bounds, or making them too big and
unnecessarily tying up memory. The better plan would be to iterate over the
input and test the constraints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After printing our preamble, we&amp;rsquo;ll create tracking variables for the current x
and y positions, and the minimum and maximums of both. We&amp;rsquo;ll initialize all of
them to zero, and then iterate over the input, adjusting the current value of
x and y and keeping the maximums and minimums updated as needed. Once the loop
is complete, we have enough information to compute the sizes of the arrays. Note
that we need to add 1 to the total; e.g. &lt;code&gt;1 - (-1) = 2&lt;/code&gt;, but that covers the
values &lt;code&gt;-1, 0, 1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the grid and travel again */
    bool grid[w][h];
    memset(grid, 0, w * h * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the sizes, we can declare the two-dimensional array. Again,
older versions of the C standard do not allow runtime determination of the array
sizes for stack declarations; if you are stuck using an old version, you will
need to allocate the array on the heap with &lt;code&gt;malloc&lt;/code&gt; or the like. Since we only
need to track if a house has been visited or not, we&amp;rsquo;ll use the &lt;code&gt;bool&lt;/code&gt; data type
for our grid. The more astute reader might know that &lt;code&gt;bool&lt;/code&gt; is still represented
with a full byte in C, but we can still use the type as a hint to those who
might read your code as to the function.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve declared the array, we will need to initialize it; while we can
declare the array in this fashion now, we still cannot initialize it at
declaration. We&amp;rsquo;ll use the &lt;code&gt;memset&lt;/code&gt; function to zero out the allocated arrays.
This is safe with our &lt;code&gt;bool&lt;/code&gt; data type as &lt;code&gt;false&lt;/code&gt; is represented as 0.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll set our initial indices for x and y for the upcoming run. Since
we cannot have negative indices in an array, we&amp;rsquo;ll need to offset them using the
minimum values previously found.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    grid[x][y] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }
        grid[x][y] = true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re finally ready to gather our data. We&amp;rsquo;ll iterate through the input again,
flipping the value on the grid to true as we visit each space. Notice that we
set the origin space to &lt;code&gt;true&lt;/code&gt; as well per the problem parameters (&lt;code&gt;He begins by delivering a present to the house at his starting location...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve completed the loop, we can count the houses by iterating through the
grid and incrementing a counter for each set of coordinates that is true. The
ternary operator is used as a shortcut here.&lt;/p&gt;

&lt;p&gt;Once we submit our solution, the second problem appears:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The next year, to speed up the process, Santa creates a robot version of himself, &lt;strong&gt;Robo-Santa&lt;/strong&gt;, to deliver presents with him.&lt;/p&gt;

&lt;p&gt;Santa and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.&lt;/p&gt;

&lt;p&gt;This year, how many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^v&lt;/code&gt; delivers presents to &lt;code&gt;3&lt;/code&gt; houses, because Santa goes north, and then Robo-Santa goes south.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; now delivers presents to &lt;code&gt;3&lt;/code&gt; houses, and Santa and Robo-Santa end up back where they started.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; now delivers presents to &lt;code&gt;11&lt;/code&gt; houses, with Santa going one direction and Robo-Santa going the other.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we read, the difference here is that we have a second &amp;ldquo;Santa&amp;rdquo;, and they
alternate directions in the input, rather than one taking all the directions.
This means we will need to implement a toggle, as well as keep two sets of
coordinates on the same grid. As with previous answers, I chose to integrate
this solution into the original problem rather than writing a completely new
set of code to solve problem 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];

        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to the single &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; value for the first problem, I declare
a two-element array to represent the coordinates of both santas for the second
problem. I alse declare and initialize another set of min/max variables.
Finally, a variable is declared to act as a toggle between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now to find our coordinates, we run through the loop. We increment the x and y
of the appropriate Santa, and check that against the x and y minimums and
maximums for the second grid (remember, both Santas share the grid, so there
is only one set of mins and maxes). We&amp;rsquo;ll update the values for the second grid
based on the active Santa, and then once all values have been updated, we use
the bitwise XOR assignment operator to flip the toggle value. Once the loop is
complete, we calculate the width and height of the second grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The grid creation for the second problem is identical to the first problem. The
only difference comes in assigning the initial coordinates; this needs to be
done for both Santas for the second problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During the second iteration of the input, we&amp;rsquo;ll toggle the Santa as we did
during the range finding iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll count the number of visited houses for the second grid, exactly
as we did the first grid.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll free our allocated input array for completeness and return
success:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All together now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];
        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;

    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;

    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }

    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);

    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 2: I Was Told There Would Be No Math</title>
      <link>/post/advent-2015-c-2/</link>
      <pubDate>Mon, 09 Sep 2019 02:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-2/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m going to go ahead and do a second puzzle today since the early ones are
relatively simple. Day 1&amp;rsquo;s puzzles were mostly incrementing, decrementing and
tracking variables; Day 2&amp;rsquo;s have a bit more math involved.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.&lt;/p&gt;

&lt;p&gt;Fortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is &lt;code&gt;2*l*w + 2*w*h + 2*h*l&lt;/code&gt;. The elves also need a little extra paper for each present: the area of the smallest side.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2*6 + 2*12 + 2*8 = 52&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;6&lt;/code&gt; square feet of slack, for a total of &lt;code&gt;58&lt;/code&gt; square feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;2*1 + 2*10 + 2*10 = 42&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;1&lt;/code&gt; square foot of slack, for a total of &lt;code&gt;43&lt;/code&gt; square feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All numbers in the elves&amp;rsquo; list are in feet. How many total &lt;strong&gt;square feet of wrapping paper&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we&amp;rsquo;re going to take a minute to break the problem down. As the
problem states, the input is formatted as XXxYYxZZ, so we will need to parse
the input into usable numbers. Since we need to operate on the smallest
dimensions for the slack, we&amp;rsquo;ll need to be able to sort the inputted values.
Finally, we&amp;rsquo;ll need to do the math and keep a running total.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dig in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preamble to our function is identical to day 1, with the exception of
initializing our return value early as we&amp;rsquo;ll be using our &lt;code&gt;goto&lt;/code&gt; short circuit
pattern to handle some later potential errors. We check that the user provided a
filename and read the file into the &lt;code&gt;input&lt;/code&gt; buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll then print our daily header and initialize the running total for the
wrapping paper.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start getting into some more interesting string handling. Note that the
input has one present per line, so we need to effectively split the string on
the lines. We will use the POSIX &lt;code&gt;strsep&lt;/code&gt; function for this. There is a similar
&lt;code&gt;strtok&lt;/code&gt; function in the C standard librory, but it has the downside of being
non-reentrant. If portability is a concern, you may want to stick use &lt;code&gt;strtok&lt;/code&gt;,
however &lt;code&gt;strsep&lt;/code&gt; is widely supported and should  be used instead of &lt;code&gt;strtok&lt;/code&gt;
wherever possible.&lt;/p&gt;

&lt;p&gt;In order to avoid changing the original value of the pointer to the input, we
make a copy into &lt;code&gt;cursor&lt;/code&gt; which becomes the moving pointer passed as the first
argument of &lt;code&gt;strsep&lt;/code&gt;. Finally, we are splitting on the newline character &lt;code&gt;\n&lt;/code&gt;.
We will not bother to make a copy of the input buffer as we only need to parse
it once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One side effect of &lt;code&gt;strsep&lt;/code&gt; that one needs to be aware of is that if multiple
delimiters are encountered in a row, &lt;code&gt;strsep&lt;/code&gt; will return a pointer to an empty
string instead of consuming all of the delimiters at once. We check for the
empty string and short-circuit the loop if we encounter this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now initialize an array of three &lt;code&gt;int&lt;/code&gt;s to hold the parsed values. We use an
array instead of separate variables because we will need to sort the result.
Once the array is initialized, we use the &lt;code&gt;sscanf&lt;/code&gt; function to scan the
dimensions into the array. As we are not trying to scan &lt;em&gt;into&lt;/em&gt; string variables,
&lt;code&gt;sscanf&lt;/code&gt; is perfectly safe for our usage. As an error check, we will
short-circuit to the function cleanup if we have an invalid line which scans
less than three values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        qsort(dims, 3, sizeof(int), cmp_int_asc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the values are scanned, they need to be sorted so that we can find the
slack using the smallest side. For this we use the standard library function
&lt;code&gt;qsort&lt;/code&gt; with a simple comparator function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int cmp_int_asc(const void *a, const void *b)
{
    int l = *(const int *)a;
    int r = *(const int *)b;

    return l &amp;lt; r ? -1 : l &amp;gt; r ? 1 : 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The comparator dereferences and casts the inputs and then returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a &amp;lt; 
b&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if they are equal. I use the ternary operator here
for conciseness, but I would refrain from using it for anything more complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have our values and we have them sorted by smallest to largest, we
just need to do the math and update our running total. As noted in the problem,
for each present we need to add the area of each side plus the area of the
smallest side as slack: &lt;code&gt;2xy + 2yz + 2xz + xy&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have broken out of the input parsing loop, &lt;code&gt;paper&lt;/code&gt; should have the total
required wrapping paper. We can print the solution and then proceed with
cleanup. As noted in day 1, freeing &lt;code&gt;input&lt;/code&gt; is not strictly necessary in this
case but is good from a habit-forming perspective.&lt;/p&gt;

&lt;p&gt;Once the solution has been input, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.&lt;/p&gt;

&lt;p&gt;The ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don&amp;rsquo;t ask how they tie the bow, though; they&amp;rsquo;ll never tell.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2+2+3+3 = 10&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;2*3*4 = 24&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;34&lt;/code&gt; feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;1+1+1+1 = 4&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;1*1*10 = 10&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;14&lt;/code&gt; feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many total &lt;strong&gt;feet of ribbon&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we already have all of the infrastructure present to handle this
new problem. We&amp;rsquo;ll add a new variable to track the running total of ribbon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int paper = 0;
    int ribbon = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the total ribbon on each loop, following the instructions to add
&lt;code&gt;2x+2y+xyz&lt;/code&gt; to the total:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll print the second solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it&amp;rsquo;s all put together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
    int ribbon = 0;

    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }

        qsort(dims, 3, sizeof(int), cmp_int_asc);

        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, this program will pass all Valgrind checks and does not leak memory.&lt;/p&gt;

&lt;p&gt;Suggestions, questions, and criticism welcome! Comments can be added below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 1: Not Quite Lisp</title>
      <link>/post/advent-2015-c-1/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-1/</guid>
      <description>&lt;p&gt;Yesterday, I talked in general about what I am trying to accomplish with this
series, and wrote a reusable function to read the input files into memory, which
will be used frequently throughout the series. Now it&amp;rsquo;s time to dig in.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa was hoping for a white Christmas, but his weather machine&amp;rsquo;s &amp;ldquo;snow&amp;rdquo; function is powered by stars, and he&amp;rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.&lt;/p&gt;

&lt;p&gt;Collect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an easy puzzle to warm you up.&lt;/p&gt;

&lt;p&gt;Santa is trying to deliver presents in a large apartment building, but he can&amp;rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.&lt;/p&gt;

&lt;p&gt;An opening parenthesis, &lt;code&gt;(&lt;/code&gt;, means he should go up one floor, and a closing parenthesis, &lt;code&gt;)&lt;/code&gt;, means he should go down one floor.&lt;/p&gt;

&lt;p&gt;The apartment building is very tall, and the basement is very deep; he will never find the top or bottom  floors.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(())&lt;/code&gt; and &lt;code&gt;()()&lt;/code&gt; both result in floor &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(((&lt;/code&gt; and &lt;code&gt;(()(()(&lt;/code&gt; both result in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;))(((((&lt;/code&gt; also results in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;())&lt;/code&gt; and &lt;code&gt;))(&lt;/code&gt; both result in floor &lt;code&gt;-1&lt;/code&gt; (the first basement level).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)))&lt;/code&gt; and &lt;code&gt;)())())&lt;/code&gt; both result in floor &lt;code&gt;-3&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To &lt;strong&gt;what floor&lt;/strong&gt; do the instructions take Santa?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before we start writing code, let&amp;rsquo;s think about what needs to happen. We will
need to input a file, read through it, determine which characters are important
(&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) and adjust the floor number accordingly. Then we&amp;rsquo;ll need to output
our solution somehow.&lt;/p&gt;

&lt;p&gt;Generally speaking, each day&amp;rsquo;s puzzle will be its own executable and the input
filename will be a command-line argument.&lt;/p&gt;

&lt;p&gt;Now that we have a plan of attack, let&amp;rsquo;s dig in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First things first, let&amp;rsquo;s check and make sure the user actually provided a
filename. Don&amp;rsquo;t forget that &lt;code&gt;argv[0]&lt;/code&gt; is always the name of the invoked command,
so &lt;code&gt;argc&lt;/code&gt; must be at least &lt;code&gt;2&lt;/code&gt; if the user has provided any arguments at all. If
the argument is not present, we&amp;rsquo;ll print a useful error message to &lt;code&gt;stderr&lt;/code&gt; and
return from &lt;code&gt;main&lt;/code&gt; with a non-zero code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that input file function we wrote yesterday? Now we get to use it. We
declare a pointer to the buffer and pass it into the function, along with the
filename which should be in &lt;code&gt;argv[1]&lt;/code&gt;. If the file doesn&amp;rsquo;t exist, isn&amp;rsquo;t
readable, or any other problem that we handled in the function, it will return
&lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;errno&lt;/code&gt; will be set. In that case, we print the error message to
&lt;code&gt;stderr&lt;/code&gt; and return non-zero. If everything worked, the contents of the file
are now in the location in memory pointed to by our &lt;code&gt;input&lt;/code&gt; pointer. Once we&amp;rsquo;ve
successfully read the file, we&amp;rsquo;ll print our header line for the output.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to solve the problem. The most straightforward way is going to be
to iterate over the contents of the file in memory byte-by-byte and adjust the
floor accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the first puzzle */
    int floor = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We initialize our floor variable to zero as noted in the problem description
(&lt;code&gt;He starts on the ground floor (floor 0)...&lt;/code&gt;), and then construct a &lt;code&gt;for&lt;/code&gt; loop
with the index starting at &lt;code&gt;0&lt;/code&gt; (remember, C arrays are zero-indexed) and
incrementing by one until we reach the file size which was returned by our file
input function. During each iteration of the loop, we check the byte at that
index and either increment or decrement the floor number depending on the
character. In this case, I have chosen to ignore any spurious characters that
may be in the input.&lt;/p&gt;

&lt;p&gt;The object of the problem is to determine which floor we arrive at (&lt;code&gt;To what 
floor do the instructions take Santa?&lt;/code&gt;), so the value of the &lt;code&gt;floor&lt;/code&gt; variable
is our solution.&lt;/p&gt;

&lt;p&gt;Once we input our solution, a second problem appears!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, given the same instructions, find the &lt;strong&gt;position&lt;/strong&gt; of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()())&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;5&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What is the &lt;strong&gt;position&lt;/strong&gt; of the character that causes Santa to first enter the basement?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the interest of saving compute time and code, we will attempt to integrate
the finding of the second solution into the original code. In this case, it&amp;rsquo;s
a matter of finding the index where we first hit floor &lt;code&gt;-1&lt;/code&gt;. We can do this by
setting a variable to a known bad value, and checking whether it has been reset
to a known good value and if not, setting it. So, we&amp;rsquo;ll update our problem logic
as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the puzzles */
    int floor = 0;
    int basement = -1;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == -1)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this updated logic, we set &lt;code&gt;basement&lt;/code&gt; to a sentinel value of &lt;code&gt;-1&lt;/code&gt;; since we
are counting up, the value cannot possibly be negative. Then, in each iteration
of the loop, we check for the floor to be &lt;code&gt;-1&lt;/code&gt; (since we can only move one
floor at a time) and for the basement value to be the sentinel. For those of
you counting instructions, notice that the floor check will short-circuit; i.e.
the basement check will not happen unless the floor is &lt;code&gt;-1&lt;/code&gt;. The net effect is
that on average we are only adding one instruction per loop. Also notice that
we set the value of basement to &lt;code&gt;i + 1&lt;/code&gt; as the positions are one-indexed per
the problem parameters (&lt;code&gt;The first character in the instructions has position 
1...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have solved the problem, we&amp;rsquo;ll clean up and return &lt;code&gt;0&lt;/code&gt;. Note that it
is not strictly necessary to free &lt;code&gt;input&lt;/code&gt;, but it is a good habit to be in.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the whole program for day 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);

    /* solve the puzzles */
    int floor = 0;
    int basement = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == 0)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);

    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program makes proper error checks and manages memory properly, and will
pass all Valgrind checks in a variety of test scenarios.&lt;/p&gt;

&lt;p&gt;If I&amp;rsquo;ve done something horribly wrong or you have questions, please comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code deep dive kickoff</title>
      <link>/post/advent-setup-c/</link>
      <pubDate>Sun, 08 Sep 2019 22:00:00 +0000</pubDate>
      
      <guid>/post/advent-setup-c/</guid>
      <description>&lt;p&gt;In the first technical article for this iteration of the site, I&amp;rsquo;d like to turn
to &lt;a href=&#34;https://adventofcode.com&#34; target=&#34;_blank&#34;&gt;Advent of Code&lt;/a&gt;. These are programming problems
built around a fun Christmas-themed storyline each year. I especially appreciate
that the problems are language-agnostic, so I frequently turn to some of the
easier ones when I&amp;rsquo;m getting familiar with a new language.&lt;/p&gt;

&lt;p&gt;It can be easy to throw together just enough code to make the puzzle work, but
I thought I&amp;rsquo;d revisit these problems from a different angle, looking not only
at how to solve the problem, but how to write high-quality code, including error
handling and memory management. In order to up the challenge, the solutions will
be written in C, and the code will pass all Valgrind tests for memory leaks and
other issues. All code discussed in these posts will be in my &lt;a href=&#34;https://github.com/e3b0c442/advent&#34; target=&#34;_blank&#34;&gt;Advent of Code
solutions repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To kick things off, we&amp;rsquo;ll take a look at code reuse. When you&amp;rsquo;re quickly
prototyping or problem solving, you&amp;rsquo;re frequently going to have identical
snippets of code in multiple places. If we&amp;rsquo;re writing high-quality code, we want
to avoid this wherever possible. One common theme throughout the Advent of Code
problems will be reading an input file into memory. In order to avoid writing
the same code over and over, we&amp;rsquo;re going to start things off by writing a
function to read a file into a memory buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already, just in the function signature, we are making design decisions. We
could have written the function to return the pointer to the memory buffer, and
in most languages this makes the most sense. However, in C, the length of an
array is not an integral part of the data type, so we need to pass that
information back as well. Therefore, I made the decision to pass a pointer to
pointer to char (array) to the function, which will be modified in the function
with the actual pointer to the allocated buffer, and to return the size of the
buffer in the return value (or -1 if there is an error). We use this pattern
rather than passing in the buffer itself because we do not know ahead of time
how the buffer needs to be sized. The caller will be responsible for freeing the
buffer when they are done using it.&lt;/p&gt;

&lt;p&gt;Now, lets think about what actually needs to happen to read a file into memory,
and what can go wrong.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Does the file exist? Is it a valid, readable file?&lt;/li&gt;
&lt;li&gt;How big is the file; consequently, how big does my buffer need to be?&lt;/li&gt;
&lt;li&gt;What happens if we don&amp;rsquo;t succeed in reading the actual data?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can see, when reading a file, there are a lot of potential failure
points. Keeping that in mind, let&amp;rsquo;s start writing our code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we do is initialize variables that will exist for the life of
the function (and be part of the cleanup). &lt;code&gt;rval&lt;/code&gt; will hold our return value,
&lt;code&gt;f&lt;/code&gt; will hold our file pointer, and &lt;code&gt;*buf&lt;/code&gt; is the pointer to the buffer that
will hold the file contents, which is passed in as a parameter. Each is
initialized to a sane default, as variables are not automatically initialized
in C.&lt;/p&gt;

&lt;p&gt;With that out of the way, we&amp;rsquo;ll make our first check. Using the POSIX &lt;code&gt;stat&lt;/code&gt;
function, we query the file for information. Right off the bat, this will tell
us if the file exists; if it does not, &lt;code&gt;stat&lt;/code&gt; will return &lt;code&gt;-1&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;
accordingly. If we see this, we will jump to our error cleanup.&lt;/p&gt;

&lt;p&gt;At this point, I&amp;rsquo;m going to take a sidebar and talk a bit about &lt;code&gt;goto&lt;/code&gt;. For most
programmers, there&amp;rsquo;s a knee-jerk reaction to avoid &lt;code&gt;goto&lt;/code&gt; at all costs.
Generally, I agree with this with one exception: &lt;em&gt;error cleanup.&lt;/em&gt; In this case,
&lt;code&gt;goto&lt;/code&gt; properly used provides an avenue to short-circuit function execution and
provide for cleanup in the case of an error without reusing the same code.&lt;/p&gt;

&lt;p&gt;If the file exists, the &lt;code&gt;struct stat&lt;/code&gt; will be populated with information about
the file, including the type and size. Continuing on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our next check is that we are working with a regular file, as opposed to a
directory, block device, or other file type. (note: &lt;code&gt;stat&lt;/code&gt; follows symlinks!).
We use the &lt;code&gt;S_ISREG&lt;/code&gt; macro to accomplish this. Because this is a check and not
necessarily an error condition, if the provided file is not a regular file we
will set &lt;code&gt;errno&lt;/code&gt; ourselves to indicate an invalid parameter and then jump to our
error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL) 
        goto err_cleanup; /* errno is set by fopen() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the file exists, and that it&amp;rsquo;s a regular file, we will try to
open it for reading. If the file is not readable for any reason, &lt;code&gt;fopen&lt;/code&gt; will
return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; appropriately. We will check for the &lt;code&gt;NULL&lt;/code&gt;
return value and short-circuit as needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve successfully opened the file, we&amp;rsquo;ll allocate the buffer. Even
though we already had the size information from the &lt;code&gt;stat&lt;/code&gt; call, I&amp;rsquo;ve chosen
not to allocate the buffer until we know the file is readable, to avoid
unnecessary allocations. For this problem it doesn&amp;rsquo;t really matter, but it&amp;rsquo;s
a good habit to be in. If there is an error allocating the buffer such as
running out of memory, &lt;code&gt;malloc&lt;/code&gt; will return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;; again we
will check for this and short-circuit the function as necessary. I&amp;rsquo;m using
&lt;code&gt;malloc&lt;/code&gt; instead of &lt;code&gt;calloc&lt;/code&gt; because we have designed the function such that the
buffer will be completely filled by the file, negating the need to initialize
it. The extra +1 is to make room for a null terminator so that we may treat the
buffer as a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we perform the actual read. &lt;code&gt;fread&lt;/code&gt; is a buffered read which calls the
low-level &lt;code&gt;read&lt;/code&gt; syscall, and as such it will block until the requested size
is read unless there is an error, allowing us to avoid need to loop until the
expected data is read. Instead, we will check to make sure the expected size
of data is read (the file size) and check for an error if it is not. If there
is an error reading the file, we&amp;rsquo;ll short-circuit to our error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We finish up the logic of our function by setting the extra allocated byte at
the end of the buffer to a null terminator, then set the return value to the
amount of data read, and finally jumping to our non-error cleanup. Array
indeces have a higher precedence than the indirection operator, so we need to
enclose the indirection in parentheses to avoid writing to the wrong memory
address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for our cleanup. There are two things that need to be cleaned up in this
function: first, the file needs to be closed if it was opened, to avoid file
handle leaks. Also, if there was an error, the data buffer needs to be freed
if it was allocated and the pointer set to NULL. Finally, if we did error,
we set &lt;code&gt;rval&lt;/code&gt; to -1 which indicates the error to the caller, who can then get
more information by inspecting &lt;code&gt;errno.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The whole function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */

    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL)
        goto err_cleanup; /* errno is set by fopen() */

    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */

    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;

    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;

err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve now written a function with appropriate error checking that can be reused
throughout our Advent of Code exercises!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Return of the... me?</title>
      <link>/post/e3b0c442-returns/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/e3b0c442-returns/</guid>
      <description>&lt;p&gt;So here we are again.&lt;/p&gt;

&lt;p&gt;After 20 years, you&amp;rsquo;d think I&amp;rsquo;d have gotten the hang of keeping a personal
website current and up to date. Alas, times and priorities change.&lt;/p&gt;

&lt;p&gt;Hopefully now that it&amp;rsquo;s easy to build with &lt;a href=&#34;https://gohugo.io&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; that will
change and I can stick around for awhile and actually keep this up to date and
post regularly.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll see.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
