[{"authors":["nick"],"categories":null,"content":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.\nPGP fingerprint: 9408 6361 4B0B 3307 5068 5FE8 DD3F EC7C 659D CEA2\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"22df73ca0cc2e5922b5f427771bc24c0","permalink":"/authors/nick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/nick/","section":"authors","summary":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.","tags":null,"title":"Nick Meyer","type":"authors"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\nFor example:\n A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet. A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.  All numbers in the elves\u0026rsquo; list are in feet. How many total square feet of wrapping paper should they order?\n As with day 1, we\u0026rsquo;re going to take a minute to break the problem down. As the problem states, the input is formatted as XXxYYxZZ, so we will need to parse the input into usable numbers. Since we need to operate on the smallest dimensions for the slack, we\u0026rsquo;ll need to be able to sort the inputted values. Finally, we\u0026rsquo;ll need to do the math and keep a running total.\nLet\u0026rsquo;s dig in:\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  The preamble to our function is identical to day 1, with the exception of initializing our return value early as we\u0026rsquo;ll be using our goto short circuit pattern to handle some later potential errors. We check that the user provided a filename and read the file into the input buffer.\nprintf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0;  We\u0026rsquo;ll then print our daily header and initialize the running total for the wrapping paper.\n/* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;);  Now we start getting into some more interesting string handling. Note that the input has one present per line, so we need to effectively split the string on the lines. We will use the POSIX strsep function for this. There is a similar strtok function in the C standard librory, but it has the downside of being non-reentrant. If portability is a concern, you may want to stick use strtok, however strsep is widely supported and should be used instead of strtok wherever possible.\nIn order to avoid changing the original value of the pointer to the input, we make a copy into cursor which becomes the moving pointer passed as the first argument of strsep. Finally, we are splitting on the newline character \\n. We will not bother to make a copy of the input buffer as we only need to parse it once.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize;  One side effect of strsep that one needs to be aware of is that if multiple delimiters are encountered in a row, strsep will return a pointer to an empty string instead of consuming all of the delimiters at once. We check for the empty string and short-circuit the loop if we encounter this.\n/* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; }  We now initialize an array of three ints to hold the parsed values. We use an array instead of separate variables because we will need to sort the result. Once the array is initialized, we use the sscanf function to scan the dimensions into the array. As we are not trying to scan into string variables, sscanf is perfectly safe for our usage. As an error check, we will short-circuit to the function cleanup if we have an invalid line which scans less than three values.\nqsort(dims, 3, sizeof(int), cmp_int_asc);  Once the values are scanned, they need to be sorted so that we can find the slack using the smallest side. For this we use the standard library function qsort with a simple comparator function:\nint cmp_int_asc(const void *a, const void *b) { int l = *(const int *)a; int r = *(const int *)b; return l \u0026lt; r ? -1 : l \u0026gt; r ? 1 : 0; }  The comparator dereferences and casts the inputs and then returns -1 if a \u0026lt; b, 1 if a \u0026gt; b, or 0 if they are equal. I use the ternary operator here for conciseness, but I would refrain from using it for anything more complex.\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now that we have our values and we have them sorted by smallest to largest, we just need to do the math and update our running total. As noted in the problem, for each present we need to add the area of each side plus the area of the smallest side as slack: 2xy + 2yz + 2xz + xy.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  Once we have broken out of the input parsing loop, paper should have the total required wrapping paper. We can print the solution and then proceed with cleanup. As noted in day 1, freeing input is not strictly necessary in this case but is good from a habit-forming perspective.\nOnce the solution has been input, the second problem is presented:\n The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don\u0026rsquo;t ask how they tie the bow, though; they\u0026rsquo;ll never tell.\nFor example:\n A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet. A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.  How many total feet of ribbon should they order?\n As with day 1, we already have all of the infrastructure present to handle this new problem. We\u0026rsquo;ll add a new variable to track the running total of ribbon:\nint paper = 0; int ribbon = 0;  Then update the total ribbon on each loop, following the instructions to add 2x+2y+xyz to the total:\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];  Finally, we\u0026rsquo;ll print the second solution:\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon);  When it\u0026rsquo;s all put together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0; int ribbon = 0; /* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; /* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; } qsort(dims, 3, sizeof(int), cmp_int_asc); paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  As before, this program will pass all Valgrind checks and does not leak memory.\nSuggestions, questions, and criticism welcome! Comments can be added below.\n","date":1567994400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567994400,"objectID":"f5e5b339b407c157e6918a4e63e14f57","permalink":"/post/advent-2015-c-2/","publishdate":"2019-09-09T02:00:00Z","relpermalink":"/post/advent-2015-c-2/","section":"post","summary":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.","tags":["Programming","Advent of Code","C","String parsing"],"title":"Advent of Code 2015 Day 2: I Was Told There Would Be No Math","type":"post"},{"authors":null,"categories":null,"content":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere\u0026rsquo;s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can\u0026rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n (()) and ()() both result in floor 0. ((( and (()(()( both result in floor 3. ))((((( also results in floor 3. ()) and ))( both result in floor -1 (the first basement level). ))) and )())()) both result in floor -3.  To what floor do the instructions take Santa?\n Before we start writing code, let\u0026rsquo;s think about what needs to happen. We will need to input a file, read through it, determine which characters are important (( and )) and adjust the floor number accordingly. Then we\u0026rsquo;ll need to output our solution somehow.\nGenerally speaking, each day\u0026rsquo;s puzzle will be its own executable and the input filename will be a command-line argument.\nNow that we have a plan of attack, let\u0026rsquo;s dig in.\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; }  First things first, let\u0026rsquo;s check and make sure the user actually provided a filename. Don\u0026rsquo;t forget that argv[0] is always the name of the invoked command, so argc must be at least 2 if the user has provided any arguments at all. If the argument is not present, we\u0026rsquo;ll print a useful error message to stderr and return from main with a non-zero code.\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;);  Remember that input file function we wrote yesterday? Now we get to use it. We declare a pointer to the buffer and pass it into the function, along with the filename which should be in argv[1]. If the file doesn\u0026rsquo;t exist, isn\u0026rsquo;t readable, or any other problem that we handled in the function, it will return -1 and errno will be set. In that case, we print the error message to stderr and return non-zero. If everything worked, the contents of the file are now in the location in memory pointed to by our input pointer. Once we\u0026rsquo;ve successfully read the file, we\u0026rsquo;ll print our header line for the output.\nNow it\u0026rsquo;s time to solve the problem. The most straightforward way is going to be to iterate over the contents of the file in memory byte-by-byte and adjust the floor accordingly.\n/* solve the first puzzle */ int floor = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor);  We initialize our floor variable to zero as noted in the problem description (He starts on the ground floor (floor 0)...), and then construct a for loop with the index starting at 0 (remember, C arrays are zero-indexed) and incrementing by one until we reach the file size which was returned by our file input function. During each iteration of the loop, we check the byte at that index and either increment or decrement the floor number depending on the character. In this case, I have chosen to ignore any spurious characters that may be in the input.\nThe object of the problem is to determine which floor we arrive at (To what floor do the instructions take Santa?), so the value of the floor variable is our solution.\nOnce we input our solution, a second problem appears!\n Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n ) causes him to enter the basement at character position 1. ()()) causes him to enter the basement at character position 5.  What is the position of the character that causes Santa to first enter the basement?\n In the interest of saving compute time and code, we will attempt to integrate the finding of the second solution into the original code. In this case, it\u0026rsquo;s a matter of finding the index where we first hit floor -1. We can do this by setting a variable to a known bad value, and checking whether it has been reset to a known good value and if not, setting it. So, we\u0026rsquo;ll update our problem logic as such:\n/* solve the puzzles */ int floor = 0; int basement = -1; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == -1) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement);  In this updated logic, we set basement to a sentinel value of -1; since we are counting up, the value cannot possibly be negative. Then, in each iteration of the loop, we check for the floor to be -1 (since we can only move one floor at a time) and for the basement value to be the sentinel. For those of you counting instructions, notice that the floor check will short-circuit; i.e. the basement check will not happen unless the floor is -1. The net effect is that on average we are only adding one instruction per loop. Also notice that we set the value of basement to i + 1 as the positions are one-indexed per the problem parameters (The first character in the instructions has position 1...).\nfree(input); return 0; }  Now that we have solved the problem, we\u0026rsquo;ll clean up and return 0. Note that it is not strictly necessary to free input, but it is a good habit to be in.\nHere\u0026rsquo;s the whole program for day 1:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;); /* solve the puzzles */ int floor = 0; int basement = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == 0) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement); free(input); return 0; }  This program makes proper error checks and manages memory properly, and will pass all Valgrind checks in a variety of test scenarios.\nIf I\u0026rsquo;ve done something horribly wrong or you have questions, please comment!\n","date":1567987200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567987200,"objectID":"b231645316f12b2922f38f7ba06232ed","permalink":"/post/advent-2015-c-1/","publishdate":"2019-09-09T00:00:00Z","relpermalink":"/post/advent-2015-c-1/","section":"post","summary":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 1: Not Quite Lisp","type":"post"},{"authors":null,"categories":null,"content":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management. In order to up the challenge, the solutions will be written in C, and the code will pass all Valgrind tests for memory leaks and other issues. All code discussed in these posts will be in my Advent of Code solutions repository.\nTo kick things off, we\u0026rsquo;ll take a look at code reuse. When you\u0026rsquo;re quickly prototyping or problem solving, you\u0026rsquo;re frequently going to have identical snippets of code in multiple places. If we\u0026rsquo;re writing high-quality code, we want to avoid this wherever possible. One common theme throughout the Advent of Code problems will be reading an input file into memory. In order to avoid writing the same code over and over, we\u0026rsquo;re going to start things off by writing a function to read a file into a memory buffer:\nint read_file_to_buffer(char **buf, char *filename);  Already, just in the function signature, we are making design decisions. We could have written the function to return the pointer to the memory buffer, and in most languages this makes the most sense. However, in C, the length of an array is not an integral part of the data type, so we need to pass that information back as well. Therefore, I made the decision to pass a pointer to pointer to char (array) to the function, which will be modified in the function with the actual pointer to the allocated buffer, and to return the size of the buffer in the return value (or -1 if there is an error). We use this pattern rather than passing in the buffer itself because we do not know ahead of time how the buffer needs to be sized. The caller will be responsible for freeing the buffer when they are done using it.\nNow, lets think about what actually needs to happen to read a file into memory, and what can go wrong.\n Does the file exist? Is it a valid, readable file? How big is the file; consequently, how big does my buffer need to be? What happens if we don\u0026rsquo;t succeed in reading the actual data?  As you can see, when reading a file, there are a lot of potential failure points. Keeping that in mind, let\u0026rsquo;s start writing our code.\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */  The first thing we do is initialize variables that will exist for the life of the function (and be part of the cleanup). rval will hold our return value, f will hold our file pointer, and *buf is the pointer to the buffer that will hold the file contents, which is passed in as a parameter. Each is initialized to a sane default, as variables are not automatically initialized in C.\nWith that out of the way, we\u0026rsquo;ll make our first check. Using the POSIX stat function, we query the file for information. Right off the bat, this will tell us if the file exists; if it does not, stat will return -1 and set errno accordingly. If we see this, we will jump to our error cleanup.\nAt this point, I\u0026rsquo;m going to take a sidebar and talk a bit about goto. For most programmers, there\u0026rsquo;s a knee-jerk reaction to avoid goto at all costs. Generally, I agree with this with one exception: error cleanup. In this case, goto properly used provides an avenue to short-circuit function execution and provide for cleanup in the case of an error without reusing the same code.\nIf the file exists, the struct stat will be populated with information about the file, including the type and size. Continuing on:\n/* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; }  Our next check is that we are working with a regular file, as opposed to a directory, block device, or other file type. (note: stat follows symlinks!). We use the S_ISREG macro to accomplish this. Because this is a check and not necessarily an error condition, if the provided file is not a regular file we will set errno ourselves to indicate an invalid parameter and then jump to our error cleanup.\n/* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */  Now that we know the file exists, and that it\u0026rsquo;s a regular file, we will try to open it for reading. If the file is not readable for any reason, fopen will return NULL and set errno appropriately. We will check for the NULL return value and short-circuit as needed.\n/* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */  Now that we\u0026rsquo;ve successfully opened the file, we\u0026rsquo;ll allocate the buffer. Even though we already had the size information from the stat call, I\u0026rsquo;ve chosen not to allocate the buffer until we know the file is readable, to avoid unnecessary allocations. For this problem it doesn\u0026rsquo;t really matter, but it\u0026rsquo;s a good habit to be in. If there is an error allocating the buffer such as running out of memory, malloc will return NULL and set errno; again we will check for this and short-circuit the function as necessary. I\u0026rsquo;m using malloc instead of calloc because we have designed the function such that the buffer will be completely filled by the file, negating the need to initialize it. The extra +1 is to make room for a null terminator so that we may treat the buffer as a string.\n/* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup;  Now we perform the actual read. fread is a buffered read which calls the low-level read syscall, and as such it will block until the requested size is read unless there is an error, allowing us to avoid need to loop until the expected data is read. Instead, we will check to make sure the expected size of data is read (the file size) and check for an error if it is not. If there is an error reading the file, we\u0026rsquo;ll short-circuit to our error cleanup.\n/* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup;  We finish up the logic of our function by setting the extra allocated byte at the end of the buffer to a null terminator, then set the return value to the amount of data read, and finally jumping to our non-error cleanup. Array indeces have a higher precedence than the indirection operator, so we need to enclose the indirection in parentheses to avoid writing to the wrong memory address.\nerr_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval;  Now for our cleanup. There are two things that need to be cleaned up in this function: first, the file needs to be closed if it was opened, to avoid file handle leaks. Also, if there was an error, the data buffer needs to be freed if it was allocated and the pointer set to NULL. Finally, if we did error, we set rval to -1 which indicates the error to the caller, who can then get more information by inspecting errno.\nThe whole function:\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */ /* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; } /* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */ /* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */ /* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup; /* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup; err_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval; }  We\u0026rsquo;ve now written a function with appropriate error checking that can be reused throughout our Advent of Code exercises!\n","date":1567980000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567980000,"objectID":"4a19ca9dcbe5acd4634b1a929187717f","permalink":"/post/advent-setup-c/","publishdate":"2019-09-08T22:00:00Z","relpermalink":"/post/advent-setup-c/","section":"post","summary":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management.","tags":["Programming","Advent of Code","C","Best practices","DRY"],"title":"Advent of Code deep dive kickoff","type":"post"},{"authors":null,"categories":null,"content":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.\n","date":1567468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567468800,"objectID":"7b1a7e9fadbc0ac76e4a203dc7dda3a9","permalink":"/post/e3b0c442-returns/","publishdate":"2019-09-03T00:00:00Z","relpermalink":"/post/e3b0c442-returns/","section":"post","summary":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.","tags":["Personal","Website"],"title":"Return of the... me?","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About Me","type":"widget_page"}]