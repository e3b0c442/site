[{"authors":["nick"],"categories":null,"content":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.\nPGP fingerprint: 9408 6361 4B0B 3307 5068 5FE8 DD3F EC7C 659D CEA2\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"22df73ca0cc2e5922b5f427771bc24c0","permalink":"/authors/nick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/nick/","section":"authors","summary":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.","tags":null,"title":"Nick Meyer","type":"authors"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: 1, 2, 3, \u0026hellip;) that produces such a hash.\nFor example:\n If your secret key is abcdef, the answer is 609043, because the MD5 hash of abcdef609043 starts with five zeroes (000001dbbfa...), and it is the lowest such number to do so. If your secret key is pqrstuv, the lowest number it combines with to make an MD5 hash starting with five zeroes is 1048970; that is, the MD5 hash of pqrstuv1048970 looks like 000006136ef....   As always, we\u0026rsquo;ll start with breaking down the problem into discrete parts: * Read the input * Convert a number to a string * Combine the input and the number string * Get the MD5 digest of the combined string * Check that the first five digits of the digest are 0\nRather than write our own MD5 hashing implementation, we will use the well-known and commonly-installed OpenSSL library\u0026rsquo;s implementation. You\u0026rsquo;ll need to make sure that your linker pulls in the OpenSSL library.\nLet\u0026rsquo;s write some code:\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  For the sake of completion, this is our standard prelude of verifying the command-line argument and reading the input file.\nprintf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16];  We print our preamble, then initialize some variables. Note that I\u0026rsquo;m doing this outside of a loop so that we do not incur this cost in the loop. Our code will be written in such a way that the variables do not need to be reinitialized on every pass. Step by step we have:\n The declaration of the iteration index i, which is the number that will be added to the input string on each pass The declaration of the buffer which stores the whole string to be hashed. We size from the input and then add 11 \u0026ndash; 10 for the maximum number of digits in a 32-bit integer, and 1 for the null terminator. The initialization of the string buffer. Ensuring all bytes are set to 0 now will help us not need to re-initialize the variable on every loop Copying the input into the buffer Creating a buffer for the MD5 digest. MD5 digests are 128 bits, so we need a 16-byte buffer. Note that we do not have a null terminator here because this is not a string.\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest);   Now we begin the loop. W se formatted print to append the string representation of i to the buffer. Notice that we are using pointer arithmetic to point to the first index in the buffer after the original input string. Because the numbers will only ever increase, we will overwrite this on each loop and not need to reinitialize the variable. We then get the MD5 digest of the constructed string.\nAt this point, one might be tempted to use formatted print to output the hexadecimal representation of the digest. Don\u0026rsquo;t! String formatting operations are computationally expensive, and we have the information we need to solve the problem without doing it.\nif (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; }  Note that the ratio of bytes to hex characters is 1:2; that is, each byte of the digest would translate to two hex characters. With this in mind, remember that this digest is just one big number; so, rather than convert the number back to a string, let\u0026rsquo;s just check the number.\nWe are searching for a digest where the first five digits of the hexadecimal representation of the digest are 0. For bytes 0 and 1, this is easy: the value of the byte must be 0. For byte 2, it requires a little bit more thought, since only the first digit must be zero. In this case, it\u0026rsquo;s just a matter of places like in decimal math. There are 16 possible hexadecimal digits, so any value of the byte that is less than 16 will have the first hex digit as 0.\nBy checking this way and avoiding the string conversion, we cut our compute usage down by 10-100x, which is important in this exercise as hashing is not a fast operation, relatively speaking.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i);  We now have our solution, which is the current value of i. Once this is validated, our second puzzle appears:\n Now find one that starts with six zeroes.\n Well, that\u0026rsquo;s succinct, isn\u0026rsquo;t it? Literally all we need to do at this point is resume the loop right where we left off, making one change: we can check that byte 2 of the digest is equal to zero, rather than less than 16:\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; }  We don\u0026rsquo;t even need to reset i here, since by definition a digest can\u0026rsquo;t start with six zeroes without starting with five. In the circumstance that the first digest that begins with five zeroes also begins with six zeroes, the first iteration of our loop will catch it because we broke out of the previous loop before incrementing the index, and we don\u0026rsquo;t increment until the end of the loop.\nWe now have our solution, and can print it and clean up:\nprintf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0; }  When we put it all together, we have:\n\u0026rdquo;\u0026lsquo;c #include  #include  #include  #include  #include  #include \u0026ldquo;common.h\u0026rdquo;\nint main(int argc, char const argv[]) { / check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026ldquo;Must provide filename of input file\\n\u0026rdquo;); return -1; }\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16]; /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i); /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; } printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0;  } ```\n","date":1568084400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568084400,"objectID":"409f0a75a351b9fbce6cf49d57337bb1","permalink":"/post/advent-2015-c-4/","publishdate":"2019-09-10T03:00:00Z","relpermalink":"/post/advent-2015-c-4/","section":"post","summary":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal.","tags":["Programming","Advent of Code","C","Cryptography","Hashing"],"title":"Advent of Code 2015 Day 4: The Ideal Stocking Stuffer","type":"post"},{"authors":null,"categories":null,"content":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;). After each move, he delivers another present to the house at his new location.\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\nFor example:\n \u0026gt; delivers presents to 2 houses: one at the starting location, and one to the east. ^\u0026gt;v\u0026lt; delivers presents to 4 houses in a square, including twice to the house at his starting/ending location. ^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.   This problem seems pretty simple on the face of it, but let\u0026rsquo;s break it down. We will need to:\n Read the input from the file Iterate over the input Track which locations have been visited Count the visited locations  In order to track the location, we\u0026rsquo;ll need to use a slightly more advanced data structure. Since we are working with quantities in 2D space, a 2D array makes sense. Thankfully, in newer versions of the C standard, the array sizes do not need to be known at compile time, so we can avoid some messy pointer arithmetic.\nLet\u0026rsquo;s get to work.\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  If this looks familiar, you\u0026rsquo;re catching on. We check that the filename is provided, read the input file to memory, and handle any errors.\nNow we\u0026rsquo;re ready to get started\u0026hellip; but are we? We still have no idea how big our grid array needs to be. We could guess, but we run the danger of either making the arrays too small and going out-of-bounds, or making them too big and unnecessarily tying up memory. The better plan would be to iterate over the input and test the constraints.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1;  After printing our preamble, we\u0026rsquo;ll create tracking variables for the current x and y positions, and the minimum and maximums of both. We\u0026rsquo;ll initialize all of them to zero, and then iterate over the input, adjusting the current value of x and y and keeping the maximums and minimums updated as needed. Once the loop is complete, we have enough information to compute the sizes of the arrays. Note that we need to add 1 to the total; e.g. 1 - (-1) = 2, but that covers the values -1, 0, 1.\n/* create the grid and travel again */ bool grid[w][h]; memset(grid, 0, w * h * sizeof(bool)); x = 0 - min_x; y = 0 - min_y;  Now that we know the sizes, we can declare the two-dimensional array. Again, older versions of the C standard do not allow runtime determination of the array sizes for stack declarations; if you are stuck using an old version, you will need to allocate the array on the heap with malloc or the like. Since we only need to track if a house has been visited or not, we\u0026rsquo;ll use the bool data type for our grid. The more astute reader might know that bool is still represented with a full byte in C, but we can still use the type as a hint to those who might read your code as to the function.\nOnce we\u0026rsquo;ve declared the array, we will need to initialize it; while we can declare the array in this fashion now, we still cannot initialize it at declaration. We\u0026rsquo;ll use the memset function to zero out the allocated arrays. This is safe with our bool data type as false is represented as 0.\nFinally, we\u0026rsquo;ll set our initial indices for x and y for the upcoming run. Since we cannot have negative indices in an array, we\u0026rsquo;ll need to offset them using the minimum values previously found.\ngrid[x][y] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } grid[x][y] = true; }  We\u0026rsquo;re finally ready to gather our data. We\u0026rsquo;ll iterate through the input again, flipping the value on the grid to true as we visit each space. Notice that we set the origin space to true as well per the problem parameters (He begins by delivering a present to the house at his starting location...).\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses);  Once we\u0026rsquo;ve completed the loop, we can count the houses by iterating through the grid and incrementing a counter for each set of coordinates that is true. The ternary operator is used as a shortcut here.\nOnce we submit our solution, the second problem appears:\n The next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\nThis year, how many houses receive at least one present?\nFor example:\n ^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south. ^\u0026gt;v\u0026lt; now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started. ^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.   As we read, the difference here is that we have a second \u0026ldquo;Santa\u0026rdquo;, and they alternate directions in the input, rather than one taking all the directions. This means we will need to implement a toggle, as well as keep two sets of coordinates on the same grid. As with previous answers, I chose to integrate this solution into the original problem rather than writing a completely new set of code to solve problem 2.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1;  In addition to the single x and y value for the first problem, I declare a two-element array to represent the coordinates of both santas for the second problem. I alse declare and initialize another set of min/max variables. Finally, a variable is declared to act as a toggle between 0 and 1.\nNow to find our coordinates, we run through the loop. We increment the x and y of the appropriate Santa, and check that against the x and y minimums and maximums for the second grid (remember, both Santas share the grid, so there is only one set of mins and maxes). We\u0026rsquo;ll update the values for the second grid based on the active Santa, and then once all values have been updated, we use the bitwise XOR assignment operator to flip the toggle value. Once the loop is complete, we calculate the width and height of the second grid.\n/* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2;  The grid creation for the second problem is identical to the first problem. The only difference comes in assigning the initial coordinates; this needs to be done for both Santas for the second problem.\ns = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; }  During the second iteration of the input, we\u0026rsquo;ll toggle the Santa as we did during the range finding iteration.\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses);  We\u0026rsquo;ll count the number of visited houses for the second grid, exactly as we did the first grid.\nFinally, we\u0026rsquo;ll free our allocated input array for completeness and return success:\nfree(input); return rval; }  All together now:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1; /* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2; s = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; } /* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses); free(input); return rval; }  ","date":1568073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568073600,"objectID":"756b26d309c5f79aaf0044e7d5d609e4","permalink":"/post/advent-2015-c-3/","publishdate":"2019-09-10T00:00:00Z","relpermalink":"/post/advent-2015-c-3/","section":"post","summary":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;).","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum","type":"post"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\nFor example:\n A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet. A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.  All numbers in the elves\u0026rsquo; list are in feet. How many total square feet of wrapping paper should they order?\n As with day 1, we\u0026rsquo;re going to take a minute to break the problem down. As the problem states, the input is formatted as XXxYYxZZ, so we will need to parse the input into usable numbers. Since we need to operate on the smallest dimensions for the slack, we\u0026rsquo;ll need to be able to sort the inputted values. Finally, we\u0026rsquo;ll need to do the math and keep a running total.\nLet\u0026rsquo;s dig in:\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  The preamble to our function is identical to day 1, with the exception of initializing our return value early as we\u0026rsquo;ll be using our goto short circuit pattern to handle some later potential errors. We check that the user provided a filename and read the file into the input buffer.\nprintf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0;  We\u0026rsquo;ll then print our daily header and initialize the running total for the wrapping paper.\n/* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;);  Now we start getting into some more interesting string handling. Note that the input has one present per line, so we need to effectively split the string on the lines. We will use the POSIX strsep function for this. There is a similar strtok function in the C standard librory, but it has the downside of being non-reentrant. If portability is a concern, you may want to stick use strtok, however strsep is widely supported and should be used instead of strtok wherever possible.\nIn order to avoid changing the original value of the pointer to the input, we make a copy into cursor which becomes the moving pointer passed as the first argument of strsep. Finally, we are splitting on the newline character \\n. We will not bother to make a copy of the input buffer as we only need to parse it once.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize;  One side effect of strsep that one needs to be aware of is that if multiple delimiters are encountered in a row, strsep will return a pointer to an empty string instead of consuming all of the delimiters at once. We check for the empty string and short-circuit the loop if we encounter this.\n/* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; }  We now initialize an array of three ints to hold the parsed values. We use an array instead of separate variables because we will need to sort the result. Once the array is initialized, we use the sscanf function to scan the dimensions into the array. As we are not trying to scan into string variables, sscanf is perfectly safe for our usage. As an error check, we will short-circuit to the function cleanup if we have an invalid line which scans less than three values.\nqsort(dims, 3, sizeof(int), cmp_int_asc);  Once the values are scanned, they need to be sorted so that we can find the slack using the smallest side. For this we use the standard library function qsort with a simple comparator function:\nint cmp_int_asc(const void *a, const void *b) { int l = *(const int *)a; int r = *(const int *)b; return l \u0026lt; r ? -1 : l \u0026gt; r ? 1 : 0; }  The comparator dereferences and casts the inputs and then returns -1 if a \u0026lt; b, 1 if a \u0026gt; b, or 0 if they are equal. I use the ternary operator here for conciseness, but I would refrain from using it for anything more complex.\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now that we have our values and we have them sorted by smallest to largest, we just need to do the math and update our running total. As noted in the problem, for each present we need to add the area of each side plus the area of the smallest side as slack: 2xy + 2yz + 2xz + xy.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  Once we have broken out of the input parsing loop, paper should have the total required wrapping paper. We can print the solution and then proceed with cleanup. As noted in day 1, freeing input is not strictly necessary in this case but is good from a habit-forming perspective.\nOnce the solution has been input, the second problem is presented:\n The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don\u0026rsquo;t ask how they tie the bow, though; they\u0026rsquo;ll never tell.\nFor example:\n A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet. A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.  How many total feet of ribbon should they order?\n As with day 1, we already have all of the infrastructure present to handle this new problem. We\u0026rsquo;ll add a new variable to track the running total of ribbon:\nint paper = 0; int ribbon = 0;  Then update the total ribbon on each loop, following the instructions to add 2x+2y+xyz to the total:\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];  Finally, we\u0026rsquo;ll print the second solution:\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon);  When it\u0026rsquo;s all put together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0; int ribbon = 0; /* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; /* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; } qsort(dims, 3, sizeof(int), cmp_int_asc); paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  As before, this program will pass all Valgrind checks and does not leak memory.\nSuggestions, questions, and criticism welcome! Comments can be added below.\n","date":1567994400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567994400,"objectID":"f5e5b339b407c157e6918a4e63e14f57","permalink":"/post/advent-2015-c-2/","publishdate":"2019-09-09T02:00:00Z","relpermalink":"/post/advent-2015-c-2/","section":"post","summary":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.","tags":["Programming","Advent of Code","C","String parsing"],"title":"Advent of Code 2015 Day 2: I Was Told There Would Be No Math","type":"post"},{"authors":null,"categories":null,"content":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere\u0026rsquo;s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can\u0026rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n (()) and ()() both result in floor 0. ((( and (()(()( both result in floor 3. ))((((( also results in floor 3. ()) and ))( both result in floor -1 (the first basement level). ))) and )())()) both result in floor -3.  To what floor do the instructions take Santa?\n Before we start writing code, let\u0026rsquo;s think about what needs to happen. We will need to input a file, read through it, determine which characters are important (( and )) and adjust the floor number accordingly. Then we\u0026rsquo;ll need to output our solution somehow.\nGenerally speaking, each day\u0026rsquo;s puzzle will be its own executable and the input filename will be a command-line argument.\nNow that we have a plan of attack, let\u0026rsquo;s dig in.\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; }  First things first, let\u0026rsquo;s check and make sure the user actually provided a filename. Don\u0026rsquo;t forget that argv[0] is always the name of the invoked command, so argc must be at least 2 if the user has provided any arguments at all. If the argument is not present, we\u0026rsquo;ll print a useful error message to stderr and return from main with a non-zero code.\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;);  Remember that input file function we wrote yesterday? Now we get to use it. We declare a pointer to the buffer and pass it into the function, along with the filename which should be in argv[1]. If the file doesn\u0026rsquo;t exist, isn\u0026rsquo;t readable, or any other problem that we handled in the function, it will return -1 and errno will be set. In that case, we print the error message to stderr and return non-zero. If everything worked, the contents of the file are now in the location in memory pointed to by our input pointer. Once we\u0026rsquo;ve successfully read the file, we\u0026rsquo;ll print our header line for the output.\nNow it\u0026rsquo;s time to solve the problem. The most straightforward way is going to be to iterate over the contents of the file in memory byte-by-byte and adjust the floor accordingly.\n/* solve the first puzzle */ int floor = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor);  We initialize our floor variable to zero as noted in the problem description (He starts on the ground floor (floor 0)...), and then construct a for loop with the index starting at 0 (remember, C arrays are zero-indexed) and incrementing by one until we reach the file size which was returned by our file input function. During each iteration of the loop, we check the byte at that index and either increment or decrement the floor number depending on the character. In this case, I have chosen to ignore any spurious characters that may be in the input.\nThe object of the problem is to determine which floor we arrive at (To what floor do the instructions take Santa?), so the value of the floor variable is our solution.\nOnce we input our solution, a second problem appears!\n Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n ) causes him to enter the basement at character position 1. ()()) causes him to enter the basement at character position 5.  What is the position of the character that causes Santa to first enter the basement?\n In the interest of saving compute time and code, we will attempt to integrate the finding of the second solution into the original code. In this case, it\u0026rsquo;s a matter of finding the index where we first hit floor -1. We can do this by setting a variable to a known bad value, and checking whether it has been reset to a known good value and if not, setting it. So, we\u0026rsquo;ll update our problem logic as such:\n/* solve the puzzles */ int floor = 0; int basement = -1; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == -1) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement);  In this updated logic, we set basement to a sentinel value of -1; since we are counting up, the value cannot possibly be negative. Then, in each iteration of the loop, we check for the floor to be -1 (since we can only move one floor at a time) and for the basement value to be the sentinel. For those of you counting instructions, notice that the floor check will short-circuit; i.e. the basement check will not happen unless the floor is -1. The net effect is that on average we are only adding one instruction per loop. Also notice that we set the value of basement to i + 1 as the positions are one-indexed per the problem parameters (The first character in the instructions has position 1...).\nfree(input); return 0; }  Now that we have solved the problem, we\u0026rsquo;ll clean up and return 0. Note that it is not strictly necessary to free input, but it is a good habit to be in.\nHere\u0026rsquo;s the whole program for day 1:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;); /* solve the puzzles */ int floor = 0; int basement = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == 0) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement); free(input); return 0; }  This program makes proper error checks and manages memory properly, and will pass all Valgrind checks in a variety of test scenarios.\nIf I\u0026rsquo;ve done something horribly wrong or you have questions, please comment!\n","date":1567987200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567987200,"objectID":"b231645316f12b2922f38f7ba06232ed","permalink":"/post/advent-2015-c-1/","publishdate":"2019-09-09T00:00:00Z","relpermalink":"/post/advent-2015-c-1/","section":"post","summary":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 1: Not Quite Lisp","type":"post"},{"authors":null,"categories":null,"content":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management. In order to up the challenge, the solutions will be written in C, and the code will pass all Valgrind tests for memory leaks and other issues. All code discussed in these posts will be in my Advent of Code solutions repository.\nTo kick things off, we\u0026rsquo;ll take a look at code reuse. When you\u0026rsquo;re quickly prototyping or problem solving, you\u0026rsquo;re frequently going to have identical snippets of code in multiple places. If we\u0026rsquo;re writing high-quality code, we want to avoid this wherever possible. One common theme throughout the Advent of Code problems will be reading an input file into memory. In order to avoid writing the same code over and over, we\u0026rsquo;re going to start things off by writing a function to read a file into a memory buffer:\nint read_file_to_buffer(char **buf, char *filename);  Already, just in the function signature, we are making design decisions. We could have written the function to return the pointer to the memory buffer, and in most languages this makes the most sense. However, in C, the length of an array is not an integral part of the data type, so we need to pass that information back as well. Therefore, I made the decision to pass a pointer to pointer to char (array) to the function, which will be modified in the function with the actual pointer to the allocated buffer, and to return the size of the buffer in the return value (or -1 if there is an error). We use this pattern rather than passing in the buffer itself because we do not know ahead of time how the buffer needs to be sized. The caller will be responsible for freeing the buffer when they are done using it.\nNow, lets think about what actually needs to happen to read a file into memory, and what can go wrong.\n Does the file exist? Is it a valid, readable file? How big is the file; consequently, how big does my buffer need to be? What happens if we don\u0026rsquo;t succeed in reading the actual data?  As you can see, when reading a file, there are a lot of potential failure points. Keeping that in mind, let\u0026rsquo;s start writing our code.\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */  The first thing we do is initialize variables that will exist for the life of the function (and be part of the cleanup). rval will hold our return value, f will hold our file pointer, and *buf is the pointer to the buffer that will hold the file contents, which is passed in as a parameter. Each is initialized to a sane default, as variables are not automatically initialized in C.\nWith that out of the way, we\u0026rsquo;ll make our first check. Using the POSIX stat function, we query the file for information. Right off the bat, this will tell us if the file exists; if it does not, stat will return -1 and set errno accordingly. If we see this, we will jump to our error cleanup.\nAt this point, I\u0026rsquo;m going to take a sidebar and talk a bit about goto. For most programmers, there\u0026rsquo;s a knee-jerk reaction to avoid goto at all costs. Generally, I agree with this with one exception: error cleanup. In this case, goto properly used provides an avenue to short-circuit function execution and provide for cleanup in the case of an error without reusing the same code.\nIf the file exists, the struct stat will be populated with information about the file, including the type and size. Continuing on:\n/* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; }  Our next check is that we are working with a regular file, as opposed to a directory, block device, or other file type. (note: stat follows symlinks!). We use the S_ISREG macro to accomplish this. Because this is a check and not necessarily an error condition, if the provided file is not a regular file we will set errno ourselves to indicate an invalid parameter and then jump to our error cleanup.\n/* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */  Now that we know the file exists, and that it\u0026rsquo;s a regular file, we will try to open it for reading. If the file is not readable for any reason, fopen will return NULL and set errno appropriately. We will check for the NULL return value and short-circuit as needed.\n/* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */  Now that we\u0026rsquo;ve successfully opened the file, we\u0026rsquo;ll allocate the buffer. Even though we already had the size information from the stat call, I\u0026rsquo;ve chosen not to allocate the buffer until we know the file is readable, to avoid unnecessary allocations. For this problem it doesn\u0026rsquo;t really matter, but it\u0026rsquo;s a good habit to be in. If there is an error allocating the buffer such as running out of memory, malloc will return NULL and set errno; again we will check for this and short-circuit the function as necessary. I\u0026rsquo;m using malloc instead of calloc because we have designed the function such that the buffer will be completely filled by the file, negating the need to initialize it. The extra +1 is to make room for a null terminator so that we may treat the buffer as a string.\n/* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup;  Now we perform the actual read. fread is a buffered read which calls the low-level read syscall, and as such it will block until the requested size is read unless there is an error, allowing us to avoid need to loop until the expected data is read. Instead, we will check to make sure the expected size of data is read (the file size) and check for an error if it is not. If there is an error reading the file, we\u0026rsquo;ll short-circuit to our error cleanup.\n/* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup;  We finish up the logic of our function by setting the extra allocated byte at the end of the buffer to a null terminator, then set the return value to the amount of data read, and finally jumping to our non-error cleanup. Array indeces have a higher precedence than the indirection operator, so we need to enclose the indirection in parentheses to avoid writing to the wrong memory address.\nerr_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval;  Now for our cleanup. There are two things that need to be cleaned up in this function: first, the file needs to be closed if it was opened, to avoid file handle leaks. Also, if there was an error, the data buffer needs to be freed if it was allocated and the pointer set to NULL. Finally, if we did error, we set rval to -1 which indicates the error to the caller, who can then get more information by inspecting errno.\nThe whole function:\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */ /* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; } /* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */ /* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */ /* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup; /* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup; err_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval; }  We\u0026rsquo;ve now written a function with appropriate error checking that can be reused throughout our Advent of Code exercises!\n","date":1567980000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567980000,"objectID":"4a19ca9dcbe5acd4634b1a929187717f","permalink":"/post/advent-setup-c/","publishdate":"2019-09-08T22:00:00Z","relpermalink":"/post/advent-setup-c/","section":"post","summary":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management.","tags":["Programming","Advent of Code","C","Best practices","DRY"],"title":"Advent of Code deep dive kickoff","type":"post"},{"authors":null,"categories":null,"content":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.\n","date":1567468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567468800,"objectID":"7b1a7e9fadbc0ac76e4a203dc7dda3a9","permalink":"/post/e3b0c442-returns/","publishdate":"2019-09-03T00:00:00Z","relpermalink":"/post/e3b0c442-returns/","section":"post","summary":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.","tags":["Personal","Website"],"title":"Return of the... me?","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About Me","type":"widget_page"}]