[{"authors":["nick"],"categories":null,"content":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.\nPGP fingerprint: 9408 6361 4B0B 3307 5068 5FE8 DD3F EC7C 659D CEA2\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"22df73ca0cc2e5922b5f427771bc24c0","permalink":"/authors/nick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/nick/","section":"authors","summary":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.","tags":null,"title":"Nick Meyer","type":"authors"},{"authors":null,"categories":null,"content":"After 18 years of exclusively using Mac laptops, I ordered a ThinkPad today.\nWhy? In short, the value proposition of a Mac notebook no longer makes sense.\nAs Mac computers have made up a progressively smaller slice of Apple\u0026rsquo;s revenue pie, the effort put into innovation has waned, and with it, a lot of the magic of Apple\u0026rsquo;s unique ability to control both the hardware and software stacks. Couple this with advancements in hardware quality by other vendors, and improvements in the usability of both Windows and Linux operating systems, Apple\u0026rsquo;s lead in this space has narrowed significantly. This is compounded by Apple\u0026rsquo;s insistence on pushing form over function.\nThe end result? A machine which at the hardware level is functionally inferior at a greater price, without the Apple magic.\nThe ThinkPad I ordered is a half-inch wider, two-tenths of an inch deeper, and one-tenth of an inch thicker than a current 15-inch MacBook Pro, yet there is no glue, almost everything is repairable, and the expected parts are upgradeable (2 SO-DIMM slots and two NVMe M.2 slots). It doesn\u0026rsquo;t force me to use a port which, while superior, still has a dearth of released hardware. It has a fantastic keyboard with full travel. It is Mil-Spec tested for durability. It has all of this in spite of its relative thinness, and in spite of the fact that it costs two-thirds the price of a comparable MacBook Pro.\nMy current MacBook Pro has served me well for six years, but I couldn\u0026rsquo;t keep waiting for Apple to figure out that thin and light doesn\u0026rsquo;t need to mean expensive and disposable.\nI want to say I\u0026rsquo;ll miss macOS, but honestly, Linux and Windows have both come a long way in recent years, and macOS has stagnated. Given that iDevices have become more independent, and Apple is expanding its services to other platforms to extend their service revenue, the only thing one really needs a Mac for anymore is writing code for macOS/iOS, which I haven\u0026rsquo;t done for nearly a decade at this point.\nI\u0026rsquo;m not giving up my iPhone or iPad anytime soon, they are very clearly superior devices and I don\u0026rsquo;t expect that to change in the near term. But for general-purpose computers, I just can\u0026rsquo;t justify paying a 50% premium for a less-capable machine that I don\u0026rsquo;t even have the future option of making more capable.\nApple is showing glimmers of understanding that they have swung the needle too far on the form/function scale. The modularity and expandability of the new Mac Pro sets a new standard in the space. They have eschewed the proprietary Lightning port for a standard USB-C on the iPad Pro. Maybe in a few years when it\u0026rsquo;s time to look at upgrading again, the Apple magic will be back.\nIn the meantime, I\u0026rsquo;m going to enjoy that sweet, sweet Thinkpad keyboard.\n","date":1572393600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572393600,"objectID":"ab044e61d5608d555e53696f6a331197","permalink":"/post/thinkpad/","publishdate":"2019-10-30T00:00:00Z","relpermalink":"/post/thinkpad/","section":"post","summary":"After 18 years of exclusively using Mac laptops, I ordered a ThinkPad today.\nWhy? In short, the value proposition of a Mac notebook no longer makes sense.\nAs Mac computers have made up a progressively smaller slice of Apple\u0026rsquo;s revenue pie, the effort put into innovation has waned, and with it, a lot of the magic of Apple\u0026rsquo;s unique ability to control both the hardware and software stacks. Couple this with advancements in hardware quality by other vendors, and improvements in the usability of both Windows and Linux operating systems, Apple\u0026rsquo;s lead in this space has narrowed significantly.","tags":["Apple","Lenovo","ThinkPad","MacBook Pro","opinion"],"title":"Passing the torch","type":"post"},{"authors":null,"categories":null,"content":"It\u0026rsquo;s been a few weeks, but I\u0026rsquo;m glad to be able to pick up the Advent of Code series again. In the last post, I took a bit of a digression to discuss hash tables. In today\u0026rsquo;s post, we\u0026rsquo;ll see why. Let\u0026rsquo;s see what we have in store for day 7:\n This year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.\nEach wire has an identifier (some lowercase letters) and can carry a 16-bit signal (a number from 0 to 65535). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.\nThe included instructions booklet describes how to connect the parts together: x AND y -\u0026gt; z means to connect wires x and y to an AND gate, and then connect its output to wire z.\nFor example:\n 123 -\u0026gt; x means that the signal 123 is provided to wire x. x AND y -\u0026gt; z means that the bitwise AND of wire x and wire y is provided to wire z. p LSHIFT 2 -\u0026gt; q means that the value from wire p is left-shifted by 2 and then provided to wire q. NOT e -\u0026gt; f means that the bitwise complement of the value from wire e is provided to wire f.  Other possible gates include OR (bitwise OR) and RSHIFT (right-shift). If, for some reason, you\u0026rsquo;d like to emulate the circuit instead, almost all programming languages (for example, C, JavaScript, or Python) provide operators for these gates.\nFor example, here is a simple circuit:\n\u0026gt; 123 -\u0026gt; x \u0026gt; 456 -\u0026gt; y \u0026gt; x AND y -\u0026gt; d \u0026gt; x OR y -\u0026gt; e \u0026gt; x LSHIFT 2 -\u0026gt; f \u0026gt; y RSHIFT 2 -\u0026gt; g \u0026gt; NOT x -\u0026gt; h \u0026gt; NOT y -\u0026gt; i \u0026gt; ```  After it is run, these are the signals on the wires:\nd: 72 e: 507 f: 492 g: 114 h: 65412 i: 65079 x: 123 y: 456  In little Bobby\u0026rsquo;s kit\u0026rsquo;s instructions booklet (provided as your puzzle input), what signal is ultimately provided to wire a?\n This is a fairly complex problem, and in contrast to previous days\u0026rsquo; entries, there is more than one way to go about solving it successfully and efficiently. I chose to solve this problem by creating hash tables with the gate statements, and then recursively calling an operator function to find the gate value. Hash tables are approprate for this task for two reasons:\n Accessing the gate instructions will effectively be random-access since there is no linearity to how the instructions are arranged. Hash tables on average have O(1) time complexity for searches. The gates are named by strings, allowing us to translate them directly into hash table keys.  We will utilize the esht implementation discussed in the prior article. As noted in that article, while there is a POSIX hash table implementation, it is non-reentrant, and a re-entrant version included as part of the GNU C library is not present in many UNIX flavors, including macOS. In this case, reentrancy is important as we will soon see that we need to maintain two tables.\nAs we examine this problem, what might immediately jump out is that each of these gates is a function that takes one or two 16-bit input values and outputs another value. Indeed, it would be possible, and some might consider elegant, to parse the inputs into a linked tree of function pointers using function pointers. However, I feel like this adds some unnecessary complexity and does not avoid the need for an additional caching mechanism, which is necessary due to the fact that we cannot guarantee that the gates are a true tree.\nGiven this, it is much simpler and cleaner to parse the gate definitions into a data structure and make recursive calls to a single executor function to accomplish the goal of the task.\nWith that lengthy discussion out of the way, let\u0026rsquo;s break the problem down a bit as we have done in previous weeks.\n Read the input file into memory Parse the individual gates into a hash table Execute the gates  As gates can also be inputs to another gate, we will need to call the gate executor recursively, so we will make this a separate function. We\u0026rsquo;ll start our coding here.\nuint16_t do_op(esht *instrs, esht *cache, char *key)  Our gate execution function takes three arguments: the hash table with the gate instructions keyed by gate name, a cache of already-resolved values also keyed by the gate name, and the gate key itself. The return value is uint16_t, which is an unsigned 16-bit integer.\n{ uint16_t rval; uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL); if (cached != NULL) { rval = *cached; free(cached); return rval; }  The first thing we are going to do is check for a cached value. We use the provided key and cache table pointer to call esht_get(); we cast the return value to a pointer to uint16_t as the values are stored in the hash table as void pointers. If a result is found in the cache, we copy the value, clean up the allocated memory (remember that with esht, the caller is responsible for cleanup of returned values), and return the retrieved value.\nchar *instr = (char *)esht_get(instrs, key, NULL); if (instr == NULL) { errno = ENOKEY; goto err_cleanup; } regmatch_t matches[4] = {0}; int res = regexec(\u0026amp;instr_r, instr, 4, matches, 0); if (res == REG_NOMATCH) { errno = EINVAL; goto err_cleanup; }  If there is no value in the cache for the key, it is time to start solving the gate value. We\u0026rsquo;ll first pull the gate definition from the hash table where we\u0026rsquo;ve already stored it. We then declare an array of four matches; the instruction parsing expression has three submatches in addition to the whole string match, which we will discuss later. For now, it is sufficient to know that we are capturing the three components of the gate expression. Finally, we execute the regular expression to populate the match variables. If either the instruction lookup fails or the regular expression execution returns no match, errno is set appropriately and execution jumps to the error cleanup handler.\nchar ls[6] = {0}; char op[7] = {0}; char rs[6] = {0}; char *check; unsigned long l, r = 0;  Now we start working on the gate values. First, we set up temporary buffers for the string representations of each of the components of the gate expression: the left operand, the operation, and the right operand. The buffer sizes are chosen specifically; since l and r can be no larger than 65536, we know that 5 characters is the max storage; likewise, the longest gate operation is 6 characters. All buffers have the extra byte for the null terminator, and are initialized appropriately. We then additionally define a char pointer which is used as part of the strtoul error check, and finally integral values for the left and right operands of the gate.\nif (matches[1].rm_so != -1) { strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); l = strtoul(ls, \u0026amp;check, 10); if (strlen(ls) \u0026gt; 0) if (l == 0 \u0026amp;\u0026amp; check == ls) { l = do_op(instrs, cache, ls); if (l == UINT16_MAX \u0026amp;\u0026amp; errno != 0) goto err_cleanup; } }  With our variable initalization complete, we\u0026rsquo;ll start checking the values. For the left operand, the first thing we will check is that it is actually there, since some gates only have a single (right) operand. One useful properties of regular expressions in this case is that even if a submatch is conditional, its position in the results is still preserved, so we know that the right operand will always have match index 3, regardless of whether the left operand and operator exist at all. If the submatch does not actually exist, member rm_so of the regmatch_t returned by regexec will be -1.\nOnce we\u0026rsquo;ve verified the submatch exists, we will copy just the submatch value to our temporary buffer by using the offests returned in the regmatch_t. We will then attempt to convert the buffer to an unsigned long using strtoul. We pass check into the function; if the value of check is the same as the string pointer once the operation is done and the return value is 0, we know that no number was actually found in the string and we can assume that rather than a value, it is the key to another gate and we can consequently make the recursive call. If the call returns the sentinel value and errno is set, we\u0026rsquo;ll propogate that up.\nif (matches[3].rm_so != -1) { strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so); r = strtoul(rs, \u0026amp;check, 10); if (strlen(rs) \u0026gt; 0) { if (r == 0 \u0026amp;\u0026amp; check == rs) { r = do_op(instrs, cache, rs); if (r == UINT16_MAX \u0026amp;\u0026amp; errno != 0) goto err_cleanup; } } else { errno = EINVAL; goto err_cleanup; } }  Now we do the same for the right operand; the only difference being that we always expect the right operand to be there; if it is absent, that is considered an error and we will return appropriately.\nif (matches[2].rm_so != -1) { strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); if (!strcmp(op, \u0026quot;LSHIFT\u0026quot;)) rval = l \u0026lt;\u0026lt; r; else if (!strcmp(op, \u0026quot;RSHIFT\u0026quot;)) rval = l \u0026gt;\u0026gt; r; else if (!strcmp(op, \u0026quot;AND\u0026quot;)) rval = l \u0026amp; r; else if (!strcmp(op, \u0026quot;OR\u0026quot;)) rval = l | r; else if (!strcmp(op, \u0026quot;NOT\u0026quot;)) rval = ~r; else { errno = EINVAL; goto err_cleanup; } } else rval = r;  Then we will parse the operator. We know what the expected values are here; if the operator does not exist, we know that we are just returning the value provided by the right operand; else, we find one of the known bitwise operations and perform it, setting the return value accordingly. If the operator exists but is not an expected value, this is an error condition and we jump appropriately.\nesht_update(cache, key, \u0026amp;rval, sizeof(uint16_t)); goto cleanup; err_cleanup: rval = UINT16_MAX; cleanup: if (instr != NULL) free(instr); return rval; }  If we have gotten this far, we now have a final value for this gate that can be cached. We will add the value to the cache table with the gate\u0026rsquo;s key so that future calls to this gate can just return the cached value. Then we will go to the cleanup, where we make sure to free the instruction we retrieved from the hash table and free our iretrieved instruction.\nNow that we have our operation function implemented, we can look at the containing function for the problem.\nint main(int argc, char const *argv[]) { int rc, res = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 7:\\n\u0026quot;);  Identically to previous days, we parse the arguments, open the file, and copy it into memory.\n/* create the regular expression for parsing into the table */ regex_t gate_r; int result = regcomp(\u0026amp;gate_r, \u0026quot;(.*) -\u0026gt; ([a-z]+)\u0026quot;, 0); if (result != 0) goto err_cleanup;  We then compile the regular expression that splits the gate operation from its key. If this returns an unexpected result, we will jump to the error cleanup. This is a fairly simple regex, that captures two submatches: anything to the left of -\u0026gt;, and then a gate key to the right of -\u0026gt;, which is only letters.\nchar *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[3] = {0}; esht *inst_table = esht_create(); if (inst_table == NULL) goto err_cleanup;  Now we will set up some variables in preparation for looping over the input, including our line cursor and an array of regmatch_t for capturing the gate operations and keys, which we initialize to all zeroes on declaration. Then we create the table that will hold all of the gates.\n/* parse the gates into the hash table */ while (line != NULL) { if (strlen(line) == 0) goto tokenize; memset(matches, 0, 3 * sizeof(regmatch_t)); result = regexec(\u0026amp;gate_r, line, 3, matches, 0); if (result != 0) goto err_cleanup; char key[4] = {0}; char val[64] = {0}; strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); int res; if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0) goto err_cleanup; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now we loop over the input, parsing the input lines into the hash table. We first check that there is actually length ta the line; if so, then we zero out the match objects (since we aren\u0026rsquo;t declaring them inside the loop) and execute the regular expression against the line. If there is no match, we\u0026rsquo;ll break the loop and error out.\nAssuming all goes well, we will then declare temporary buffors for the key and value; we chose a sane length for both to avoid the need to allocate on the heap. We then use the offsets in the regmatch_t to copy the key and gate operation into the buffers. Finally, we add the gate to the hash table, erroring out if there is an unexpected return from the update operation.\nresult = regcomp(\u0026amp;instr_r, \u0026quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$\u0026quot;, 0); if (result) goto err_cleanup;  We then create the expression for parsing the gate operations, which is stored in a file-local manner as mentioned before. This expression searches for an optional alphanumeric value, followed by an optional operator from the list provided in the problem specification, followed by a required alphanumeric expression. If there is a problem compiling the regular expression, we\u0026rsquo;ll jump to the error handler.\n/* create a cache and perform the recursive operation to get the gate value */ esht *cache = esht_create(); if (cache == NULL) goto err_cleanup; uint16_t a = do_op(inst_table, cache, \u0026quot;a\u0026quot;); printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, a);  Then we allocate another table to cache values. This is required due to the fact that the connections between the gates form more of a web than a tree, which can cause, if not complete short-circuits, unnecessary multiple executions of the gate to find the value. We call the operation function with the key \u0026ldquo;a\u0026rdquo; as defined in the problem statement, which will recursively call itself with the appropriate gates to calculate the final value at wire \u0026ldquo;a\u0026rdquo;, which we will then print.\nNow that we have solved the first problem, let\u0026rsquo;s see what the second problem will require:\n Now, take the signal you got on wire a, override wire b to that signal, and reset the other wires (including wire a). What new signal is ultimately provided to wire a?\n It\u0026rsquo;s a good thing we made that cache table! Since we didn\u0026rsquo;t alter the original instructions, all we need to do is destroy the old cache, then set value \u0026ldquo;b\u0026rdquo; in the new cache as directed in the instructions:\n/* clear cache and set b to value of a */ esht_destroy(cache); cache = esht_create(); if (cache == NULL) goto err_cleanup; if ((res = esht_update(cache, \u0026quot;b\u0026quot;, \u0026amp;a, sizeof(uint16_t))) != 0) goto err_cleanup; /* get solution 2 */ a = do_op(inst_table, cache, \u0026quot;a\u0026quot;); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, a); goto cleanup;  Once Solution 2 is printed, we can clean up:\nerr_cleanup: rc = -1; cleanup: if (cache != NULL) esht_destroy(cache); regfree(\u0026amp;instr_r); if (inst_table != NULL) esht_destroy(inst_table); regfree(\u0026amp;gate_r); free(input); return rc; }  Putting the whole thing together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;pcreposix.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; #include \u0026quot;esht.h\u0026quot; static regex_t instr_r; uint16_t do_op(esht *instrs, esht *cache, char *key) { uint16_t rval; uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL); if (cached != NULL) { rval = *cached; free(cached); return rval; } char *instr = (char *)esht_get(instrs, key, NULL); if (instr == NULL) { errno = ENOKEY; goto err_cleanup; } regmatch_t matches[4] = {0}; int res = regexec(\u0026amp;instr_r, instr, 4, matches, 0); if (res == REG_NOMATCH) { errno = EINVAL; goto err_cleanup; } char ls[6] = {0}; char op[7] = {0}; char rs[6] = {0}; char *check; unsigned long l, r = 0; if (matches[1].rm_so != -1) { strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); l = strtoul(ls, \u0026amp;check, 10); if (strlen(ls) \u0026gt; 0) if (l == 0 \u0026amp;\u0026amp; check == ls) { l = do_op(instrs, cache, ls); if (l == UINT16_MAX \u0026amp;\u0026amp; errno != 0) goto err_cleanup; } } if (matches[3].rm_so != -1) { strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so); r = strtoul(rs, \u0026amp;check, 10); if (strlen(rs) \u0026gt; 0) { if (r == 0 \u0026amp;\u0026amp; check == rs) { r = do_op(instrs, cache, rs); if (r == UINT16_MAX \u0026amp;\u0026amp; errno != 0) goto err_cleanup; } } else { errno = EINVAL; goto err_cleanup; } } if (matches[2].rm_so != -1) { strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); if (!strcmp(op, \u0026quot;LSHIFT\u0026quot;)) rval = l \u0026lt;\u0026lt; r; else if (!strcmp(op, \u0026quot;RSHIFT\u0026quot;)) rval = l \u0026gt;\u0026gt; r; else if (!strcmp(op, \u0026quot;AND\u0026quot;)) rval = l \u0026amp; r; else if (!strcmp(op, \u0026quot;OR\u0026quot;)) rval = l | r; else if (!strcmp(op, \u0026quot;NOT\u0026quot;)) rval = ~r; else { errno = EINVAL; goto err_cleanup; } } else rval = r; esht_update(cache, key, \u0026amp;rval, sizeof(uint16_t)); goto cleanup; err_cleanup: rval = UINT16_MAX; cleanup: if (instr != NULL) free(instr); return rval; } int main(int argc, char const *argv[]) { int rc, res = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 7:\\n\u0026quot;); /* create the regular expression for parsing into the table */ regex_t gate_r; int result = regcomp(\u0026amp;gate_r, \u0026quot;(.*) -\u0026gt; ([a-z]+)\u0026quot;, 0); if (result != 0) goto err_cleanup; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[3] = {0}; esht *inst_table = esht_create(); if (inst_table == NULL) goto err_cleanup; /* parse the gates into the hash table */ while (line != NULL) { if (strlen(line) == 0) goto tokenize; memset(matches, 0, 3 * sizeof(regmatch_t)); result = regexec(\u0026amp;gate_r, line, 3, matches, 0); if (result != 0) goto err_cleanup; char key[4] = {0}; char val[64] = {0}; strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0) goto err_cleanup; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } result = regcomp(\u0026amp;instr_r, \u0026quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$\u0026quot;, 0); if (result) goto err_cleanup; /* create a cache and perform the recursive operation to get the gate value */ esht *cache = esht_create(); if (cache == NULL) goto err_cleanup; uint16_t a = do_op(inst_table, cache, \u0026quot;a\u0026quot;); printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, a); /* clear cache and set b to value of a */ esht_destroy(cache); cache = esht_create(); if (cache == NULL) goto err_cleanup; if ((res = esht_update(cache, \u0026quot;b\u0026quot;, \u0026amp;a, sizeof(uint16_t))) != 0) goto err_cleanup; /* get solution 2 */ a = do_op(inst_table, cache, \u0026quot;a\u0026quot;); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, a); goto cleanup; err_cleanup: rc = -1; cleanup: if (cache != NULL) esht_destroy(cache); regfree(\u0026amp;instr_r); if (inst_table != NULL) esht_destroy(inst_table); regfree(\u0026amp;gate_r); free(input); return rc; }  This is by far the most complex problem we have dealt with, requiring both a new data structure and the use of recursion to solve.\nAs always, feel free to leave a comment if you have constructive feedback. We\u0026rsquo;ll be back for day 8 shortly!\n","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571097600,"objectID":"6a932712e468b25c104fa41192026c6b","permalink":"/post/advent-2015-c-7/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/post/advent-2015-c-7/","section":"post","summary":"It\u0026rsquo;s been a few weeks, but I\u0026rsquo;m glad to be able to pick up the Advent of Code series again. In the last post, I took a bit of a digression to discuss hash tables. In today\u0026rsquo;s post, we\u0026rsquo;ll see why. Let\u0026rsquo;s see what we have in store for day 7:\n This year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.","tags":["Programming","Advent of Code","C","Data Structures","Regular Expressions"],"title":"Advent of Code 2015 Day 7: Some Assembly Required","type":"post"},{"authors":null,"categories":null,"content":"The code discussed here can be found on Github\nBefore we tackle Day 7, we need to talk a bit about data structures. Choosing the proper data structures for your program\u0026rsquo;s data is extremely important in making your application both performant and easily understood.\nAs we will see in Day 7\u0026rsquo;s discussion, we will need to be able to access an item by a provided string key. Storing these items in a linked list or array would work, but would be unnecessarily slow as the array would need to be iterated each time we try to find the item we are searching for. While there are ways to optimize this, such as by using binary search on a sorted array, these still only achieve an average time complexity of O(log(n)).\nThe solution in this case is to use a hash table. Hash tables allow for a quick access given a piece of data (generally a string) as a key. This is accomplished by using a hashing algorithm to convert the key into a numerical value which can then be used as an array index. Given a well designed hash table, average search time can be constant time.\nUnfortunately, the C standard library comes with neither a hash table implementation nor a hash algorithm. POSIX defines a hash table, but it is defined and stored globally, making it effectively non-reentrant. While this is of only a minor concern for us at this time, it also means that only one such table can be defined at a given time, which will likely be an issue in all but the most simple programs. GNU provides an extension which contains reentrant versions of the POSIX algorithm, but it is not available on even all UNIX platforms, most notably macOS.\nFor these reasons, we will take some time and thought in this post to design and construct a hash table that gets around these limitations. We will have two primary design motivations:\n The table will be universal, so it must compile on standard C. I\u0026rsquo;m going to take this a step further and make it valid ANSI C. The table will be simple for end users. We will make a clear demarcation of responsibility for memory; each time the user adds something to the table, the key and value are copied, and the hash table owns those copies. When an item is retrieved, it is copied out. Therefore the end user is responsible for freeing all items provided to or retrieved from the table, but not the copies in the table.  Regardless of platform, there are two important design decisions that need to be made when designing a hash table:\n Hashing algorithm. The choice of hashing algorithm is very important. If a slow algorithm is used, the speed benefits of the hash table are reduced as the time to calculate hashes is high. If an algorithm with poor distributions are used, there will be additional collisions and therefore additional need to iterate over the hash buckets to find the requested item. Realistically, we need a hash algorithm which will produce a hash that fits in a standard numerical data type. Collision handling. Even with a proper hash algorithm, unless you are using the full value of a modern cryptographic hash (Hint: don\u0026rsquo;t do this, they are slow and unnecessary, and you can\u0026rsquo;t use the full value anyway!), you will inevitably have collisions \u0026ndash; two identical keys which produce the same hash digest. There are two common ways to handle this: using chaining, i.e. each hash key points to an array or linked list instead of a single item; or by using open addressing, in which we make the primary array larger and, if an item already occupies the hash slot, iterating along the array until an open position is found.  For our hash table, we will use Daniel J. Bernstein\u0026rsquo;s DJB2a algorithm. This algorithm is simple and extremely fast, yet has reasonably good distribution. To handle collisions, we will use chaining with a singly-linked list. This reduces the complexity of adding and removing items from the chain with little to no performance penalty over an array iteration.\nIn order to implement our hash table, we need to handle five different operations:\n Allocating and initializing the table Inserting items into the table (or updating items already in the table) Searching for items in the table Deleting items from the table Destroying the table when we are done using it.  Depending on one\u0026rsquo;s use case, there may be a desire to separate the adding and updating functions. As we are trying to keep things simple though, we will keep them as one function under the assumption that if an item exists for the key, it will be updated.\nTo start things off, we will need to create structures for the data in the table. In addition to the data itself, we need to track the key used to access the data and, since we will not be assuming a data type, the size of the data. In addition, since we are using linked-list chaining to handle collisions, we will need to have a pointer to the next item in the chain.\ntypedef struct esht_entry { char *k; /* key */ void *v; /* value */ size_t l; /* size */ struct esht_entry *n; /* pointer to next item in chain */ } esht_entry;  With this structure defined, we can then define the structure for the table. This structures tracks both the current number of entries in the table, and the current size of the array backing the table, as well as the array itself. The size and capacity are used to calculate the load factor. Generally speaking, the load factor of a hash table should be kept below 80% to ensure minimal collisions, thus keeping performance high.\nstruct esht { size_t len; /* current size */ size_t cap; /* current size of backing array */ esht_entry **entries; /* array of pointers to entries */ };  With these structs defined, we now have a place for all of the information that needs to be stored as part of our hash table. Now, we want to define our hash function. As mentioned before, this is Daniel J. Bernstein\u0026rsquo;s DJB2a algorithm:\nunsigned long esht_hash(char *str) { unsigned long hash = 5381; int c; while ((c = *str++)) hash = ((hash \u0026lt;\u0026lt; 5) + hash) ^ c; return hash; }  Now we can get down to the business of allocating and initializing the hash table. For simplicity\u0026rsquo;s sake, we are going to design our table with an initial capacity of 1. We will allocate the memory for the table struct, set the capacity and length, and allocate the memory for the backing array. We will check for errors after each allocation and return NULL on error, or return a pointer to the table struct if everything goes as planned. Note that we will use an array of pointers to item structs, rather than making an array of item structs themselves; this will simplify the addition and removal of items later on. We also use malloc to allocate the table, but calloc to allocate the array. This is because we will explicitly initialize the table members, but the array will just have NULL pointers to start since there are no items. (The value of a NULL pointer is 0).\nesht *esht_create() { esht *table; table = malloc(sizeof(esht)); if (table == NULL) return NULL; table-\u0026gt;cap = 1; table-\u0026gt;len = 0; table-\u0026gt;entries = calloc(1, sizeof(esht_entry *)); if (table-\u0026gt;entries == NULL) { free(table); return NULL; } return table; }  Now that we have a table, we can start doing operations on it. However, there is one common piece of code that can be factored out, and that is the resize operation, which will resize the backing array and redistribute the elements.\nA bit of explanation: In order to not consume an inordinate amount of memory (e.g. 2**32 * sizeof(esht_entry *)), we don\u0026rsquo;t actually use the full hash value, but the modulus of the hash value against the capacity of the array. The size of the array then becomes the second operand of the modulus. The side effect of this is that the array lookup index will change any time the array is resized, so we need to recompute the lookup index by re-hashing and modulizing the key.\nWhat this means is that you want to be judicious with resizing, as there will be a performance hit while the entirety of the table\u0026rsquo;s keys are hashed again. For our table, we are setting a maximum load factor of 0.75 and a minimum load factor of 0.25, and then either doubling or cutting in half the size once those limits are breached. This allows for a bit of hysteresis, so that if there are several insert or delete operatinos close to either limit, the table wouldn\u0026rsquo;t be resized on every insert/delete. If we wanted to simplify further, we could remove the minimum load factor and only allow the table to grow, but this potentially causes a memory leak.\nint esht_resize(esht *table, size_t new_cap) { /* declare variables at the beginning to conform with ANSI C */ int i, ii; esht_entry *cur, *next, **old; /* allocate and zero out a new backing array */ esht_entry **new_entries = calloc(new_cap, sizeof(esht_entry *)); if (new_entries == NULL) return 1; /* iterate over the old array... */ for (i = 0; i \u0026lt; table-\u0026gt;cap; i++) { /* ...and then over the chains, recompute the hash index for each item, and insert the item into the new array */ next = table-\u0026gt;entries[i]; while (next != NULL) { cur = next; next = cur-\u0026gt;n; ii = esht_hash(cur-\u0026gt;k) % new_cap; cur-\u0026gt;n = new_entries[ii]; new_entries[ii] = cur; } } /* replace the old array with the new array, and free the old array */ old = table-\u0026gt;entries; table-\u0026gt;entries = new_entries; table-\u0026gt;cap = new_cap; free(old); return 0; }  One additional factored-out operation is finding the value for a key. This is used both by our searching and adding (read: updating) operations, and returns a pointer to the table entry for either updating or copying out a value to return.\nesht_entry *esht_get_entry(esht *table, char *key) { /* declare variables for ANSI C conformance */ unsigned long i; esht_entry *e; /* hash the key and perform a modulus against the table capacity to get the lookup index */ i = esht_hash(key) % table-\u0026gt;cap; /* iterate the chain until a matching key is found and return the entry */ e = table-\u0026gt;entries[i]; while (e != NULL) { if (!strcmp(key, e-\u0026gt;k)) return e; e = e-\u0026gt;n; } /* if no entry is found, return NULL */ return NULL; }  Now we can get down to the meat and potatoes: adding (updating), finding, and removing items from the table. First, we will write our insertion function. This function searches for an existing item with the same key and updates it; absent an existing item for the key, it allocates a new item and inserts it into the table. Finally, if the insertion causes the load factor to be exceeded, the table is resized.\nint esht_update(esht *table, char *key, void *value, size_t len) { /* declare variables for ANSI C conformance */ unsigned long i; esht_entry *e; void *v, *k, *old; /* find an existing entry for the key... */ e = esht_get_entry(table, key); if (e != NULL) { /* allocate memory for and copy the value */ v = malloc(len); if (v == NULL) return 1; memcpy(v, value, len); /* replace the value, update the value size, and free the old value */ old = e-\u0026gt;v; e-\u0026gt;l = len; e-\u0026gt;v = v; free(old); return 0; } /* ...or allocate memory for a new entry */ e = malloc(sizeof(esht_entry)); if (e == NULL) return 1; /* allocate for and copy the value */ v = malloc(len); if (v == NULL) { free(e); return 1; } memcpy(v, value, len); /* allocate for and copy the key */ k = malloc(strlen(key) + 1); if (k == NULL) { free(e); free(v); return 1; } strcpy(k, key); /* set the entry variables */ e-\u0026gt;k = k; e-\u0026gt;v = v; e-\u0026gt;l = len; /* hash the key and perform a modulus against the table capacity to get the lookup index */ i = esht_hash(key) % table-\u0026gt;cap; /* insert the item into the table and update the size */ e-\u0026gt;n = table-\u0026gt;entries[i]; table-\u0026gt;entries[i] = e; table-\u0026gt;len++; /* if the load factor has been exceeded, resize the backing array */ if ((float)table-\u0026gt;len / (float)table-\u0026gt;cap \u0026gt; ESHT_MAX_FACTOR) if (esht_resize(table, table-\u0026gt;cap * 2)) return 1; return 0; }  We\u0026rsquo;ve already written most of the logic for finding an item; we\u0026rsquo;ll use that to find the item, then copy the value out to the end user. For end-user friendliness, we return a pointer to the value and not an entry struct. If the caller needs to know the size of the data (i.e. it is not a NULL-terminated string or known data size), they can pass a pointer to a size_t value, in which we can place the size of the data.\nvoid *esht_get(esht *table, char *key, size_t *len) { /* declare variables for ANSI C conformance */ esht_entry *e; void *r; /* find an existing entry. If there is no entry matching the key, set the value of the length pointer to 0 and return NULL */ e = esht_get_entry(table, key); if (e == NULL) { if (len != NULL) *len = 0; return NULL; } /* allocate memory for and copy the value of the table entry */ r = malloc(e-\u0026gt;l); if (r == NULL) { if (len != NULL) *len = 0; return NULL; } memcpy(r, e-\u0026gt;v, e-\u0026gt;l); /* if a valid pointer was provided, set the length of the return data, then return a pointer to the copied value */ if (len != NULL) *len = e-\u0026gt;l; return r; }  Now, we will provide a way for end users to remove items from the table that are no longer needed. This function takes the key as an argument and returns 1 if no item was found, or 0 if the item was found and successfully removed. Then the table is resized if the load factor exceeds the minimum value.\nint esht_remove(esht *table, char *key) { /* declare variables for ANSI C conformance */ unsigned long i; esht_entry *e; /* hash and modulus the key. Note: we are not reusing the esht_get_entry function here because we need to know the previous item in the chain */ i = esht_hash(key) % table-\u0026gt;cap; e = table-\u0026gt;entries[i]; /* if the initial lookup is NULL, the item does not exist */ if (e == NULL) return 1; /* otherwise, check the first key, and if the key matches, adjust the chain */ if (!strcmp(e-\u0026gt;k, key)) { table-\u0026gt;entries[i] = e-\u0026gt;n; goto cleanup; } /* If the first key did not match, iterate the table until it is found and adjust the chain */ while (e-\u0026gt;n != NULL) { if (!strcmp(e-\u0026gt;n-\u0026gt;k, key)) { e-\u0026gt;n = e-\u0026gt;n-\u0026gt;n; goto cleanup; } } return 1; /* This jump is only taken if a valid entry is found */ cleanup: /* Free the key, value, and entry struct */ free(e-\u0026gt;k); free(e-\u0026gt;v); free(e); /* adjust the table size and resize if needed */ table-\u0026gt;len--; if ((float)table-\u0026gt;len / (float)table-\u0026gt;cap \u0026lt; ESHT_MIN_FACTOR) if (esht_resize(table, table-\u0026gt;cap / 2)) return 1; return 0; }  We now have a table to which we can add, find, and remove items. Now, we need to be able to clean the table up. The destroy function iterates the backing array and chains, frees the key and value of every entry and then the entry itself, frees the backing array, then finally frees the table struct.\nvoid esht_destroy(esht *table) { /* declare variables for ANSI C conformance */ int i; esht_entry *e, *n; /* iterate the backing array... */ for (i = 0; i \u0026lt; table-\u0026gt;cap; i++) { /* and then the chains, freeing all keys, values, and entries */ e = table-\u0026gt;entries[i]; while (e != NULL) { n = e-\u0026gt;n; free(e-\u0026gt;k); free(e-\u0026gt;v); free(e); e = n; } } /* free the backing array and then the table itself */ free(table-\u0026gt;entries); free(table); }  We now have an ANSI-C compliant, end-user-friendly hash table. The end user is responsible for managing items provided to or retrieved from the table, and is insulated from accidentally changing internal table values. The end user only needs to know about the table struct itself; the entry struct is internal-only and the find operation returns a pointer to a copy of the value with an optional length.\nWe will use this table to complete Day 7 in the next post. Until then, your comments, criticisms, and inputs are appreciated in the comments.\n","date":1569196800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569196800,"objectID":"30ced04e8e373e37357b78662dad0a9a","permalink":"/post/esht/","publishdate":"2019-09-23T00:00:00Z","relpermalink":"/post/esht/","section":"post","summary":"The code discussed here can be found on Github\nBefore we tackle Day 7, we need to talk a bit about data structures. Choosing the proper data structures for your program\u0026rsquo;s data is extremely important in making your application both performant and easily understood.\nAs we will see in Day 7\u0026rsquo;s discussion, we will need to be able to access an item by a provided string key. Storing these items in a linked list or array would work, but would be unnecessarily slow as the array would need to be iterated each time we try to find the item we are searching for.","tags":["Data Structures"],"title":"In which Nick creates a hash table","type":"post"},{"authors":null,"categories":null,"content":"Note: I am not receiving any compensation either for what I\u0026rsquo;m saying here or for the product links on this page. I think the YubiKey is a great product, and I want to share why.\nWith the upcoming release of macOS Catalina \u0026ndash; and with it, the end of the last major browser holdout from the FIDO standards, I wanted to take a moment to talk about the YubiKey and the promise of the standards that it supports for secure internet authentication.\nBefore we dive into the YubiKey itself, I\u0026rsquo;d like to explain why this is important to me. The economic impact of compromised accounts is astronomical; according to a 2018 study by the Center for Strategic and International Studies in collaboration with McAfee, the economic impact of cyber crime is nearly $600 billion per year, or 1% of total global GDP. At the same time, password security is either misunderstood or ignored by both end users and system administrators alike; according to multiple sources, the most commonly-used password in recent years is 123456. In addition, password requirements vary greatly amongst services, with many still enforcing maximum length limits and the use of special characters (or limitation of characters) despite mathematical evidence that the use of easy-to-remember long passphrases is far more secure than requiring multiple special characters in a shorter password. Simply put - passwords need to be put out to pasture.\nWith what do we replace passwords? Public key cryptography has been widely-used and battle-tested for decades \u0026ndash; every time you visit a site with the https URL scheme, you are using it! \u0026ndash; and while some implementations have been shown to have weaknesses over time, the basic concepts are solid. As long as the private key can be protected, public key cryptograhy is an effective method of authenticating an end user and encrypting communications, which is where the YubiKey comes in.\nIf you are not familiar with the YubiKey, it is a multi-protocol hardware cryptographic token. The premise behind this kind of token is that the secret key is stored on the token and the token itself performs cryptographic operations using the key without making it accessible to the host system, thus preventing the key from being siphoned off by an unscrupulous actor. The latest generation YubiKey 5 family has support for the following protocols:\n USB HID: these protocols take advantage of the capability of the YubiKey to act as a keyboard and send data as keystrokes:  Static password: The YubiKey can generate a secure password that can be combined with an easy-to-remember value to simulate a 2nd-factor auth. Yubico OTP: A custom OTP implementation that relies on a shared key known by the YubiKey and the server. Yubico provides this service for all fresh-from-factory YubiKeys; if you don\u0026rsquo;t trust Yubico with your key, you can run the service by yourself and reprogram your YubiKey with a new shared key.  OTP (One-time password): These protocols allow for time- or event-based one-time passwords:  OATH-TOTP: This is the same protocol utilized by the nearly-ubiquitous mobile authenticators out there. In the case of the YubiKey, the one-time password values are read from the key with a special Yubico Authenticator application. OATH-HOTP: This one-time password mechanism is not nearly as commonly used due to its reliance on counters and susceptibility to synchronization issues. HMAC-SHA1 Challenge/Response: This protocol relies on a shared secret. The remote party sends a challenge, and the YubiKey calculates the HMAC-SHA1 code of the challenge using the shared secret, and returns it to the remote party.  CCID (Smart cards): These protocols allow the YubiKey to emulate smart cards:  OpenPGP: The YubiKey acts as an OpenPGP smart card, with three key slots available. The YubiKey then performs all sign/encrypt/decrypt operations using the stored keys. PIV: The YubiKey acts as a PIV card and can be accessed using the standard PKCS#11 protocols. In addition to raw keys, the PIV applet can store certificates and generate CSRs, allowing for the keys to be certified and have enforced expiration and revocation capabilities.  FIDO (web authentication): These protocols allow for the usage of public key cryptography for authentication in the Web browser:  U2F, aka CTAP1: This protocol allows for 2nd-factor authentication using the private key stored on the YubiKey. It was never standardized beyond FIDO and thus there are implementation and support issues across common browsers. FIDO2, aka CTAP2: This protocol is backwards-compatible with CTAP1, and works in concert with the W3C WebAuthn standard to allow not only 2nd-factor authentication, but completely passwordless authentication. This is the future of web authentication.   In addition to the fully-featured Yubikey 5 line, Yubico offers a \u0026ldquo;Security Key\u0026rdquo; line which only support the FIDO protocols. For the majority of people out there, this is sufficient.\nWebAuthn is a recently ratified standard by the W3C specifying a JavaScript API for facilitating authentication with public key cryptography. This works together with the CTAP device protocols to enable the web browser to communicate with a CTAP-compatible USB device and use it to securely authenticate a user to a service. Per the FIDO2 website: FIDO2 cryptographic login credentials are unique across every website, never leave the user’s device and are never stored on a server. This security model eliminates the risks of phishing, all forms of password theft and replay attacks. The FIDO2 protocol also supports requiring a local second factor such as physical presence (push the button) or a PIN. In the case of a PIN, this can be a simpler value as it is never transmitted over the Internet nor stored outside of the device.\nI utilize my YubiKey 4 as much as possible. I use the PIV applet to log in locally to my computers; the OpenPGP applet to store my PGP auth, signing, and encryption keys that I use for signing git commits or remotely logging into servers. I utilize Yubico OTP as a second factor on my most sensitive servers as well as the secnod factor on my password manager. I utilize FIDO U2F wherever possible (Google, AWS, Facebook). I understand I am a power user, and that many of these use cases are quite advanced, but I simply see too much value in eschewing the world of the password and moving exclusively to public-key cryptography, now that I have the tools to do it. I only wish more things supported it, e.g. LUKS, which still requires a passphrase.\nRegardless of your level of expertise, I hope you are at least using a Security Key. If not, get one ASAP, and pressure every provider that does not yet support WebAuthn/FIDO2 to build that support as soon as possible. Hopefully we can start seeing that $600 billion number trend downward as more people adopt YubiKeys or other FIDO2-compliant devices.\n","date":1568764800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568764800,"objectID":"6fa27b35ebe67d46b83f7b7e8d98e193","permalink":"/post/yubikey/","publishdate":"2019-09-18T00:00:00Z","relpermalink":"/post/yubikey/","section":"post","summary":"Note: I am not receiving any compensation either for what I\u0026rsquo;m saying here or for the product links on this page. I think the YubiKey is a great product, and I want to share why.\nWith the upcoming release of macOS Catalina \u0026ndash; and with it, the end of the last major browser holdout from the FIDO standards, I wanted to take a moment to talk about the YubiKey and the promise of the standards that it supports for secure internet authentication.","tags":["Security","Cryptography","YubiKey"],"title":"The YubiKey; or, why are you still using a password in 2019?","type":"post"},{"authors":null,"categories":null,"content":"Welcome back to my Advent of Code series. I hope you\u0026rsquo;re enjoying exploring these problems in depth in C. Let\u0026rsquo;s take a look at the problem for day 6:\n Because your neighbors keep defeating you in the holiday house decorating contest year after year, you\u0026rsquo;ve decided to deploy one million lights in a 1000x1000 grid.\nFurthermore, because you\u0026rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.\nLights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at 0,0, 0,999, 999,999, and 999,0. The instructions include whether to turn on, turn off, or toggle various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like 0,0 through 2,2 therefore refers to 9 lights in a 3x3 square. The lights all start turned off.\nTo defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.\nFor example:\n turn on 0,0 through 999,999 would turn on (or leave on) every light. toggle 0,0 through 999,0 would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off. turn off 499,499 through 500,500 would turn off (or leave off) the middle four lights. After following the instructions, how many lights are lit?   Let\u0026rsquo;s look at our constituent problems:\n Read the input file into memory Set up a grid Parse the input lines Follow the input instructions  We already know how to read our file into memory, so we\u0026rsquo;ll move onto setting up the grid. As with Day 3, we will use a two-dimensional array to represent the grid. Unlike day 3, we know in advance what the size of the grid is, so we don\u0026rsquo;t need to do an extra loop to size it; we can just declare bool grid[1000][1000], initialize, and move on.\nLikewise, parsing the input lines is also a situation we have previously encountered. In previous days, we have used scanners and regular expressions. While using scanners is ideal for simple situations, we have to remember the downsides: scanners are tokenized by any whitespace, and scanners cannot safely be used to scan into strings. Both of these cases are disqualifiers for our input; we have a component of the input that might have a space in it, and we also need to scan into a string. For this reason, we\u0026rsquo;ll use regular expressions to parse our input. Because we can only parse into strings with regular expressions, we will also need to convert our number strings to numerical values.\nOnce we have our values, we can use them to set up a nested loop to update the values on the grid.\nLet\u0026rsquo;s look at some code:\nint main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 6:\\n\u0026quot;);  This is our now familiar check for argument, read input, and print preamble, included only for completeness at this point.\nregex_t inst_r; int result = regcomp(\u0026amp;inst_r, \u0026quot;\\\\(turn on\\\\|turn off\\\\|toggle\\\\) \\\\([[:digit:]]\\\\{1,\\\\}\\\\),\\\\([[:digit:]]\\\\{1,\\\\}\\\\) through \\\\([[:digit:]]\\\\{1,\\\\}\\\\),\\\\([[:digit:]]\\\\{1,\\\\}\\\\)\u0026quot;, 0); if (result != 0) goto err_cleanup;  Next, we compile the regular expression to match against. Without the escape characters, this expression looks like: (turn on|turn off|toggle) ([[:digit:]]{1,}),([[:digit:]]{1,}) through ([[:digit:]]{1,}),([[:digit:]]{1,}). Reading this expression aloud, we get Capture a group containing \u0026ldquo;turn on\u0026rdquo;, \u0026ldquo;turn off\u0026rdquo;, or \u0026ldquo;toggle\u0026rdquo;. Find a space. Capture a group of one or more digits, then find a comma, then capture a group of one or more digits. Find the phrase \u0026ldquo; through \u0026ldquo;. Capture a group of one or more digits, then find a comma, then capture a group of one or more digits. At the end of it, we have captured five submatches; one for the command, and then one each for the low and high X and Y coordinates.\nchar *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[6] = {0}; bool grid[1000][1000]; memset(grid, 0, 1000 * 1000 * sizeof(bool));  We now prepare to start our loop. We create the cursor variable and get the first line, declare an array to hold the regular expression match coordinates and initialize it, and declare and initialize the grid array. Note that we use memset for the grid array because the {0} initialization shorthand cannot be used with multidimensional arrays. Also note that we declared a six member array for the regular expression matches; the first match is always the full matched string, so we need room for this plus the five submatches that we actually care about.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize; memset(matches, 0, 6 * sizeof(regmatch_t)); result = regexec(\u0026amp;inst_r, line, 6, matches, 0); if (result != 0) goto err_cleanup; char instr[9] = {0}; char oxs[4] = {0}; char oys[4] = {0}; char dxs[4] = {0}; char dys[4] = {0}; strncpy(instr, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); strncpy(oxs, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); strncpy(oys, line + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so); strncpy(dxs, line + matches[4].rm_so, matches[4].rm_eo - matches[4].rm_so); strncpy(dys, line + matches[5].rm_so, matches[5].rm_eo - matches[5].rm_so); unsigned long ox = strtoul(oxs, NULL, 10); if (ox == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long oy = strtoul(oys, NULL, 10); if (oy == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long dx = strtoul(dxs, NULL, 10); if (dx == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long dy = strtoul(dys, NULL, 10); if (dy == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; if (strcmp(\u0026quot;turn on\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = true; } else if (strcmp(\u0026quot;turn off\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = false; } else if (strcmp(\u0026quot;toggle\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = !grid[x][y]; } else { goto err_cleanup; } tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now, we perform our loop on each of the input lines, parsing and following the directions. We\u0026rsquo;ll zero out the match array, then execute the compiled regular expression against the input line. We then initialize destination variables for each of the five submatch values, and use the match coordinates to copy the matched substrings into the destination variables.\nOnce the destination variables are populated, we\u0026rsquo;ll use strtoul to parse the four numerical values into integral equivalents, giving us the final set of parsed values to handle our input.\nAt this point, we use strcmp to compare the instruction string against the known instructions, and then set up a nested loop using the X and Y values. Finally, the interior of the loop sets the value of that coordinate per the instruction. You\u0026rsquo;ll notice that we parsed the instruction first, requiring the loop to be specified multiple times, seemingly breaking the don\u0026rsquo;t-repeat-yourself rule. In this case, however, this is justified, as if we reversed things, the string comparison would need to be done for each position, which would be prohibitvely computationally expensive. Once the loop is complete, the values of the grid are set.\nint on = 0; for (int x = 0; x \u0026lt; 1000; x++) for (int y = 0; y \u0026lt; 1000; y++) if (grid[x][y]) on++; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, on);  In order to get our solution, we set up a counter variable and then another nested loop over the entire two-dimensional surface. Each time we encounter a true value, we increment the counter. We then print our solution.\nAfter submitting the solution, the second problem is presented:\n You just finish implementing your winning light pattern when you realize you mistranslated Santa\u0026rsquo;s message from Ancient Nordic Elvish.\nThe light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.\nThe phrase turn on actually means that you should increase the brightness of those lights by 1.\nThe phrase turn off actually means that you should decrease the brightness of those lights by 1, to a minimum of zero.\nThe phrase toggle actually means that you should increase the brightness of those lights by 2.\nWhat is the total brightness of all lights combined after following Santa\u0026rsquo;s instructions?\nFor example:\n turn on 0,0 through 0,0 would increase the total brightness by 1. toggle 0,0 through 999,999 would increase the total brightness by 2000000.   As with previous problems, this one is simalar, and we can implement it in the existing loop to avoid the need to loop the input a second time.\nchar *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[6] = {0}; bool grid[1000][1000]; int grid2[1000][1000]; memset(grid, 0, 1000 * 1000 * sizeof(bool)); memset(grid2, 0, 1000 * 1000 * sizeof(int));  We will declare a second grid variable, this time of type int[][], since we need to track more than just on or off.\nif (strcmp(\u0026quot;turn on\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = true; grid2[x][y]++; } } else if (strcmp(\u0026quot;turn off\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = false; grid2[x][y] = grid2[x][y] \u0026gt; 0 ? grid2[x][y] - 1 : 0; } } else if (strcmp(\u0026quot;toggle\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = !grid[x][y]; grid2[x][y] += 2; } } else { goto err_cleanup; }  The instructions are equivalent for both loops; we just need to add the application of the instructions to the second grid following the second transation\u0026rsquo;s directions.\nint on = 0; int bright = 0; for (int x = 0; x \u0026lt; 1000; x++) for (int y = 0; y \u0026lt; 1000; y++) { if (grid[x][y]) on++; bright += grid2[x][y]; } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, on); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, bright);  We\u0026rsquo;ll add a second counter variable and perform the addition during the same nested loop as the first solution, and then print both solutions.\ngoto cleanup; err_cleanup: rc = -1; cleanup: regfree(\u0026amp;inst_r); free(input); return rc; }  Finally, we will clean up. As before, we need to call regfree to free the compiled regular expression in addition to freeing the input.\nOur problems are gradually getting more difficult, but we\u0026rsquo;re almost a week through! Day seven\u0026rsquo;s solution requires implementing a new data structure, so our next article will take a break to discuss this in detail.\nAs always, comments, criticism, and banter are welcome, just leave a comment!\n","date":1568678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568678400,"objectID":"37e458296bd91b5c587f0603e8678566","permalink":"/post/advent-2015-c-6/","publishdate":"2019-09-17T00:00:00Z","relpermalink":"/post/advent-2015-c-6/","section":"post","summary":"Welcome back to my Advent of Code series. I hope you\u0026rsquo;re enjoying exploring these problems in depth in C. Let\u0026rsquo;s take a look at the problem for day 6:\n Because your neighbors keep defeating you in the holiday house decorating contest year after year, you\u0026rsquo;ve decided to deploy one million lights in a 1000x1000 grid.\nFurthermore, because you\u0026rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.","tags":["Programming","Advent of Code","C","Regular Expressions"],"title":"Advent of Code 2015 Day 6: Probably a Fire Hazard","type":"post"},{"authors":null,"categories":null,"content":"Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we are going to look at day 5:\n Santa needs help figuring out which strings in his text file are naughty or nice.\nA nice string is one with all of the following properties:\n It contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou. It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd). It does not contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.  For example:\n ugknbfddgicrmopn is nice because it has at least three vowels (u...i...o...), a double letter (...dd...), and none of the disallowed substrings. aaa is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap. jchzalrnumimnmhp is naughty because it has no double letter. haegwjzuvuyypxyu is naughty because it contains the string xy. dvszwmarrgswjxmb is naughty because it contains only one vowel.  How many strings are nice?\n Let\u0026rsquo;s begin by breaking down the problem. We need to:\n Read the input file into memory Split the input into its components Determine whether the string meets the naughty or nice requirements  The first two parts of this problem are familiar, and generally speaking, identical. We\u0026rsquo;ll use the variable good to track the good strings.\nint main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 5:\\n\u0026quot;);  The last part, however, is the most difficult problem that has yet been presented. How are we going to check the strings?\nWhile it might be tempting to loop over the strings and implement tracking variables to check these conditions (and, depending on the implementation, might be faster), the more appropriate tool in this situation is regular expressions.\nregex_t rule1, rule2, rule3; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup;  Each of the three rules can be checked using a valid POSIX basic regular expression (note that in the code snippet above, the appropriate escape characters have been added):\n at least 3 vowels: [aeiou].*[aeiou].*[aeiou]  This regular expression says: find a letter a, e, i, o, or u. Then find zero or more of any character, then a letter a,e,i,o,u, then zero or more of any character, then a, e, i, o, or u.  at least one letter that occurs twice in a row: (.)\\1  This regular expression uses a backreference to refer to a prior character. It says: find a group containing any one character, then find the first group. In this case, the first group is the matched one character.  does not contain ab, cd, pq, xy: (ab|cd|pq|xy)  We\u0026rsquo;ll actually be looking for a negative result on this one because it is simpler than trying to do the negation in the expression itself. This expression says, find the strings ab or cd or pq or xy.   We compile the expressions once to be used to quickly match the strings as we loop through the input:\nint good = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); goto cleanup;  If rule 3 does not match (we put this one in front to short-circuit, since if it matches the string is automatically invalid) and rules 1 and 2 match, then the string is a good string. Note that this appears backwards due to regexec returning 0 on match and 1 on no match. We output the counted good strings for our solution.\nThen, we just need to clean up:\nerr_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); free(input); return rc; }  With our solution submitted, we then get our second problem:\n Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.\nNow, a nice string is one with all of the following properties:\n It contains a pair of any two letters that appears at least twice in the string without overlapping, like xyxy (xy) or aabcdefgaa (aa), but not like aaa (aa, but it overlaps). It contains at least one letter which repeats with exactly one letter between them, like xyx, abcdefeghi (efe), or even aaa.  For example:\n qjhvhtzxzqqjkmpb is nice because is has a pair that appears twice (qj) and a letter that repeats with exactly one letter between them (zxz). xxyxx is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap. uurcxstgmygtbstg is naughty because it has a pair (tg) but no repeat with a single letter between them. ieodomkazucvgmuy is naughty because it has a repeating letter with one between (odo), but no pair that appears twice.  How many strings are nice under these new rules?\n As expected, the problem is very similar, if slightly more complicated. The good news is that these rules can also be checked with valid POSIX basic regular expressions, so we can easily add the new rules to the existing loop.\nregex_t rule1, rule2, rule3, rule4, rule5; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule4, \u0026quot;\\\\(..\\\\).*\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule5, \u0026quot;\\\\(.\\\\).\\\\1\u0026quot;, 0)) goto err_cleanup;  The two new rules are:\n A pair of two letters that appear at least twice in the string without overlapping: (..).*\\1  This regular expression says: find a group with two of any character, then find zero or more of any character, then find the first group.  one letter which repeats with exactly one letter between: (.).\\1  This regular expression says: find a group with one of any character, then find one of any character, then find the first group.   These are again compiled.\nint good = 0; int great = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; if (!regexec(\u0026amp;rule4, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule5, line, 0, NULL, 0)) great++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, great);  We add a second check for the two new rules, with a separate counter, then print the second result after the first.\nerr_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); regfree(\u0026amp;rule4); regfree(\u0026amp;rule5); free(input); return rc; }  Finally, we clean up the new compiled regexes in addition to the previous ones.\nAll together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;regex.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 5:\\n\u0026quot;); regex_t rule1, rule2, rule3, rule4, rule5; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule4, \u0026quot;\\\\(..\\\\).*\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule5, \u0026quot;\\\\(.\\\\).\\\\1\u0026quot;, 0)) goto err_cleanup; int good = 0; int great = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; if (!regexec(\u0026amp;rule4, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule5, line, 0, NULL, 0)) great++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, great); goto cleanup; err_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); regfree(\u0026amp;rule4); regfree(\u0026amp;rule5); free(input); return rc; }  This is just one instance where a problem that is potentially complex can be simplified with regular expressions (note: this goes both ways!)\nAs always, if you have questions, comments, or suggestions, feel free to leave a comment!\n","date":1568419200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568419200,"objectID":"aa3aa3dc71b4048b68fda92b736de5d1","permalink":"/post/advent-2015-c-5/","publishdate":"2019-09-14T00:00:00Z","relpermalink":"/post/advent-2015-c-5/","section":"post","summary":"Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we are going to look at day 5:\n Santa needs help figuring out which strings in his text file are naughty or nice.\nA nice string is one with all of the following properties:\n It contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou. It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).","tags":["Programming","Advent of Code","C","Regular Expressions"],"title":"Advent of Code 2015 Day 5: Doesn't He Have Intern-Elves For This?","type":"post"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: 1, 2, 3, \u0026hellip;) that produces such a hash.\nFor example:\n If your secret key is abcdef, the answer is 609043, because the MD5 hash of abcdef609043 starts with five zeroes (000001dbbfa...), and it is the lowest such number to do so. If your secret key is pqrstuv, the lowest number it combines with to make an MD5 hash starting with five zeroes is 1048970; that is, the MD5 hash of pqrstuv1048970 looks like 000006136ef....   As always, we\u0026rsquo;ll start with breaking down the problem into discrete parts:\n Read the input Convert a number to a string Combine the input and the number string Get the MD5 digest of the combined string Check that the first five digits of the digest are 0  Rather than write our own MD5 hashing implementation, we will use the well-known and commonly-installed OpenSSL library\u0026rsquo;s implementation. You\u0026rsquo;ll need to make sure that your linker pulls in the OpenSSL library.\nLet\u0026rsquo;s write some code:\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  For the sake of completion, this is our standard prelude of verifying the command-line argument and reading the input file.\nprintf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16];  We print our preamble, then initialize some variables. Note that I\u0026rsquo;m doing this outside of a loop so that we do not incur this cost in the loop. Our code will be written in such a way that the variables do not need to be reinitialized on every pass. Step by step we have:\n The declaration of the iteration index i, which is the number that will be added to the input string on each pass The declaration of the buffer which stores the whole string to be hashed. We size from the input and then add 11 \u0026ndash; 10 for the maximum number of digits in a 32-bit integer, and 1 for the null terminator. The initialization of the string buffer. Ensuring all bytes are set to 0 now will help us not need to re-initialize the variable on every loop Copying the input into the buffer Creating a buffer for the MD5 digest. MD5 digests are 128 bits, so we need a 16-byte buffer. Note that we do not have a null terminator here because this is not a string.\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest);   Now we begin the loop. W se formatted print to append the string representation of i to the buffer. Notice that we are using pointer arithmetic to point to the first index in the buffer after the original input string. Because the numbers will only ever increase, we will overwrite this on each loop and not need to reinitialize the variable. We then get the MD5 digest of the constructed string.\nAt this point, one might be tempted to use formatted print to output the hexadecimal representation of the digest. Don\u0026rsquo;t! String formatting operations are computationally expensive, and we have the information we need to solve the problem without doing it.\nif (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; }  Note that the ratio of bytes to hex characters is 1:2; that is, each byte of the digest would translate to two hex characters. With this in mind, remember that this digest is just one big number; so, rather than convert the number back to a string, let\u0026rsquo;s just check the number.\nWe are searching for a digest where the first five digits of the hexadecimal representation of the digest are 0. For bytes 0 and 1, this is easy: the value of the byte must be 0. For byte 2, it requires a little bit more thought, since only the first digit must be zero. In this case, it\u0026rsquo;s just a matter of places like in decimal math. There are 16 possible hexadecimal digits, so any value of the byte that is less than 16 will have the first hex digit as 0.\nBy checking this way and avoiding the string conversion, we cut our compute usage down by 10-100x, which is important in this exercise as hashing is not a fast operation, relatively speaking.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i);  We now have our solution, which is the current value of i. Once this is validated, our second puzzle appears:\n Now find one that starts with six zeroes.\n Well, that\u0026rsquo;s succinct, isn\u0026rsquo;t it? Literally all we need to do at this point is resume the loop right where we left off, making one change: we can check that byte 2 of the digest is equal to zero, rather than less than 16:\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; }  We don\u0026rsquo;t even need to reset i here, since by definition a digest can\u0026rsquo;t start with six zeroes without starting with five. In the circumstance that the first digest that begins with five zeroes also begins with six zeroes, the first iteration of our loop will catch it because we broke out of the previous loop before incrementing the index, and we don\u0026rsquo;t increment until the end of the loop.\nWe now have our solution, and can print it and clean up:\nprintf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0; }  When we put it all together, we have:\n\u0026rdquo;\u0026lsquo;c #include  #include  #include  #include  #include  #include \u0026ldquo;common.h\u0026rdquo;\nint main(int argc, char const argv[]) { / check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026ldquo;Must provide filename of input file\\n\u0026rdquo;); return -1; }\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16]; /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i); /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; } printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0;  } ```\n","date":1568084400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568084400,"objectID":"409f0a75a351b9fbce6cf49d57337bb1","permalink":"/post/advent-2015-c-4/","publishdate":"2019-09-10T03:00:00Z","relpermalink":"/post/advent-2015-c-4/","section":"post","summary":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal.","tags":["Programming","Advent of Code","C","Cryptography","Hashing"],"title":"Advent of Code 2015 Day 4: The Ideal Stocking Stuffer","type":"post"},{"authors":null,"categories":null,"content":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;). After each move, he delivers another present to the house at his new location.\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\nFor example:\n \u0026gt; delivers presents to 2 houses: one at the starting location, and one to the east. ^\u0026gt;v\u0026lt; delivers presents to 4 houses in a square, including twice to the house at his starting/ending location. ^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.   This problem seems pretty simple on the face of it, but let\u0026rsquo;s break it down. We will need to:\n Read the input from the file Iterate over the input Track which locations have been visited Count the visited locations  In order to track the location, we\u0026rsquo;ll need to use a slightly more advanced data structure. Since we are working with quantities in 2D space, a 2D array makes sense. Thankfully, in newer versions of the C standard, the array sizes do not need to be known at compile time, so we can avoid some messy pointer arithmetic.\nLet\u0026rsquo;s get to work.\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  If this looks familiar, you\u0026rsquo;re catching on. We check that the filename is provided, read the input file to memory, and handle any errors.\nNow we\u0026rsquo;re ready to get started\u0026hellip; but are we? We still have no idea how big our grid array needs to be. We could guess, but we run the danger of either making the arrays too small and going out-of-bounds, or making them too big and unnecessarily tying up memory. The better plan would be to iterate over the input and test the constraints.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1;  After printing our preamble, we\u0026rsquo;ll create tracking variables for the current x and y positions, and the minimum and maximums of both. We\u0026rsquo;ll initialize all of them to zero, and then iterate over the input, adjusting the current value of x and y and keeping the maximums and minimums updated as needed. Once the loop is complete, we have enough information to compute the sizes of the arrays. Note that we need to add 1 to the total; e.g. 1 - (-1) = 2, but that covers the values -1, 0, 1.\n/* create the grid and travel again */ bool grid[w][h]; memset(grid, 0, w * h * sizeof(bool)); x = 0 - min_x; y = 0 - min_y;  Now that we know the sizes, we can declare the two-dimensional array. Again, older versions of the C standard do not allow runtime determination of the array sizes for stack declarations; if you are stuck using an old version, you will need to allocate the array on the heap with malloc or the like. Since we only need to track if a house has been visited or not, we\u0026rsquo;ll use the bool data type for our grid. The more astute reader might know that bool is still represented with a full byte in C, but we can still use the type as a hint to those who might read your code as to the function.\nOnce we\u0026rsquo;ve declared the array, we will need to initialize it; while we can declare the array in this fashion now, we still cannot initialize it at declaration. We\u0026rsquo;ll use the memset function to zero out the allocated arrays. This is safe with our bool data type as false is represented as 0.\nFinally, we\u0026rsquo;ll set our initial indices for x and y for the upcoming run. Since we cannot have negative indices in an array, we\u0026rsquo;ll need to offset them using the minimum values previously found.\ngrid[x][y] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } grid[x][y] = true; }  We\u0026rsquo;re finally ready to gather our data. We\u0026rsquo;ll iterate through the input again, flipping the value on the grid to true as we visit each space. Notice that we set the origin space to true as well per the problem parameters (He begins by delivering a present to the house at his starting location...).\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses);  Once we\u0026rsquo;ve completed the loop, we can count the houses by iterating through the grid and incrementing a counter for each set of coordinates that is true. The ternary operator is used as a shortcut here.\nOnce we submit our solution, the second problem appears:\n The next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\nThis year, how many houses receive at least one present?\nFor example:\n ^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south. ^\u0026gt;v\u0026lt; now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started. ^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.   As we read, the difference here is that we have a second \u0026ldquo;Santa\u0026rdquo;, and they alternate directions in the input, rather than one taking all the directions. This means we will need to implement a toggle, as well as keep two sets of coordinates on the same grid. As with previous answers, I chose to integrate this solution into the original problem rather than writing a completely new set of code to solve problem 2.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1;  In addition to the single x and y value for the first problem, I declare a two-element array to represent the coordinates of both santas for the second problem. I alse declare and initialize another set of min/max variables. Finally, a variable is declared to act as a toggle between 0 and 1.\nNow to find our coordinates, we run through the loop. We increment the x and y of the appropriate Santa, and check that against the x and y minimums and maximums for the second grid (remember, both Santas share the grid, so there is only one set of mins and maxes). We\u0026rsquo;ll update the values for the second grid based on the active Santa, and then once all values have been updated, we use the bitwise XOR assignment operator to flip the toggle value. Once the loop is complete, we calculate the width and height of the second grid.\n/* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2;  The grid creation for the second problem is identical to the first problem. The only difference comes in assigning the initial coordinates; this needs to be done for both Santas for the second problem.\ns = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; }  During the second iteration of the input, we\u0026rsquo;ll toggle the Santa as we did during the range finding iteration.\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses);  We\u0026rsquo;ll count the number of visited houses for the second grid, exactly as we did the first grid.\nFinally, we\u0026rsquo;ll free our allocated input array for completeness and return success:\nfree(input); return rval; }  All together now:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1; /* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2; s = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; } /* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses); free(input); return rval; }  ","date":1568073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568073600,"objectID":"756b26d309c5f79aaf0044e7d5d609e4","permalink":"/post/advent-2015-c-3/","publishdate":"2019-09-10T00:00:00Z","relpermalink":"/post/advent-2015-c-3/","section":"post","summary":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;).","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum","type":"post"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\nFor example:\n A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet. A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.  All numbers in the elves\u0026rsquo; list are in feet. How many total square feet of wrapping paper should they order?\n As with day 1, we\u0026rsquo;re going to take a minute to break the problem down. As the problem states, the input is formatted as XXxYYxZZ, so we will need to parse the input into usable numbers. Since we need to operate on the smallest dimensions for the slack, we\u0026rsquo;ll need to be able to sort the inputted values. Finally, we\u0026rsquo;ll need to do the math and keep a running total.\nLet\u0026rsquo;s dig in:\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  The preamble to our function is identical to day 1, with the exception of initializing our return value early as we\u0026rsquo;ll be using our goto short circuit pattern to handle some later potential errors. We check that the user provided a filename and read the file into the input buffer.\nprintf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0;  We\u0026rsquo;ll then print our daily header and initialize the running total for the wrapping paper.\n/* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;);  Now we start getting into some more interesting string handling. Note that the input has one present per line, so we need to effectively split the string on the lines. We will use the POSIX strsep function for this. There is a similar strtok function in the C standard librory, but it has the downside of being non-reentrant. If portability is a concern, you may want to stick use strtok, however strsep is widely supported and should be used instead of strtok wherever possible.\nIn order to avoid changing the original value of the pointer to the input, we make a copy into cursor which becomes the moving pointer passed as the first argument of strsep. Finally, we are splitting on the newline character \\n. We will not bother to make a copy of the input buffer as we only need to parse it once.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize;  One side effect of strsep that one needs to be aware of is that if multiple delimiters are encountered in a row, strsep will return a pointer to an empty string instead of consuming all of the delimiters at once. We check for the empty string and short-circuit the loop if we encounter this.\n/* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; }  We now initialize an array of three ints to hold the parsed values. We use an array instead of separate variables because we will need to sort the result. Once the array is initialized, we use the sscanf function to scan the dimensions into the array. As we are not trying to scan into string variables, sscanf is perfectly safe for our usage. As an error check, we will short-circuit to the function cleanup if we have an invalid line which scans less than three values.\nqsort(dims, 3, sizeof(int), cmp_int_asc);  Once the values are scanned, they need to be sorted so that we can find the slack using the smallest side. For this we use the standard library function qsort with a simple comparator function:\nint cmp_int_asc(const void *a, const void *b) { int l = *(const int *)a; int r = *(const int *)b; return l \u0026lt; r ? -1 : l \u0026gt; r ? 1 : 0; }  The comparator dereferences and casts the inputs and then returns -1 if a \u0026lt; b, 1 if a \u0026gt; b, or 0 if they are equal. I use the ternary operator here for conciseness, but I would refrain from using it for anything more complex.\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now that we have our values and we have them sorted by smallest to largest, we just need to do the math and update our running total. As noted in the problem, for each present we need to add the area of each side plus the area of the smallest side as slack: 2xy + 2yz + 2xz + xy.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  Once we have broken out of the input parsing loop, paper should have the total required wrapping paper. We can print the solution and then proceed with cleanup. As noted in day 1, freeing input is not strictly necessary in this case but is good from a habit-forming perspective.\nOnce the solution has been input, the second problem is presented:\n The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don\u0026rsquo;t ask how they tie the bow, though; they\u0026rsquo;ll never tell.\nFor example:\n A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet. A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.  How many total feet of ribbon should they order?\n As with day 1, we already have all of the infrastructure present to handle this new problem. We\u0026rsquo;ll add a new variable to track the running total of ribbon:\nint paper = 0; int ribbon = 0;  Then update the total ribbon on each loop, following the instructions to add 2x+2y+xyz to the total:\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];  Finally, we\u0026rsquo;ll print the second solution:\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon);  When it\u0026rsquo;s all put together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0; int ribbon = 0; /* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; /* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; } qsort(dims, 3, sizeof(int), cmp_int_asc); paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  As before, this program will pass all Valgrind checks and does not leak memory.\nSuggestions, questions, and criticism welcome! Comments can be added below.\n","date":1567994400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567994400,"objectID":"f5e5b339b407c157e6918a4e63e14f57","permalink":"/post/advent-2015-c-2/","publishdate":"2019-09-09T02:00:00Z","relpermalink":"/post/advent-2015-c-2/","section":"post","summary":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.","tags":["Programming","Advent of Code","C","String parsing"],"title":"Advent of Code 2015 Day 2: I Was Told There Would Be No Math","type":"post"},{"authors":null,"categories":null,"content":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere\u0026rsquo;s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can\u0026rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n (()) and ()() both result in floor 0. ((( and (()(()( both result in floor 3. ))((((( also results in floor 3. ()) and ))( both result in floor -1 (the first basement level). ))) and )())()) both result in floor -3.  To what floor do the instructions take Santa?\n Before we start writing code, let\u0026rsquo;s think about what needs to happen. We will need to input a file, read through it, determine which characters are important (( and )) and adjust the floor number accordingly. Then we\u0026rsquo;ll need to output our solution somehow.\nGenerally speaking, each day\u0026rsquo;s puzzle will be its own executable and the input filename will be a command-line argument.\nNow that we have a plan of attack, let\u0026rsquo;s dig in.\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; }  First things first, let\u0026rsquo;s check and make sure the user actually provided a filename. Don\u0026rsquo;t forget that argv[0] is always the name of the invoked command, so argc must be at least 2 if the user has provided any arguments at all. If the argument is not present, we\u0026rsquo;ll print a useful error message to stderr and return from main with a non-zero code.\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;);  Remember that input file function we wrote yesterday? Now we get to use it. We declare a pointer to the buffer and pass it into the function, along with the filename which should be in argv[1]. If the file doesn\u0026rsquo;t exist, isn\u0026rsquo;t readable, or any other problem that we handled in the function, it will return -1 and errno will be set. In that case, we print the error message to stderr and return non-zero. If everything worked, the contents of the file are now in the location in memory pointed to by our input pointer. Once we\u0026rsquo;ve successfully read the file, we\u0026rsquo;ll print our header line for the output.\nNow it\u0026rsquo;s time to solve the problem. The most straightforward way is going to be to iterate over the contents of the file in memory byte-by-byte and adjust the floor accordingly.\n/* solve the first puzzle */ int floor = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor);  We initialize our floor variable to zero as noted in the problem description (He starts on the ground floor (floor 0)...), and then construct a for loop with the index starting at 0 (remember, C arrays are zero-indexed) and incrementing by one until we reach the file size which was returned by our file input function. During each iteration of the loop, we check the byte at that index and either increment or decrement the floor number depending on the character. In this case, I have chosen to ignore any spurious characters that may be in the input.\nThe object of the problem is to determine which floor we arrive at (To what floor do the instructions take Santa?), so the value of the floor variable is our solution.\nOnce we input our solution, a second problem appears!\n Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n ) causes him to enter the basement at character position 1. ()()) causes him to enter the basement at character position 5.  What is the position of the character that causes Santa to first enter the basement?\n In the interest of saving compute time and code, we will attempt to integrate the finding of the second solution into the original code. In this case, it\u0026rsquo;s a matter of finding the index where we first hit floor -1. We can do this by setting a variable to a known bad value, and checking whether it has been reset to a known good value and if not, setting it. So, we\u0026rsquo;ll update our problem logic as such:\n/* solve the puzzles */ int floor = 0; int basement = -1; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == -1) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement);  In this updated logic, we set basement to a sentinel value of -1; since we are counting up, the value cannot possibly be negative. Then, in each iteration of the loop, we check for the floor to be -1 (since we can only move one floor at a time) and for the basement value to be the sentinel. For those of you counting instructions, notice that the floor check will short-circuit; i.e. the basement check will not happen unless the floor is -1. The net effect is that on average we are only adding one instruction per loop. Also notice that we set the value of basement to i + 1 as the positions are one-indexed per the problem parameters (The first character in the instructions has position 1...).\nfree(input); return 0; }  Now that we have solved the problem, we\u0026rsquo;ll clean up and return 0. Note that it is not strictly necessary to free input, but it is a good habit to be in.\nHere\u0026rsquo;s the whole program for day 1:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;); /* solve the puzzles */ int floor = 0; int basement = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == 0) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement); free(input); return 0; }  This program makes proper error checks and manages memory properly, and will pass all Valgrind checks in a variety of test scenarios.\nIf I\u0026rsquo;ve done something horribly wrong or you have questions, please comment!\n","date":1567987200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567987200,"objectID":"b231645316f12b2922f38f7ba06232ed","permalink":"/post/advent-2015-c-1/","publishdate":"2019-09-09T00:00:00Z","relpermalink":"/post/advent-2015-c-1/","section":"post","summary":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 1: Not Quite Lisp","type":"post"},{"authors":null,"categories":null,"content":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management. In order to up the challenge, the solutions will be written in C, and the code will pass all Valgrind tests for memory leaks and other issues. All code discussed in these posts will be in my Advent of Code solutions repository.\nTo kick things off, we\u0026rsquo;ll take a look at code reuse. When you\u0026rsquo;re quickly prototyping or problem solving, you\u0026rsquo;re frequently going to have identical snippets of code in multiple places. If we\u0026rsquo;re writing high-quality code, we want to avoid this wherever possible. One common theme throughout the Advent of Code problems will be reading an input file into memory. In order to avoid writing the same code over and over, we\u0026rsquo;re going to start things off by writing a function to read a file into a memory buffer:\nint read_file_to_buffer(char **buf, char *filename);  Already, just in the function signature, we are making design decisions. We could have written the function to return the pointer to the memory buffer, and in most languages this makes the most sense. However, in C, the length of an array is not an integral part of the data type, so we need to pass that information back as well. Therefore, I made the decision to pass a pointer to pointer to char (array) to the function, which will be modified in the function with the actual pointer to the allocated buffer, and to return the size of the buffer in the return value (or -1 if there is an error). We use this pattern rather than passing in the buffer itself because we do not know ahead of time how the buffer needs to be sized. The caller will be responsible for freeing the buffer when they are done using it.\nNow, lets think about what actually needs to happen to read a file into memory, and what can go wrong.\n Does the file exist? Is it a valid, readable file? How big is the file; consequently, how big does my buffer need to be? What happens if we don\u0026rsquo;t succeed in reading the actual data?  As you can see, when reading a file, there are a lot of potential failure points. Keeping that in mind, let\u0026rsquo;s start writing our code.\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */  The first thing we do is initialize variables that will exist for the life of the function (and be part of the cleanup). rval will hold our return value, f will hold our file pointer, and *buf is the pointer to the buffer that will hold the file contents, which is passed in as a parameter. Each is initialized to a sane default, as variables are not automatically initialized in C.\nWith that out of the way, we\u0026rsquo;ll make our first check. Using the POSIX stat function, we query the file for information. Right off the bat, this will tell us if the file exists; if it does not, stat will return -1 and set errno accordingly. If we see this, we will jump to our error cleanup.\nAt this point, I\u0026rsquo;m going to take a sidebar and talk a bit about goto. For most programmers, there\u0026rsquo;s a knee-jerk reaction to avoid goto at all costs. Generally, I agree with this with one exception: error cleanup. In this case, goto properly used provides an avenue to short-circuit function execution and provide for cleanup in the case of an error without reusing the same code.\nIf the file exists, the struct stat will be populated with information about the file, including the type and size. Continuing on:\n/* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; }  Our next check is that we are working with a regular file, as opposed to a directory, block device, or other file type. (note: stat follows symlinks!). We use the S_ISREG macro to accomplish this. Because this is a check and not necessarily an error condition, if the provided file is not a regular file we will set errno ourselves to indicate an invalid parameter and then jump to our error cleanup.\n/* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */  Now that we know the file exists, and that it\u0026rsquo;s a regular file, we will try to open it for reading. If the file is not readable for any reason, fopen will return NULL and set errno appropriately. We will check for the NULL return value and short-circuit as needed.\n/* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */  Now that we\u0026rsquo;ve successfully opened the file, we\u0026rsquo;ll allocate the buffer. Even though we already had the size information from the stat call, I\u0026rsquo;ve chosen not to allocate the buffer until we know the file is readable, to avoid unnecessary allocations. For this problem it doesn\u0026rsquo;t really matter, but it\u0026rsquo;s a good habit to be in. If there is an error allocating the buffer such as running out of memory, malloc will return NULL and set errno; again we will check for this and short-circuit the function as necessary. I\u0026rsquo;m using malloc instead of calloc because we have designed the function such that the buffer will be completely filled by the file, negating the need to initialize it. The extra +1 is to make room for a null terminator so that we may treat the buffer as a string.\n/* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup;  Now we perform the actual read. fread is a buffered read which calls the low-level read syscall, and as such it will block until the requested size is read unless there is an error, allowing us to avoid need to loop until the expected data is read. Instead, we will check to make sure the expected size of data is read (the file size) and check for an error if it is not. If there is an error reading the file, we\u0026rsquo;ll short-circuit to our error cleanup.\n/* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup;  We finish up the logic of our function by setting the extra allocated byte at the end of the buffer to a null terminator, then set the return value to the amount of data read, and finally jumping to our non-error cleanup. Array indeces have a higher precedence than the indirection operator, so we need to enclose the indirection in parentheses to avoid writing to the wrong memory address.\nerr_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval;  Now for our cleanup. There are two things that need to be cleaned up in this function: first, the file needs to be closed if it was opened, to avoid file handle leaks. Also, if there was an error, the data buffer needs to be freed if it was allocated and the pointer set to NULL. Finally, if we did error, we set rval to -1 which indicates the error to the caller, who can then get more information by inspecting errno.\nThe whole function:\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */ /* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; } /* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */ /* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */ /* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup; /* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup; err_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval; }  We\u0026rsquo;ve now written a function with appropriate error checking that can be reused throughout our Advent of Code exercises!\n","date":1567980000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567980000,"objectID":"4a19ca9dcbe5acd4634b1a929187717f","permalink":"/post/advent-setup-c/","publishdate":"2019-09-08T22:00:00Z","relpermalink":"/post/advent-setup-c/","section":"post","summary":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management.","tags":["Programming","Advent of Code","C","Best practices","DRY"],"title":"Advent of Code deep dive kickoff","type":"post"},{"authors":null,"categories":null,"content":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.\n","date":1567468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567468800,"objectID":"7b1a7e9fadbc0ac76e4a203dc7dda3a9","permalink":"/post/e3b0c442-returns/","publishdate":"2019-09-03T00:00:00Z","relpermalink":"/post/e3b0c442-returns/","section":"post","summary":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.","tags":["Personal","Website"],"title":"Return of the... me?","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About Me","type":"widget_page"}]