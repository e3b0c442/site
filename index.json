[{"authors":["nick"],"categories":null,"content":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.\nGPG fingerprint: 9408 6361 4B0B 3307 5068 5FE8 DD3F EC7C 659D CEA2\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"22df73ca0cc2e5922b5f427771bc24c0","permalink":"/authors/nick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/nick/","section":"authors","summary":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.","tags":null,"title":"Nick Meyer","type":"authors"},{"authors":null,"categories":null,"content":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management. In order to up the challenge, the solutions will be written in C, and the code will pass all Valgrind tests for memory leaks and other issues. All code discussed in these posts will be in my Advent of Code solutions repository.\nTo kick things off, we\u0026rsquo;ll take a look at code reuse. When you\u0026rsquo;re quickly prototyping or problem solving, you\u0026rsquo;re frequently going to have identical snippets of code in multiple places. If we\u0026rsquo;re writing high-quality code, we want to avoid this wherever possible. One common theme throughout the Advent of Code problems will be reading an input file into memory. In order to avoid writing the same code over and over, we\u0026rsquo;re going to start things off by writing a function to read a file into a memory buffer:\nint read_file_to_buffer(char **buf, char *filename);  Already, just in the function signature, we are making design decisions. We could have written the function to return the pointer to the memory buffer, and in most languages this makes the most sense. However, in C, the length of an array is not an integral part of the data type, so we need to pass that information back as well. Therefore, I made the decision to pass a pointer to pointer to char (array) to the function, which will be modified in the function with the actual pointer to the allocated buffer, and to return the size of the buffer in the return value (or -1 if there is an error). We use this pattern rather than passing in the buffer itself because we do not know ahead of time how the buffer needs to be sized. The caller will be responsible for freeing the buffer when they are done using it.\nNow, lets think about what actually needs to happen to read a file into memory, and what can go wrong.\n Does the file exist? Is it a valid, readable file? How big is the file; consequently, how big does my buffer need to be? What happens if we don\u0026rsquo;t succeed in reading the actual data?  As you can see, when reading a file, there are a lot of potential failure points. Keeping that in mind, let\u0026rsquo;s start writing our code.\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */  The first thing we do is initialize variables that will exist for the life of the function (and be part of the cleanup). rval will hold our return value, f will hold our file pointer, and *buf is the pointer to the buffer that will hold the file contents, which is passed in as a parameter. Each is initialized to a sane default, as variables are not automatically initialized in C.\nWith that out of the way, we\u0026rsquo;ll make our first check. Using the POSIX stat function, we query the file for information. Right off the bat, this will tell us if the file exists; if it does not, stat will return -1 and set errno accordingly. If we see this, we will jump to our error cleanup.\nAt this point, I\u0026rsquo;m going to take a sidebar and talk a bit about goto. For most programmers, there\u0026rsquo;s a knee-jerk reaction to avoid goto at all costs. Generally, I agree with this with one exception: error cleanup. In this case, goto properly used provides an avenue to short-circuit function execution and provide for cleanup in the case of an error without reusing the same code.\nIf the file exists, the struct stat will be populated with information about the file, including the type and size. Continuing on:\n/* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; }  Our next check is that we are working with a regular file, as opposed to a directory, block device, or other file type. (note: stat follows symlinks!). We use the S_ISREG macro to accomplish this. Because this is a check and not necessarily an error condition, if the provided file is not a regular file we will set errno ourselves to indicate an invalid parameter and then jump to our error cleanup.\n/* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */  Now that we know the file exists, and that it\u0026rsquo;s a regular file, we will try to open it for reading. If the file is not readable for any reason, fopen will return NULL and set errno appropriately. We will check for the NULL return value and short-circuit as needed.\n/* allocate the buffer */ *buf = malloc(s.st_size); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */  Now that we\u0026rsquo;ve successfully opened the file, we\u0026rsquo;ll allocate the buffer. Even though we already had the size information from the stat call, I\u0026rsquo;ve chosen not to allocate the buffer until we know the file is readable, to avoid unnecessary allocations. For this problem it doesn\u0026rsquo;t really matter, but it\u0026rsquo;s a good habit to be in. If there is an error allocating the buffer such as running out of memory, malloc will return NULL and set errno; again we will check for this and short-circuit the function as necessary. I\u0026rsquo;m using malloc instead of calloc because we have designed the function such that the buffer will be completely filled by the file, negating the need to initialize it.\n/* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup;  Now we perform the actual read. fread is a buffered read which calls the low-level read syscall, and as such it will block until the requested size is read unless there is an error, allowing us to avoid need to loop until the expected data is read. Instead, we will check to make sure the expected size of data is read (the file size) and check for an error if it is not. If there is an error reading the file, we\u0026rsquo;ll short-circuit to our error cleanup.\n/* file is read into the buffer, return the number of bytes read */ rval = rd; goto cleanup;  We finish up the logic of our function by setting the return value to the amount of data read, and then jumping to our non-error cleanup.\nerr_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval;  Now for our cleanup. There are two things that need to be cleaned up in this function: first, the file needs to be closed if it was opened, to avoid file handle leaks. Also, if there was an error, the data buffer needs to be freed if it was allocated and the pointer set to NULL. Finally, if we did error, we set rval to -1 which indicates the error to the caller, who can then get more information by inspecting errno.\nThe whole function:\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */ /* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; } /* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */ /* allocate the buffer */ *buf = malloc(s.st_size); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */ /* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup; /* file is read into the buffer, return the number of bytes read */ rval = rd; goto cleanup; err_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval; }  We\u0026rsquo;ve now written a function with appropriate error checking that can be reused throughout our Advent of Code exercises!\n","date":1567900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567900800,"objectID":"4a19ca9dcbe5acd4634b1a929187717f","permalink":"/post/advent-setup-c/","publishdate":"2019-09-08T00:00:00Z","relpermalink":"/post/advent-setup-c/","section":"post","summary":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management.","tags":["programming","advent of code","c","best practices","DRY"],"title":"Advent of Code in-depth","type":"post"},{"authors":null,"categories":null,"content":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.\n","date":1567468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567468800,"objectID":"7b1a7e9fadbc0ac76e4a203dc7dda3a9","permalink":"/post/e3b0c442-returns/","publishdate":"2019-09-03T00:00:00Z","relpermalink":"/post/e3b0c442-returns/","section":"post","summary":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.","tags":["personal","website"],"title":"Return of the... me?","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About Me","type":"widget_page"}]