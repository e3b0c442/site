[{"authors":["nick"],"categories":null,"content":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.\nPGP fingerprint: 9408 6361 4B0B 3307 5068 5FE8 DD3F EC7C 659D CEA2\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"22df73ca0cc2e5922b5f427771bc24c0","permalink":"/authors/nick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/nick/","section":"authors","summary":"Nick Meyer is a senior software engineer at Verizon Media, where he architects and builds solutions to help teams deliver infrastructure at Internet scale with startup agility. When he isn\u0026rsquo;t tearing down roadblocks and automating mundane tasks, he might be found playing Hoot Owl Hoot with his children, performing with the Omaha Chamber Singers, or tinkering with his homemade wireless grill thermometer.\nHe flatly denies that the hash he uses to identify himself to the internet is a measurement of his personality.","tags":null,"title":"Nick Meyer","type":"authors"},{"authors":null,"categories":null,"content":"Note: I am not receiving any compensation either for what I\u0026rsquo;m saying here or for the product links on this page. I think the YubiKey is a great product, and I want to share why.\nWith the upcoming release of macOS Catalina \u0026ndash; and with it, the end of the last major browser holdout from the FIDO standards, I wanted to take a moment to talk about the YubiKey and the promise of the standards that it supports for secure internet authentication.\nBefore we dive into the YubiKey itself, I\u0026rsquo;d like to explain why this is important to me. The economic impact of compromised accounts is astronomical; according to a 2018 study by the Center for Strategic and International Studies in collaboration with McAfee, the economic impact of cyber crime is nearly $600 billion per year, or 1% of total global GDP. At the same time, password security is either misunderstood or ignored by both end users and system administrators alike; according to multiple sources, the most commonly-used password in recent years is 123456. In addition, password requirements vary greatly amongst services, with many still enforcing maximum length limits and the use of special characters (or limitation of characters) despite mathematical evidence that the use of easy-to-remember long passphrases is far more secure than requiring multiple special characters in a shorter password. Simply put - passwords need to be put out to pasture.\nWith what do we replace passwords? Public key cryptography has been widely-used and battle-tested for decades \u0026ndash; every time you visit a site with the https URL scheme, you are using it! \u0026ndash; and while some implementations have been shown to have weaknesses over time, the basic concepts are solid. As long as the private key can be protected, public key cryptograhy is an effective method of authenticating an end user and encrypting communications, which is where the YubiKey comes in.\nIf you are not familiar with the YubiKey, it is a multi-protocol hardware cryptographic token. The premise behind this kind of token is that the secret key is stored on the token and the token itself performs cryptographic operations using the key without making it accessible to the host system, thus preventing the key from being siphoned off by an unscrupulous actor. The latest generation YubiKey 5 family has support for the following protocols:\n USB HID: these protocols take advantage of the capability of the YubiKey to act as a keyboard and send data as keystrokes:  Static password: The YubiKey can generate a secure password that can be combined with an easy-to-remember value to simulate a 2nd-factor auth. Yubico OTP: A custom OTP implementation that relies on a shared key known by the YubiKey and the server. Yubico provides this service for all fresh-from-factory YubiKeys; if you don\u0026rsquo;t trust Yubico with your key, you can run the service by yourself and reprogram your YubiKey with a new shared key.  OTP (One-time password): These protocols allow for time- or event-based one-time passwords:  OATH-TOTP: This is the same protocol utilized by the nearly-ubiquitous mobile authenticators out there. In the case of the YubiKey, the one-time password values are read from the key with a special Yubico Authenticator application. OATH-HOTP: This one-time password mechanism is not nearly as commonly used due to its reliance on counters and susceptibility to synchronization issues. HMAC-SHA1 Challenge/Response: This protocol relies on a shared secret. The remote party sends a challenge, and the YubiKey calculates the HMAC-SHA1 code of the challenge using the shared secret, and returns it to the remote party.  CCID (Smart cards): These protocols allow the YubiKey to emulate smart cards:  OpenPGP: The YubiKey acts as an OpenPGP smart card, with three key slots available. The YubiKey then performs all sign/encrypt/decrypt operations using the stored keys. PIV: The YubiKey acts as a PIV card and can be accessed using the standard PKCS#11 protocols. In addition to raw keys, the PIV applet can store certificates and generate CSRs, allowing for the keys to be certified and have enforced expiration and revocation capabilities.  FIDO (web authentication): These protocols allow for the usage of public key cryptography for authentication in the Web browser:  U2F, aka CTAP1: This protocol allows for 2nd-factor authentication using the private key stored on the YubiKey. It was never standardized beyond FIDO and thus there are implementation and support issues across common browsers. FIDO2, aka CTAP2: This protocol is backwards-compatible with CTAP1, and works in concert with the W3C WebAuthn standard to allow not only 2nd-factor authentication, but completely passwordless authentication. This is the future of web authentication.   In addition to the fully-featured Yubikey 5 line, Yubico offers a \u0026ldquo;Security Key\u0026rdquo; line which only support the FIDO protocols. For the majority of people out there, this is sufficient.\nWebAuthn is a recently ratified standard by the W3C specifying a JavaScript API for facilitating authentication with public key cryptography. This works together with the CTAP device protocols to enable the web browser to communicate with a CTAP-compatible USB device and use it to securely authenticate a user to a service. Per the FIDO2 website: FIDO2 cryptographic login credentials are unique across every website, never leave the userâ€™s device and are never stored on a server. This security model eliminates the risks of phishing, all forms of password theft and replay attacks. The FIDO2 protocol also supports requiring a local second factor such as physical presence (push the button) or a PIN. In the case of a PIN, this can be a simpler value as it is never transmitted over the Internet nor stored outside of the device.\nI utilize my YubiKey 4 as much as possible. I use the PIV applet to log in locally to my computers; the OpenPGP applet to store my PGP auth, signing, and encryption keys that I use for signing git commits or remotely logging into servers. I utilize Yubico OTP as a second factor on my most sensitive servers as well as the secnod factor on my password manager. I utilize FIDO U2F wherever possible (Google, AWS, Facebook). I understand I am a power user, and that many of these use cases are quite advanced, but I simply see too much value in eschewing the world of the password and moving exclusively to public-key cryptography, now that I have the tools to do it. I only wish more things supported it, e.g. LUKS, which still requires a passphrase.\nRegardless of your level of expertise, I hope you are at least using a Security Key. If not, get one ASAP, and pressure every provider that does not yet support WebAuthn/FIDO2 to build that support as soon as possible. Hopefully we can start seeing that $600 billion number trend downward as more people adopt YubiKeys or other FIDO2-compliant devices.\n","date":1568764800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568764800,"objectID":"6fa27b35ebe67d46b83f7b7e8d98e193","permalink":"/post/yubikey/","publishdate":"2019-09-18T00:00:00Z","relpermalink":"/post/yubikey/","section":"post","summary":"Note: I am not receiving any compensation either for what I\u0026rsquo;m saying here or for the product links on this page. I think the YubiKey is a great product, and I want to share why.\nWith the upcoming release of macOS Catalina \u0026ndash; and with it, the end of the last major browser holdout from the FIDO standards, I wanted to take a moment to talk about the YubiKey and the promise of the standards that it supports for secure internet authentication.","tags":["Security","Cryptography","YubiKey"],"title":"The YubiKey; or, why are you still using a password in 2019?","type":"post"},{"authors":null,"categories":null,"content":"Welcome back to my Advent of Code series. I hope you\u0026rsquo;re enjoying exploring these problems in depth in C. Let\u0026rsquo;s take a look at the problem for day 6:\n Because your neighbors keep defeating you in the holiday house decorating contest year after year, you\u0026rsquo;ve decided to deploy one million lights in a 1000x1000 grid.\nFurthermore, because you\u0026rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.\nLights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at 0,0, 0,999, 999,999, and 999,0. The instructions include whether to turn on, turn off, or toggle various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like 0,0 through 2,2 therefore refers to 9 lights in a 3x3 square. The lights all start turned off.\nTo defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.\nFor example:\n turn on 0,0 through 999,999 would turn on (or leave on) every light. toggle 0,0 through 999,0 would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off. turn off 499,499 through 500,500 would turn off (or leave off) the middle four lights. After following the instructions, how many lights are lit?   Let\u0026rsquo;s look at our constituent problems:\n Read the input file into memory Set up a grid Parse the input lines Follow the input instructions  We already know how to read our file into memory, so we\u0026rsquo;ll move onto setting up the grid. As with Day 3, we will use a two-dimensional array to represent the grid. Unlike day 3, we know in advance what the size of the grid is, so we don\u0026rsquo;t need to do an extra loop to size it; we can just declare bool grid[1000][1000], initialize, and move on.\nLikewise, parsing the input lines is also a situation we have previously encountered. In previous days, we have used scanners and regular expressions. While using scanners is ideal for simple situations, we have to remember the downsides: scanners are tokenized by any whitespace, and scanners cannot safely be used to scan into strings. Both of these cases are disqualifiers for our input; we have a component of the input that might have a space in it, and we also need to scan into a string. For this reason, we\u0026rsquo;ll use regular expressions to parse our input. Because we can only parse into strings with regular expressions, we will also need to convert our number strings to numerical values.\nOnce we have our values, we can use them to set up a nested loop to update the values on the grid.\nLet\u0026rsquo;s look at some code:\nint main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 6:\\n\u0026quot;);  This is our now familiar check for argument, read input, and print preamble, included only for completeness at this point.\nregex_t inst_r; int result = regcomp(\u0026amp;inst_r, \u0026quot;\\\\(turn on\\\\|turn off\\\\|toggle\\\\) \\\\([[:digit:]]\\\\{1,\\\\}\\\\),\\\\([[:digit:]]\\\\{1,\\\\}\\\\) through \\\\([[:digit:]]\\\\{1,\\\\}\\\\),\\\\([[:digit:]]\\\\{1,\\\\}\\\\)\u0026quot;, 0); if (result != 0) goto err_cleanup;  Next, we compile the regular expression to match against. Without the escape characters, this expression looks like: (turn on|turn off|toggle) ([[:digit:]]{1,}),([[:digit:]]{1,}) through ([[:digit:]]{1,}),([[:digit:]]{1,}). Reading this expression aloud, we get Capture a group containing \u0026ldquo;turn on\u0026rdquo;, \u0026ldquo;turn off\u0026rdquo;, or \u0026ldquo;toggle\u0026rdquo;. Find a space. Capture a group of one or more digits, then find a comma, then capture a group of one or more digits. Find the phrase \u0026ldquo; through \u0026ldquo;. Capture a group of one or more digits, then find a comma, then capture a group of one or more digits. At the end of it, we have captured five submatches; one for the command, and then one each for the low and high X and Y coordinates.\nchar *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[6] = {0}; bool grid[1000][1000]; memset(grid, 0, 1000 * 1000 * sizeof(bool));  We now prepare to start our loop. We create the cursor variable and get the first line, declare an array to hold the regular expression match coordinates and initialize it, and declare and initialize the grid array. Note that we use memset for the grid array because the {0} initialization shorthand cannot be used with multidimensional arrays. Also note that we declared a six member array for the regular expression matches; the first match is always the full matched string, so we need room for this plus the five submatches that we actually care about.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize; memset(matches, 0, 6 * sizeof(regmatch_t)); result = regexec(\u0026amp;inst_r, line, 6, matches, 0); if (result != 0) goto err_cleanup; char instr[9] = {0}; char oxs[4] = {0}; char oys[4] = {0}; char dxs[4] = {0}; char dys[4] = {0}; strncpy(instr, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so); strncpy(oxs, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so); strncpy(oys, line + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so); strncpy(dxs, line + matches[4].rm_so, matches[4].rm_eo - matches[4].rm_so); strncpy(dys, line + matches[5].rm_so, matches[5].rm_eo - matches[5].rm_so); unsigned long ox = strtoul(oxs, NULL, 10); if (ox == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long oy = strtoul(oys, NULL, 10); if (oy == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long dx = strtoul(dxs, NULL, 10); if (dx == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; unsigned long dy = strtoul(dys, NULL, 10); if (dy == 0 \u0026amp;\u0026amp; errno == EINVAL) goto err_cleanup; if (strcmp(\u0026quot;turn on\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = true; } else if (strcmp(\u0026quot;turn off\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = false; } else if (strcmp(\u0026quot;toggle\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) grid[x][y] = !grid[x][y]; } else { goto err_cleanup; } tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now, we perform our loop on each of the input lines, parsing and following the directions. We\u0026rsquo;ll zero out the match array, then execute the compiled regular expression against the input line. We then initialize destination variables for each of the five submatch values, and use the match coordinates to copy the matched substrings into the destination variables.\nOnce the destination variables are populated, we\u0026rsquo;ll use strtoul to parse the four numerical values into integral equivalents, giving us the final set of parsed values to handle our input.\nAt this point, we use strcmp to compare the instruction string against the known instructions, and then set up a nested loop using the X and Y values. Finally, the interior of the loop sets the value of that coordinate per the instruction. You\u0026rsquo;ll notice that we parsed the instruction first, requiring the loop to be specified multiple times, seemingly breaking the don\u0026rsquo;t-repeat-yourself rule. In this case, however, this is justified, as if we reversed things, the string comparison would need to be done for each position, which would be prohibitvely computationally expensive. Once the loop is complete, the values of the grid are set.\nint on = 0; for (int x = 0; x \u0026lt; 1000; x++) for (int y = 0; y \u0026lt; 1000; y++) if (grid[x][y]) on++; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, on);  In order to get our solution, we set up a counter variable and then another nested loop over the entire two-dimensional surface. Each time we encounter a true value, we increment the counter. We then print our solution.\nAfter submitting the solution, the second problem is presented:\n You just finish implementing your winning light pattern when you realize you mistranslated Santa\u0026rsquo;s message from Ancient Nordic Elvish.\nThe light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.\nThe phrase turn on actually means that you should increase the brightness of those lights by 1.\nThe phrase turn off actually means that you should decrease the brightness of those lights by 1, to a minimum of zero.\nThe phrase toggle actually means that you should increase the brightness of those lights by 2.\nWhat is the total brightness of all lights combined after following Santa\u0026rsquo;s instructions?\nFor example:\n turn on 0,0 through 0,0 would increase the total brightness by 1. toggle 0,0 through 999,999 would increase the total brightness by 2000000.   As with previous problems, this one is simalar, and we can implement it in the existing loop to avoid the need to loop the input a second time.\nchar *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); regmatch_t matches[6] = {0}; bool grid[1000][1000]; int grid2[1000][1000]; memset(grid, 0, 1000 * 1000 * sizeof(bool)); memset(grid2, 0, 1000 * 1000 * sizeof(int));  We will declare a second grid variable, this time of type int[][], since we need to track more than just on or off.\nif (strcmp(\u0026quot;turn on\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = true; grid2[x][y]++; } } else if (strcmp(\u0026quot;turn off\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = false; grid2[x][y] = grid2[x][y] \u0026gt; 0 ? grid2[x][y] - 1 : 0; } } else if (strcmp(\u0026quot;toggle\u0026quot;, instr) == 0) { for (int x = ox; x \u0026lt;= dx; x++) for (int y = oy; y \u0026lt;= dy; y++) { grid[x][y] = !grid[x][y]; grid2[x][y] += 2; } } else { goto err_cleanup; }  The instructions are equivalent for both loops; we just need to add the application of the instructions to the second grid following the second transation\u0026rsquo;s directions.\nint on = 0; int bright = 0; for (int x = 0; x \u0026lt; 1000; x++) for (int y = 0; y \u0026lt; 1000; y++) { if (grid[x][y]) on++; bright += grid2[x][y]; } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, on); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, bright);  We\u0026rsquo;ll add a second counter variable and perform the addition during the same nested loop as the first solution, and then print both solutions.\ngoto cleanup; err_cleanup: rc = -1; cleanup: regfree(\u0026amp;inst_r); free(input); return rc; }  Finally, we will clean up. As before, we need to call regfree to free the compiled regular expression in addition to freeing the input.\nOur problems are gradually getting more difficult, but we\u0026rsquo;re almost a week through! Day seven\u0026rsquo;s solution requires implementing a new data structure, so our next article will take a break to discuss this in detail.\nAs always, comments, criticism, and banter are welcome, just leave a comment!\n","date":1568678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568678400,"objectID":"37e458296bd91b5c587f0603e8678566","permalink":"/post/advent-2015-c-6/","publishdate":"2019-09-17T00:00:00Z","relpermalink":"/post/advent-2015-c-6/","section":"post","summary":"Welcome back to my Advent of Code series. I hope you\u0026rsquo;re enjoying exploring these problems in depth in C. Let\u0026rsquo;s take a look at the problem for day 6:\n Because your neighbors keep defeating you in the holiday house decorating contest year after year, you\u0026rsquo;ve decided to deploy one million lights in a 1000x1000 grid.\nFurthermore, because you\u0026rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.","tags":["Programming","Advent of Code","C","Regular Expressions"],"title":"Advent of Code 2015 Day 6: Probably a Fire Hazard","type":"post"},{"authors":null,"categories":null,"content":"Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we are going to look at day 5:\n Santa needs help figuring out which strings in his text file are naughty or nice.\nA nice string is one with all of the following properties:\n It contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou. It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd). It does not contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.  For example:\n ugknbfddgicrmopn is nice because it has at least three vowels (u...i...o...), a double letter (...dd...), and none of the disallowed substrings. aaa is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap. jchzalrnumimnmhp is naughty because it has no double letter. haegwjzuvuyypxyu is naughty because it contains the string xy. dvszwmarrgswjxmb is naughty because it contains only one vowel.  How many strings are nice?\n Let\u0026rsquo;s begin by breaking down the problem. We need to:\n Read the input file into memory Split the input into its components Determine whether the string meets the naughty or nice requirements  The first two parts of this problem are familiar, and generally speaking, identical. We\u0026rsquo;ll use the variable good to track the good strings.\nint main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 5:\\n\u0026quot;);  The last part, however, is the most difficult problem that has yet been presented. How are we going to check the strings?\nWhile it might be tempting to loop over the strings and implement tracking variables to check these conditions (and, depending on the implementation, might be faster), the more appropriate tool in this situation is regular expressions.\nregex_t rule1, rule2, rule3; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup;  Each of the three rules can be checked using a valid POSIX basic regular expression (note that in the code snippet above, the appropriate escape characters have been added):\n at least 3 vowels: [aeiou].*[aeiou].*[aeiou]  This regular expression says: find a letter a, e, i, o, or u. Then find zero or more of any character, then a letter a,e,i,o,u, then zero or more of any character, then a, e, i, o, or u.  at least one letter that occurs twice in a row: (.)\\1  This regular expression uses a backreference to refer to a prior character. It says: find a group containing any one character, then find the first group. In this case, the first group is the matched one character.  does not contain ab, cd, pq, xy: (ab|cd|pq|xy)  We\u0026rsquo;ll actually be looking for a negative result on this one because it is simpler than trying to do the negation in the expression itself. This expression says, find the strings ab or cd or pq or xy.   We compile the expressions once to be used to quickly match the strings as we loop through the input:\nint good = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); goto cleanup;  If rule 3 does not match (we put this one in front to short-circuit, since if it matches the string is automatically invalid) and rules 1 and 2 match, then the string is a good string. Note that this appears backwards due to regexec returning 0 on match and 1 on no match. We output the counted good strings for our solution.\nThen, we just need to clean up:\nerr_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); free(input); return rc; }  With our solution submitted, we then get our second problem:\n Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.\nNow, a nice string is one with all of the following properties:\n It contains a pair of any two letters that appears at least twice in the string without overlapping, like xyxy (xy) or aabcdefgaa (aa), but not like aaa (aa, but it overlaps). It contains at least one letter which repeats with exactly one letter between them, like xyx, abcdefeghi (efe), or even aaa.  For example:\n qjhvhtzxzqqjkmpb is nice because is has a pair that appears twice (qj) and a letter that repeats with exactly one letter between them (zxz). xxyxx is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap. uurcxstgmygtbstg is naughty because it has a pair (tg) but no repeat with a single letter between them. ieodomkazucvgmuy is naughty because it has a repeating letter with one between (odo), but no pair that appears twice.  How many strings are nice under these new rules?\n As expected, the problem is very similar, if slightly more complicated. The good news is that these rules can also be checked with valid POSIX basic regular expressions, so we can easily add the new rules to the existing loop.\nregex_t rule1, rule2, rule3, rule4, rule5; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule4, \u0026quot;\\\\(..\\\\).*\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule5, \u0026quot;\\\\(.\\\\).\\\\1\u0026quot;, 0)) goto err_cleanup;  The two new rules are:\n A pair of two letters that appear at least twice in the string without overlapping: (..).*\\1  This regular expression says: find a group with two of any character, then find zero or more of any character, then find the first group.  one letter which repeats with exactly one letter between: (.).\\1  This regular expression says: find a group with one of any character, then find one of any character, then find the first group.   These are again compiled.\nint good = 0; int great = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; if (!regexec(\u0026amp;rule4, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule5, line, 0, NULL, 0)) great++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, great);  We add a second check for the two new rules, with a separate counter, then print the second result after the first.\nerr_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); regfree(\u0026amp;rule4); regfree(\u0026amp;rule5); free(input); return rc; }  Finally, we clean up the new compiled regexes in addition to the previous ones.\nAll together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;regex.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rc = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 5:\\n\u0026quot;); regex_t rule1, rule2, rule3, rule4, rule5; if (regcomp(\u0026amp;rule1, \u0026quot;[aeiou].*[aeiou].*[aeiou]\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule2, \u0026quot;\\\\(.\\\\)\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule3, \u0026quot;\\\\(ab\\\\|cd\\\\|pq\\\\|xy\\\\)\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule4, \u0026quot;\\\\(..\\\\).*\\\\1\u0026quot;, 0)) goto err_cleanup; if (regcomp(\u0026amp;rule5, \u0026quot;\\\\(.\\\\).\\\\1\u0026quot;, 0)) goto err_cleanup; int good = 0; int great = 0; char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; if (regexec(\u0026amp;rule3, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule1, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule2, line, 0, NULL, 0)) good++; if (!regexec(\u0026amp;rule4, line, 0, NULL, 0) \u0026amp;\u0026amp; !regexec(\u0026amp;rule5, line, 0, NULL, 0)) great++; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, good); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, great); goto cleanup; err_cleanup: rc = -1; printf(\u0026quot;badman\\n\u0026quot;); cleanup: regfree(\u0026amp;rule1); regfree(\u0026amp;rule2); regfree(\u0026amp;rule3); regfree(\u0026amp;rule4); regfree(\u0026amp;rule5); free(input); return rc; }  This is just one instance where a problem that is potentially complex can be simplified with regular expressions (note: this goes both ways!)\nAs always, if you have questions, comments, or suggestions, feel free to leave a comment!\n","date":1568419200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568419200,"objectID":"aa3aa3dc71b4048b68fda92b736de5d1","permalink":"/post/advent-2015-c-5/","publishdate":"2019-09-14T00:00:00Z","relpermalink":"/post/advent-2015-c-5/","section":"post","summary":"Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we are going to look at day 5:\n Santa needs help figuring out which strings in his text file are naughty or nice.\nA nice string is one with all of the following properties:\n It contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou. It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).","tags":["Programming","Advent of Code","C","Regular Expressions"],"title":"Advent of Code 2015 Day 5: Doesn't He Have Intern-Elves For This?","type":"post"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: 1, 2, 3, \u0026hellip;) that produces such a hash.\nFor example:\n If your secret key is abcdef, the answer is 609043, because the MD5 hash of abcdef609043 starts with five zeroes (000001dbbfa...), and it is the lowest such number to do so. If your secret key is pqrstuv, the lowest number it combines with to make an MD5 hash starting with five zeroes is 1048970; that is, the MD5 hash of pqrstuv1048970 looks like 000006136ef....   As always, we\u0026rsquo;ll start with breaking down the problem into discrete parts:\n Read the input Convert a number to a string Combine the input and the number string Get the MD5 digest of the combined string Check that the first five digits of the digest are 0  Rather than write our own MD5 hashing implementation, we will use the well-known and commonly-installed OpenSSL library\u0026rsquo;s implementation. You\u0026rsquo;ll need to make sure that your linker pulls in the OpenSSL library.\nLet\u0026rsquo;s write some code:\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  For the sake of completion, this is our standard prelude of verifying the command-line argument and reading the input file.\nprintf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16];  We print our preamble, then initialize some variables. Note that I\u0026rsquo;m doing this outside of a loop so that we do not incur this cost in the loop. Our code will be written in such a way that the variables do not need to be reinitialized on every pass. Step by step we have:\n The declaration of the iteration index i, which is the number that will be added to the input string on each pass The declaration of the buffer which stores the whole string to be hashed. We size from the input and then add 11 \u0026ndash; 10 for the maximum number of digits in a 32-bit integer, and 1 for the null terminator. The initialization of the string buffer. Ensuring all bytes are set to 0 now will help us not need to re-initialize the variable on every loop Copying the input into the buffer Creating a buffer for the MD5 digest. MD5 digests are 128 bits, so we need a 16-byte buffer. Note that we do not have a null terminator here because this is not a string.\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest);   Now we begin the loop. W se formatted print to append the string representation of i to the buffer. Notice that we are using pointer arithmetic to point to the first index in the buffer after the original input string. Because the numbers will only ever increase, we will overwrite this on each loop and not need to reinitialize the variable. We then get the MD5 digest of the constructed string.\nAt this point, one might be tempted to use formatted print to output the hexadecimal representation of the digest. Don\u0026rsquo;t! String formatting operations are computationally expensive, and we have the information we need to solve the problem without doing it.\nif (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; }  Note that the ratio of bytes to hex characters is 1:2; that is, each byte of the digest would translate to two hex characters. With this in mind, remember that this digest is just one big number; so, rather than convert the number back to a string, let\u0026rsquo;s just check the number.\nWe are searching for a digest where the first five digits of the hexadecimal representation of the digest are 0. For bytes 0 and 1, this is easy: the value of the byte must be 0. For byte 2, it requires a little bit more thought, since only the first digit must be zero. In this case, it\u0026rsquo;s just a matter of places like in decimal math. There are 16 possible hexadecimal digits, so any value of the byte that is less than 16 will have the first hex digit as 0.\nBy checking this way and avoiding the string conversion, we cut our compute usage down by 10-100x, which is important in this exercise as hashing is not a fast operation, relatively speaking.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i);  We now have our solution, which is the current value of i. Once this is validated, our second puzzle appears:\n Now find one that starts with six zeroes.\n Well, that\u0026rsquo;s succinct, isn\u0026rsquo;t it? Literally all we need to do at this point is resume the loop right where we left off, making one change: we can check that byte 2 of the digest is equal to zero, rather than less than 16:\nwhile (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; }  We don\u0026rsquo;t even need to reset i here, since by definition a digest can\u0026rsquo;t start with six zeroes without starting with five. In the circumstance that the first digest that begins with five zeroes also begins with six zeroes, the first iteration of our loop will catch it because we broke out of the previous loop before incrementing the index, and we don\u0026rsquo;t increment until the end of the loop.\nWe now have our solution, and can print it and clean up:\nprintf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0; }  When we put it all together, we have:\n\u0026rdquo;\u0026lsquo;c #include  #include  #include  #include  #include  #include \u0026ldquo;common.h\u0026rdquo;\nint main(int argc, char const argv[]) { / check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026ldquo;Must provide filename of input file\\n\u0026rdquo;); return -1; }\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 4:\\n\u0026quot;); /* initialize variables */ int i = 1; char buf[strlen(input) + 11]; memset(buf, 0, strlen(input) + 11); strcpy(buf, input); unsigned char digest[16]; /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] \u0026lt; 16) break; i++; } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, i); /* find the first matching digest */ while (1) { sprintf(buf + strlen(input), \u0026quot;%d\u0026quot;, i); MD5((const unsigned char *)buf, strlen(buf), digest); if (digest[0] == 0 \u0026amp;\u0026amp; digest[1] == 0 \u0026amp;\u0026amp; digest[2] == 0) break; i++; } printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, i); free(input); return 0;  } ```\n","date":1568084400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568084400,"objectID":"409f0a75a351b9fbce6cf49d57337bb1","permalink":"/post/advent-2015-c-4/","publishdate":"2019-09-10T03:00:00Z","relpermalink":"/post/advent-2015-c-4/","section":"post","summary":"I\u0026rsquo;m back for a second time today since this puzzle is fairly straightforward:\n Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal.","tags":["Programming","Advent of Code","C","Cryptography","Hashing"],"title":"Advent of Code 2015 Day 4: The Ideal Stocking Stuffer","type":"post"},{"authors":null,"categories":null,"content":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;). After each move, he delivers another present to the house at his new location.\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\nFor example:\n \u0026gt; delivers presents to 2 houses: one at the starting location, and one to the east. ^\u0026gt;v\u0026lt; delivers presents to 4 houses in a square, including twice to the house at his starting/ending location. ^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.   This problem seems pretty simple on the face of it, but let\u0026rsquo;s break it down. We will need to:\n Read the input from the file Iterate over the input Track which locations have been visited Count the visited locations  In order to track the location, we\u0026rsquo;ll need to use a slightly more advanced data structure. Since we are working with quantities in 2D space, a 2D array makes sense. Thankfully, in newer versions of the C standard, the array sizes do not need to be known at compile time, so we can avoid some messy pointer arithmetic.\nLet\u0026rsquo;s get to work.\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  If this looks familiar, you\u0026rsquo;re catching on. We check that the filename is provided, read the input file to memory, and handle any errors.\nNow we\u0026rsquo;re ready to get started\u0026hellip; but are we? We still have no idea how big our grid array needs to be. We could guess, but we run the danger of either making the arrays too small and going out-of-bounds, or making them too big and unnecessarily tying up memory. The better plan would be to iterate over the input and test the constraints.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1;  After printing our preamble, we\u0026rsquo;ll create tracking variables for the current x and y positions, and the minimum and maximums of both. We\u0026rsquo;ll initialize all of them to zero, and then iterate over the input, adjusting the current value of x and y and keeping the maximums and minimums updated as needed. Once the loop is complete, we have enough information to compute the sizes of the arrays. Note that we need to add 1 to the total; e.g. 1 - (-1) = 2, but that covers the values -1, 0, 1.\n/* create the grid and travel again */ bool grid[w][h]; memset(grid, 0, w * h * sizeof(bool)); x = 0 - min_x; y = 0 - min_y;  Now that we know the sizes, we can declare the two-dimensional array. Again, older versions of the C standard do not allow runtime determination of the array sizes for stack declarations; if you are stuck using an old version, you will need to allocate the array on the heap with malloc or the like. Since we only need to track if a house has been visited or not, we\u0026rsquo;ll use the bool data type for our grid. The more astute reader might know that bool is still represented with a full byte in C, but we can still use the type as a hint to those who might read your code as to the function.\nOnce we\u0026rsquo;ve declared the array, we will need to initialize it; while we can declare the array in this fashion now, we still cannot initialize it at declaration. We\u0026rsquo;ll use the memset function to zero out the allocated arrays. This is safe with our bool data type as false is represented as 0.\nFinally, we\u0026rsquo;ll set our initial indices for x and y for the upcoming run. Since we cannot have negative indices in an array, we\u0026rsquo;ll need to offset them using the minimum values previously found.\ngrid[x][y] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; break; case 'v': y--; break; case '\u0026lt;': x--; break; case '^': y++; break; default:; } grid[x][y] = true; }  We\u0026rsquo;re finally ready to gather our data. We\u0026rsquo;ll iterate through the input again, flipping the value on the grid to true as we visit each space. Notice that we set the origin space to true as well per the problem parameters (He begins by delivering a present to the house at his starting location...).\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses);  Once we\u0026rsquo;ve completed the loop, we can count the houses by iterating through the grid and incrementing a counter for each set of coordinates that is true. The ternary operator is used as a shortcut here.\nOnce we submit our solution, the second problem appears:\n The next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\nThis year, how many houses receive at least one present?\nFor example:\n ^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south. ^\u0026gt;v\u0026lt; now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started. ^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.   As we read, the difference here is that we have a second \u0026ldquo;Santa\u0026rdquo;, and they alternate directions in the input, rather than one taking all the directions. This means we will need to implement a toggle, as well as keep two sets of coordinates on the same grid. As with previous answers, I chose to integrate this solution into the original problem rather than writing a completely new set of code to solve problem 2.\nprintf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1;  In addition to the single x and y value for the first problem, I declare a two-element array to represent the coordinates of both santas for the second problem. I alse declare and initialize another set of min/max variables. Finally, a variable is declared to act as a toggle between 0 and 1.\nNow to find our coordinates, we run through the loop. We increment the x and y of the appropriate Santa, and check that against the x and y minimums and maximums for the second grid (remember, both Santas share the grid, so there is only one set of mins and maxes). We\u0026rsquo;ll update the values for the second grid based on the active Santa, and then once all values have been updated, we use the bitwise XOR assignment operator to flip the toggle value. Once the loop is complete, we calculate the width and height of the second grid.\n/* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2;  The grid creation for the second problem is identical to the first problem. The only difference comes in assigning the initial coordinates; this needs to be done for both Santas for the second problem.\ns = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; }  During the second iteration of the input, we\u0026rsquo;ll toggle the Santa as we did during the range finding iteration.\n/* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses);  We\u0026rsquo;ll count the number of visited houses for the second grid, exactly as we did the first grid.\nFinally, we\u0026rsquo;ll free our allocated input array for completeness and return success:\nfree(input); return rval; }  All together now:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 3:\\n\u0026quot;); /* size the grid */ int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0; int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0; int s = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } if (x \u0026gt; max_x) max_x = x; if (y \u0026gt; max_y) max_y = y; if (x \u0026lt; min_x) min_x = x; if (y \u0026lt; min_y) min_y = y; if (x2[s] \u0026gt; max_x2) max_x2 = x2[s]; if (y2[s] \u0026gt; max_y2) max_y2 = y2[s]; if (x2[s] \u0026lt; min_x2) min_x2 = x2[s]; if (y2[s] \u0026lt; min_y2) min_y2 = y2[s]; s ^= 1; } int w = (max_x - min_x) + 1; int h = (max_y - min_y) + 1; int w2 = (max_x2 - min_x2) + 1; int h2 = (max_y2 - min_y2) + 1; /* create the grids and travel again */ bool grid[w][h]; bool grid2[w2][h2]; memset(grid, 0, w * h * sizeof(bool)); memset(grid2, 0, w2 * h2 * sizeof(bool)); x = 0 - min_x; y = 0 - min_y; x2[0] = 0 - min_x2; x2[1] = 0 - min_x2; y2[0] = 0 - min_y2; y2[1] = 0 - min_y2; s = 0; grid[x][y] = true; grid[x2[0]][y2[0]] = true; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '\u0026gt;': x++; x2[s]++; break; case 'v': y--; y2[s]--; break; case '\u0026lt;': x--; x2[s]--; break; case '^': y++; y2[s]++; break; default:; } grid[x][y] = true; grid2[x2[s]][y2[s]] = true; s ^= 1; } /* count the houses touched */ int houses = 0; for (int i = 0; i \u0026lt; w; i++) for (int j = 0; j \u0026lt; h; j++) houses += grid[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, houses); houses = 0; for (int i = 0; i \u0026lt; w2; i++) for (int j = 0; j \u0026lt; h2; j++) houses += grid2[i][j] ? 1 : 0; printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, houses); free(input); return rval; }  ","date":1568073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568073600,"objectID":"756b26d309c5f79aaf0044e7d5d609e4","permalink":"/post/advent-2015-c-3/","publishdate":"2019-09-10T00:00:00Z","relpermalink":"/post/advent-2015-c-3/","section":"post","summary":"You\u0026rsquo;ve made it this far, so either nobody\u0026rsquo;s reading this, you\u0026rsquo;re all masochists, or I\u0026rsquo;m doing OK. Let\u0026rsquo;s take a look at day 3:\n Santa is delivering presents to an infinite two-dimensional grid of houses.\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (\u0026gt;), or west (\u0026lt;).","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum","type":"post"},{"authors":null,"categories":null,"content":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.\nFor example:\n A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet. A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.  All numbers in the elves\u0026rsquo; list are in feet. How many total square feet of wrapping paper should they order?\n As with day 1, we\u0026rsquo;re going to take a minute to break the problem down. As the problem states, the input is formatted as XXxYYxZZ, so we will need to parse the input into usable numbers. Since we need to operate on the smallest dimensions for the slack, we\u0026rsquo;ll need to be able to sort the inputted values. Finally, we\u0026rsquo;ll need to do the math and keep a running total.\nLet\u0026rsquo;s dig in:\nint main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; }  The preamble to our function is identical to day 1, with the exception of initializing our return value early as we\u0026rsquo;ll be using our goto short circuit pattern to handle some later potential errors. We check that the user provided a filename and read the file into the input buffer.\nprintf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0;  We\u0026rsquo;ll then print our daily header and initialize the running total for the wrapping paper.\n/* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;);  Now we start getting into some more interesting string handling. Note that the input has one present per line, so we need to effectively split the string on the lines. We will use the POSIX strsep function for this. There is a similar strtok function in the C standard librory, but it has the downside of being non-reentrant. If portability is a concern, you may want to stick use strtok, however strsep is widely supported and should be used instead of strtok wherever possible.\nIn order to avoid changing the original value of the pointer to the input, we make a copy into cursor which becomes the moving pointer passed as the first argument of strsep. Finally, we are splitting on the newline character \\n. We will not bother to make a copy of the input buffer as we only need to parse it once.\nwhile (line != NULL) { if (strlen(line) == 0) goto tokenize;  One side effect of strsep that one needs to be aware of is that if multiple delimiters are encountered in a row, strsep will return a pointer to an empty string instead of consuming all of the delimiters at once. We check for the empty string and short-circuit the loop if we encounter this.\n/* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; }  We now initialize an array of three ints to hold the parsed values. We use an array instead of separate variables because we will need to sort the result. Once the array is initialized, we use the sscanf function to scan the dimensions into the array. As we are not trying to scan into string variables, sscanf is perfectly safe for our usage. As an error check, we will short-circuit to the function cleanup if we have an invalid line which scans less than three values.\nqsort(dims, 3, sizeof(int), cmp_int_asc);  Once the values are scanned, they need to be sorted so that we can find the slack using the smallest side. For this we use the standard library function qsort with a simple comparator function:\nint cmp_int_asc(const void *a, const void *b) { int l = *(const int *)a; int r = *(const int *)b; return l \u0026lt; r ? -1 : l \u0026gt; r ? 1 : 0; }  The comparator dereferences and casts the inputs and then returns -1 if a \u0026lt; b, 1 if a \u0026gt; b, or 0 if they are equal. I use the ternary operator here for conciseness, but I would refrain from using it for anything more complex.\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); }  Now that we have our values and we have them sorted by smallest to largest, we just need to do the math and update our running total. As noted in the problem, for each present we need to add the area of each side plus the area of the smallest side as slack: 2xy + 2yz + 2xz + xy.\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  Once we have broken out of the input parsing loop, paper should have the total required wrapping paper. We can print the solution and then proceed with cleanup. As noted in day 1, freeing input is not strictly necessary in this case but is good from a habit-forming perspective.\nOnce the solution has been input, the second problem is presented:\n The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don\u0026rsquo;t ask how they tie the bow, though; they\u0026rsquo;ll never tell.\nFor example:\n A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet. A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.  How many total feet of ribbon should they order?\n As with day 1, we already have all of the infrastructure present to handle this new problem. We\u0026rsquo;ll add a new variable to track the running total of ribbon:\nint paper = 0; int ribbon = 0;  Then update the total ribbon on each loop, following the instructions to add 2x+2y+xyz to the total:\npaper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];  Finally, we\u0026rsquo;ll print the second solution:\nprintf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon);  When it\u0026rsquo;s all put together, we have:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { int rval = 0; /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 2:\\n\u0026quot;); int paper = 0; int ribbon = 0; /* tokenize the data into lines */ char *cursor = input; char *line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); while (line != NULL) { if (strlen(line) == 0) goto tokenize; /* scan each line's values */ int dims[3] = {0}; int scanned = sscanf(line, \u0026quot;%dx%dx%d\u0026quot;, \u0026amp;dims[0], \u0026amp;dims[1], \u0026amp;dims[2]); if (scanned != 3) { fprintf(stderr, \u0026quot;Invalid input line \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, line); goto err_cleanup; } qsort(dims, 3, sizeof(int), cmp_int_asc); paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1]; ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2]; tokenize: line = strsep(\u0026amp;cursor, \u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, paper); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, ribbon); goto cleanup; err_cleanup: rval = 1; cleanup: free(input); return rval; }  As before, this program will pass all Valgrind checks and does not leak memory.\nSuggestions, questions, and criticism welcome! Comments can be added below.\n","date":1567994400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567994400,"objectID":"f5e5b339b407c157e6918a4e63e14f57","permalink":"/post/advent-2015-c-2/","publishdate":"2019-09-09T02:00:00Z","relpermalink":"/post/advent-2015-c-2/","section":"post","summary":"I\u0026rsquo;m going to go ahead and do a second puzzle today since the early ones are relatively simple. Day 1\u0026rsquo;s puzzles were mostly incrementing, decrementing and tracking variables; Day 2\u0026rsquo;s have a bit more math involved.\n The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.","tags":["Programming","Advent of Code","C","String parsing"],"title":"Advent of Code 2015 Day 2: I Was Told There Would Be No Math","type":"post"},{"authors":null,"categories":null,"content":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere\u0026rsquo;s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can\u0026rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n (()) and ()() both result in floor 0. ((( and (()(()( both result in floor 3. ))((((( also results in floor 3. ()) and ))( both result in floor -1 (the first basement level). ))) and )())()) both result in floor -3.  To what floor do the instructions take Santa?\n Before we start writing code, let\u0026rsquo;s think about what needs to happen. We will need to input a file, read through it, determine which characters are important (( and )) and adjust the floor number accordingly. Then we\u0026rsquo;ll need to output our solution somehow.\nGenerally speaking, each day\u0026rsquo;s puzzle will be its own executable and the input filename will be a command-line argument.\nNow that we have a plan of attack, let\u0026rsquo;s dig in.\nint main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; }  First things first, let\u0026rsquo;s check and make sure the user actually provided a filename. Don\u0026rsquo;t forget that argv[0] is always the name of the invoked command, so argc must be at least 2 if the user has provided any arguments at all. If the argument is not present, we\u0026rsquo;ll print a useful error message to stderr and return from main with a non-zero code.\n/* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;);  Remember that input file function we wrote yesterday? Now we get to use it. We declare a pointer to the buffer and pass it into the function, along with the filename which should be in argv[1]. If the file doesn\u0026rsquo;t exist, isn\u0026rsquo;t readable, or any other problem that we handled in the function, it will return -1 and errno will be set. In that case, we print the error message to stderr and return non-zero. If everything worked, the contents of the file are now in the location in memory pointed to by our input pointer. Once we\u0026rsquo;ve successfully read the file, we\u0026rsquo;ll print our header line for the output.\nNow it\u0026rsquo;s time to solve the problem. The most straightforward way is going to be to iterate over the contents of the file in memory byte-by-byte and adjust the floor accordingly.\n/* solve the first puzzle */ int floor = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor);  We initialize our floor variable to zero as noted in the problem description (He starts on the ground floor (floor 0)...), and then construct a for loop with the index starting at 0 (remember, C arrays are zero-indexed) and incrementing by one until we reach the file size which was returned by our file input function. During each iteration of the loop, we check the byte at that index and either increment or decrement the floor number depending on the character. In this case, I have chosen to ignore any spurious characters that may be in the input.\nThe object of the problem is to determine which floor we arrive at (To what floor do the instructions take Santa?), so the value of the floor variable is our solution.\nOnce we input our solution, a second problem appears!\n Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n ) causes him to enter the basement at character position 1. ()()) causes him to enter the basement at character position 5.  What is the position of the character that causes Santa to first enter the basement?\n In the interest of saving compute time and code, we will attempt to integrate the finding of the second solution into the original code. In this case, it\u0026rsquo;s a matter of finding the index where we first hit floor -1. We can do this by setting a variable to a known bad value, and checking whether it has been reset to a known good value and if not, setting it. So, we\u0026rsquo;ll update our problem logic as such:\n/* solve the puzzles */ int floor = 0; int basement = -1; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == -1) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement);  In this updated logic, we set basement to a sentinel value of -1; since we are counting up, the value cannot possibly be negative. Then, in each iteration of the loop, we check for the floor to be -1 (since we can only move one floor at a time) and for the basement value to be the sentinel. For those of you counting instructions, notice that the floor check will short-circuit; i.e. the basement check will not happen unless the floor is -1. The net effect is that on average we are only adding one instruction per loop. Also notice that we set the value of basement to i + 1 as the positions are one-indexed per the problem parameters (The first character in the instructions has position 1...).\nfree(input); return 0; }  Now that we have solved the problem, we\u0026rsquo;ll clean up and return 0. Note that it is not strictly necessary to free input, but it is a good habit to be in.\nHere\u0026rsquo;s the whole program for day 1:\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026quot;common.h\u0026quot; int main(int argc, char const *argv[]) { /* check that filename was provided */ if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Must provide filename of input file\\n\u0026quot;); return -1; } /* read the file into memory */ char *input; int filesize = read_file_to_buffer(\u0026amp;input, argv[1]); if (filesize \u0026lt; 0) { fprintf(stderr, \u0026quot;File read failed: %s\\n\u0026quot;, strerror(errno)); return -1; } printf(\u0026quot;Day 1:\\n\u0026quot;); /* solve the puzzles */ int floor = 0; int basement = 0; for (int i = 0; i \u0026lt; filesize; i++) { switch (input[i]) { case '(': floor++; break; case ')': floor--; break; default:; } if (floor == -1 \u0026amp;\u0026amp; basement == 0) { basement = i + 1; } } printf(\u0026quot;\\tSolution 1: %d\\n\u0026quot;, floor); printf(\u0026quot;\\tSolution 2: %d\\n\u0026quot;, basement); free(input); return 0; }  This program makes proper error checks and manages memory properly, and will pass all Valgrind checks in a variety of test scenarios.\nIf I\u0026rsquo;ve done something horribly wrong or you have questions, please comment!\n","date":1567987200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567987200,"objectID":"b231645316f12b2922f38f7ba06232ed","permalink":"/post/advent-2015-c-1/","publishdate":"2019-09-09T00:00:00Z","relpermalink":"/post/advent-2015-c-1/","section":"post","summary":"Yesterday, I talked in general about what I am trying to accomplish with this series, and wrote a reusable function to read the input files into memory, which will be used frequently throughout the series. Now it\u0026rsquo;s time to dig in.\n Santa was hoping for a white Christmas, but his weather machine\u0026rsquo;s \u0026ldquo;snow\u0026rdquo; function is powered by stars, and he\u0026rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.","tags":["Programming","Advent of Code","C"],"title":"Advent of Code 2015 Day 1: Not Quite Lisp","type":"post"},{"authors":null,"categories":null,"content":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management. In order to up the challenge, the solutions will be written in C, and the code will pass all Valgrind tests for memory leaks and other issues. All code discussed in these posts will be in my Advent of Code solutions repository.\nTo kick things off, we\u0026rsquo;ll take a look at code reuse. When you\u0026rsquo;re quickly prototyping or problem solving, you\u0026rsquo;re frequently going to have identical snippets of code in multiple places. If we\u0026rsquo;re writing high-quality code, we want to avoid this wherever possible. One common theme throughout the Advent of Code problems will be reading an input file into memory. In order to avoid writing the same code over and over, we\u0026rsquo;re going to start things off by writing a function to read a file into a memory buffer:\nint read_file_to_buffer(char **buf, char *filename);  Already, just in the function signature, we are making design decisions. We could have written the function to return the pointer to the memory buffer, and in most languages this makes the most sense. However, in C, the length of an array is not an integral part of the data type, so we need to pass that information back as well. Therefore, I made the decision to pass a pointer to pointer to char (array) to the function, which will be modified in the function with the actual pointer to the allocated buffer, and to return the size of the buffer in the return value (or -1 if there is an error). We use this pattern rather than passing in the buffer itself because we do not know ahead of time how the buffer needs to be sized. The caller will be responsible for freeing the buffer when they are done using it.\nNow, lets think about what actually needs to happen to read a file into memory, and what can go wrong.\n Does the file exist? Is it a valid, readable file? How big is the file; consequently, how big does my buffer need to be? What happens if we don\u0026rsquo;t succeed in reading the actual data?  As you can see, when reading a file, there are a lot of potential failure points. Keeping that in mind, let\u0026rsquo;s start writing our code.\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */  The first thing we do is initialize variables that will exist for the life of the function (and be part of the cleanup). rval will hold our return value, f will hold our file pointer, and *buf is the pointer to the buffer that will hold the file contents, which is passed in as a parameter. Each is initialized to a sane default, as variables are not automatically initialized in C.\nWith that out of the way, we\u0026rsquo;ll make our first check. Using the POSIX stat function, we query the file for information. Right off the bat, this will tell us if the file exists; if it does not, stat will return -1 and set errno accordingly. If we see this, we will jump to our error cleanup.\nAt this point, I\u0026rsquo;m going to take a sidebar and talk a bit about goto. For most programmers, there\u0026rsquo;s a knee-jerk reaction to avoid goto at all costs. Generally, I agree with this with one exception: error cleanup. In this case, goto properly used provides an avenue to short-circuit function execution and provide for cleanup in the case of an error without reusing the same code.\nIf the file exists, the struct stat will be populated with information about the file, including the type and size. Continuing on:\n/* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; }  Our next check is that we are working with a regular file, as opposed to a directory, block device, or other file type. (note: stat follows symlinks!). We use the S_ISREG macro to accomplish this. Because this is a check and not necessarily an error condition, if the provided file is not a regular file we will set errno ourselves to indicate an invalid parameter and then jump to our error cleanup.\n/* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */  Now that we know the file exists, and that it\u0026rsquo;s a regular file, we will try to open it for reading. If the file is not readable for any reason, fopen will return NULL and set errno appropriately. We will check for the NULL return value and short-circuit as needed.\n/* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */  Now that we\u0026rsquo;ve successfully opened the file, we\u0026rsquo;ll allocate the buffer. Even though we already had the size information from the stat call, I\u0026rsquo;ve chosen not to allocate the buffer until we know the file is readable, to avoid unnecessary allocations. For this problem it doesn\u0026rsquo;t really matter, but it\u0026rsquo;s a good habit to be in. If there is an error allocating the buffer such as running out of memory, malloc will return NULL and set errno; again we will check for this and short-circuit the function as necessary. I\u0026rsquo;m using malloc instead of calloc because we have designed the function such that the buffer will be completely filled by the file, negating the need to initialize it. The extra +1 is to make room for a null terminator so that we may treat the buffer as a string.\n/* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup;  Now we perform the actual read. fread is a buffered read which calls the low-level read syscall, and as such it will block until the requested size is read unless there is an error, allowing us to avoid need to loop until the expected data is read. Instead, we will check to make sure the expected size of data is read (the file size) and check for an error if it is not. If there is an error reading the file, we\u0026rsquo;ll short-circuit to our error cleanup.\n/* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup;  We finish up the logic of our function by setting the extra allocated byte at the end of the buffer to a null terminator, then set the return value to the amount of data read, and finally jumping to our non-error cleanup. Array indeces have a higher precedence than the indirection operator, so we need to enclose the indirection in parentheses to avoid writing to the wrong memory address.\nerr_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval;  Now for our cleanup. There are two things that need to be cleaned up in this function: first, the file needs to be closed if it was opened, to avoid file handle leaks. Also, if there was an error, the data buffer needs to be freed if it was allocated and the pointer set to NULL. Finally, if we did error, we set rval to -1 which indicates the error to the caller, who can then get more information by inspecting errno.\nThe whole function:\nint read_file_to_buffer(char **buf, const char *filename) { int rval = 0; FILE *f = NULL; *buf = NULL; /* check that the file exists and is valid to read */ struct stat s; int rc = stat(filename, \u0026amp;s); if (rc == -1) goto err_cleanup; /* errno is set by stat() */ /* check that we are working with an actual file */ if (!S_ISREG(s.st_mode)) { errno = EINVAL; goto err_cleanup; } /* open the file */ f = fopen(filename, \u0026quot;r\u0026quot;); if (f == NULL) goto err_cleanup; /* errno is set by fopen() */ /* allocate the buffer */ *buf = malloc(s.st_size + 1); if (*buf == NULL) goto err_cleanup; /* errno is set by malloc() */ /* read the file into the buffer */ size_t rd = fread(*buf, 1, s.st_size, f); if (rd \u0026lt; s.st_size) if (ferror(f)) goto err_cleanup; /* file is read into the buffer, return the number of bytes read */ (*buf)[rd] = '\\0'; rval = rd; goto cleanup; err_cleanup: rval = -1; if (*buf != NULL) free(*buf); *buf = NULL; cleanup: if (f != NULL) fclose(f); return rval; }  We\u0026rsquo;ve now written a function with appropriate error checking that can be reused throughout our Advent of Code exercises!\n","date":1567980000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567980000,"objectID":"4a19ca9dcbe5acd4634b1a929187717f","permalink":"/post/advent-setup-c/","publishdate":"2019-09-08T22:00:00Z","relpermalink":"/post/advent-setup-c/","section":"post","summary":"In the first technical article for this iteration of the site, I\u0026rsquo;d like to turn to Advent of Code. These are programming problems built around a fun Christmas-themed storyline each year. I especially appreciate that the problems are language-agnostic, so I frequently turn to some of the easier ones when I\u0026rsquo;m getting familiar with a new language.\nIt can be easy to throw together just enough code to make the puzzle work, but I thought I\u0026rsquo;d revisit these problems from a different angle, looking not only at how to solve the problem, but how to write high-quality code, including error handling and memory management.","tags":["Programming","Advent of Code","C","Best practices","DRY"],"title":"Advent of Code deep dive kickoff","type":"post"},{"authors":null,"categories":null,"content":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.\n","date":1567468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567468800,"objectID":"7b1a7e9fadbc0ac76e4a203dc7dda3a9","permalink":"/post/e3b0c442-returns/","publishdate":"2019-09-03T00:00:00Z","relpermalink":"/post/e3b0c442-returns/","section":"post","summary":"So here we are again.\nAfter 20 years, you\u0026rsquo;d think I\u0026rsquo;d have gotten the hang of keeping a personal website current and up to date. Alas, times and priorities change.\nHopefully now that it\u0026rsquo;s easy to build with Hugo that will change and I can stick around for awhile and actually keep this up to date and post regularly.\nWe\u0026rsquo;ll see.","tags":["Personal","Website"],"title":"Return of the... me?","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"About Me","type":"widget_page"}]