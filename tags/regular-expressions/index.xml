<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Regular Expressions on e3b0c442.io</title>
    <link>/tags/regular-expressions/</link>
    <description>Recent content in Regular Expressions on e3b0c442.io</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/tags/regular-expressions/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advent of Code 2015 Day 7: Some Assembly Required</title>
      <link>/post/advent-2015-c-7/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-7/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a few weeks, but I&amp;rsquo;m glad to be able to pick up the Advent of Code series again. In the last post, I took a bit of a digression to discuss hash tables. In today&amp;rsquo;s post, we&amp;rsquo;ll see why. Let&amp;rsquo;s see what we have in store for day 7:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This year, Santa brought little Bobby Tables a set of wires and &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34; target=&#34;_blank&#34;&gt;bitwise logic gates&lt;/a&gt;! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.&lt;/p&gt;

&lt;p&gt;Each wire has an identifier (some lowercase letters) and can carry a &lt;a href=&#34;https://en.wikipedia.org/wiki/16-bit&#34; target=&#34;_blank&#34;&gt;16-bit&lt;/a&gt; signal (a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;65535&lt;/code&gt;). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.&lt;/p&gt;

&lt;p&gt;The included instructions booklet describes how to connect the parts together: &lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means to connect wires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to an AND gate, and then connect its output to wire &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 -&amp;gt; x&lt;/code&gt; means that the signal &lt;code&gt;123&lt;/code&gt; is provided to wire &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#AND&#34; target=&#34;_blank&#34;&gt;bitwise AND&lt;/a&gt; of wire &lt;code&gt;x&lt;/code&gt; and wire &lt;code&gt;y&lt;/code&gt; is provided to wire &lt;code&gt;z&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p LSHIFT 2 -&amp;gt; q&lt;/code&gt; means that the value from wire &lt;code&gt;p&lt;/code&gt; is &lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;left-shifted&lt;/a&gt; by &lt;code&gt;2&lt;/code&gt; and then provided to wire &lt;code&gt;q&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT e -&amp;gt; f&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#NOT&#34; target=&#34;_blank&#34;&gt;bitwise complement&lt;/a&gt; of the value from wire &lt;code&gt;e&lt;/code&gt; is provided to wire &lt;code&gt;f&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other possible gates include &lt;code&gt;OR&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#OR&#34; target=&#34;_blank&#34;&gt;bitwise OR&lt;/a&gt;) and &lt;code&gt;RSHIFT&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;right-shift&lt;/a&gt;). If, for some reason, you&amp;rsquo;d like to &lt;strong&gt;emulate&lt;/strong&gt; the circuit instead, almost all programming languages (for example, &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operations_in_C&#34; target=&#34;_blank&#34;&gt;C&lt;/a&gt;, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;, or &lt;a href=&#34;https://wiki.python.org/moin/BitwiseOperators&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt;) provide operators for these gates.&lt;/p&gt;

&lt;p&gt;For example, here is a simple circuit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 123 -&amp;gt; x
&amp;gt; 456 -&amp;gt; y
&amp;gt; x AND y -&amp;gt; d
&amp;gt; x OR y -&amp;gt; e
&amp;gt; x LSHIFT 2 -&amp;gt; f
&amp;gt; y RSHIFT 2 -&amp;gt; g
&amp;gt; NOT x -&amp;gt; h
&amp;gt; NOT y -&amp;gt; i
&amp;gt; ```

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After it is run, these are the signals on the wires:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In little Bobby&amp;rsquo;s kit&amp;rsquo;s instructions booklet (provided as your puzzle input), what signal is ultimately provided to &lt;strong&gt;wire &lt;code&gt;a&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a fairly complex problem, and in contrast to previous days&amp;rsquo; entries, there is more than one way to go about solving it successfully and efficiently. I chose to solve this problem by creating &lt;em&gt;hash tables&lt;/em&gt; with the gate statements, and then recursively calling an operator function to find the gate value. Hash tables are approprate for this task for two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Accessing the gate instructions will effectively be random-access since there is no linearity to how the instructions are arranged. Hash tables on average have &lt;em&gt;O(1)&lt;/em&gt; time complexity for searches.&lt;/li&gt;
&lt;li&gt;The gates are named by strings, allowing us to translate them directly into hash table keys.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will utilize the &lt;a href=&#34;/post/esht/&#34; target=&#34;_blank&#34;&gt;esht&lt;/a&gt; implementation discussed in the prior article. As noted in that article, while there is a POSIX hash table implementation, it is non-reentrant, and a re-entrant version included as part of the GNU C library is not present in many UNIX flavors, including macOS. In this case, reentrancy is important as we will soon see that we need to maintain two tables.&lt;/p&gt;

&lt;p&gt;As we examine this problem, what might immediately jump out is that each of these gates is a function that takes one or two 16-bit input values and outputs another value. Indeed, it would be possible, and some might consider elegant, to parse the inputs into a linked tree of function pointers using function pointers. However, I feel like this adds some unnecessary complexity and does not avoid the need for an additional caching mechanism, which is necessary due to the fact that we cannot guarantee that the gates are a true tree.&lt;/p&gt;

&lt;p&gt;Given this, it is much simpler and cleaner to parse the gate definitions into a data structure and make recursive calls to a single executor function to accomplish the goal of the task.&lt;/p&gt;

&lt;p&gt;With that lengthy discussion out of the way, let&amp;rsquo;s break the problem down a bit as we have done in previous weeks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Parse the individual gates into a hash table&lt;/li&gt;
&lt;li&gt;Execute the gates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As gates can also be inputs to another gate, we will need to call the gate executor recursively, so we will make this a separate function. We&amp;rsquo;ll start our coding here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t do_op(esht *instrs, esht *cache, char *key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our gate execution function takes three arguments: the hash table with the gate instructions keyed by gate name, a cache of already-resolved values also keyed by the gate name, and the gate key itself. The return value is &lt;code&gt;uint16_t&lt;/code&gt;, which is an unsigned 16-bit integer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we are going to do is check for a cached value. We use the provided key and cache table pointer to call &lt;code&gt;esht_get()&lt;/code&gt;; we cast the return value to a pointer to &lt;code&gt;uint16_t&lt;/code&gt; as the values are stored in the hash table as void pointers. If a result is found in the cache, we copy the value, clean up the allocated memory (remember that with &lt;code&gt;esht&lt;/code&gt;, the caller is responsible for cleanup of returned values), and return the retrieved value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no value in the cache for the key, it is time to start solving the gate value. We&amp;rsquo;ll first pull the gate definition from the hash table where we&amp;rsquo;ve already stored it. We then declare an array of four matches; the instruction parsing expression has three submatches in addition to the whole string match, which we will discuss later. For now, it is sufficient to know that we are capturing the three components of the gate expression. Finally, we execute the regular expression to populate the match variables. If either the instruction lookup fails or the regular expression execution returns no match, &lt;code&gt;errno&lt;/code&gt; is set appropriately and execution jumps to the error cleanup handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start working on the gate values. First, we set up temporary buffers for the string representations of each of the components of the gate expression: the left operand, the operation, and the right operand. The buffer sizes are chosen specifically; since l and r can be no larger than 65536, we know that 5 characters is the max storage; likewise, the longest gate operation is 6 characters. All buffers have the extra byte for the null terminator, and are initialized appropriately. We then additionally define a &lt;code&gt;char&lt;/code&gt; pointer which is used as part of the &lt;code&gt;strtoul&lt;/code&gt; error check, and finally integral values for the left and right operands of the gate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our variable initalization complete, we&amp;rsquo;ll start checking the values. For the left operand, the first thing we will check is that it is actually there, since some gates only have a single (right) operand. One useful properties of regular expressions in this case is that even if a submatch is conditional, its position in the results is still
preserved, so we know that the right operand will always have match index 3, regardless of whether the left operand and operator exist at all. If the submatch does not actually exist, member &lt;code&gt;rm_so&lt;/code&gt; of the &lt;code&gt;regmatch_t&lt;/code&gt; returned by &lt;code&gt;regexec&lt;/code&gt; will be -1.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve verified the submatch exists, we will copy just the submatch value to our temporary buffer by using the offests returned in the &lt;code&gt;regmatch_t&lt;/code&gt;. We will then attempt to convert the buffer to an unsigned long using &lt;code&gt;strtoul&lt;/code&gt;. We pass &lt;code&gt;check&lt;/code&gt; into the function; if the value of &lt;code&gt;check&lt;/code&gt; is the same as the string pointer once the operation is done and the return value is 0, we know that no number was actually found in the string and we can assume that rather than a value, it is the key to another gate and we can consequently make the recursive call. If the call returns the sentinel value and &lt;code&gt;errno&lt;/code&gt; is set, we&amp;rsquo;ll propogate that up.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we do the same for the right operand; the only difference being that we always expect the right operand to be there; if it is absent, that is considered an error and we will return appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will parse the operator. We know what the expected values are here; if the operator does not exist, we know that we are just returning the value provided by the right operand; else, we find one of the known bitwise operations and perform it, setting the return value accordingly. If the operator exists but is not an expected value, this is an error condition and we jump appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have gotten this far, we now have a final value for this gate that can be cached. We will add the value to the cache table with the gate&amp;rsquo;s key so that future calls to this gate can just return the cached value. Then we will go to the cleanup, where we make sure to free the instruction we retrieved from the hash table and free our iretrieved instruction.&lt;/p&gt;

&lt;p&gt;Now that we have our operation function implemented, we can look at the containing function for the problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identically to previous days, we parse the arguments, open the file, and copy it into memory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then compile the regular expression that splits the gate operation from its key. If this returns an unexpected result, we will jump to the error cleanup. This is a fairly simple regex, that captures two submatches: anything to the left of &lt;code&gt;-&amp;gt;&lt;/code&gt;, and then a gate key to the right of &lt;code&gt;-&amp;gt;&lt;/code&gt;, which is only letters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will set up some variables in preparation for looping over the input, including our line cursor and an array of &lt;code&gt;regmatch_t&lt;/code&gt; for capturing the gate operations and keys, which we initialize to all zeroes on declaration. Then we create the table that will hold all of the gates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        int res;
        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we loop over the input, parsing the input lines into the hash table. We first check that there is actually length ta the line; if so, then we zero out the match objects (since we aren&amp;rsquo;t declaring them inside the loop) and execute the regular expression against the line. If there is no match, we&amp;rsquo;ll break the loop and error out.&lt;/p&gt;

&lt;p&gt;Assuming all goes well, we will then declare temporary buffors for the key and value; we chose a sane length for both to avoid the need to allocate on the heap. We then use the offsets in the &lt;code&gt;regmatch_t&lt;/code&gt; to copy the key and gate operation into the buffers. Finally, we add the gate to the hash table, erroring out if there is an unexpected return from the update operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then create the expression for parsing the gate operations, which is stored in a file-local manner as mentioned before. This expression searches for an optional alphanumeric value, followed by an optional operator from the list provided in the problem specification, followed by a &lt;em&gt;required&lt;/em&gt; alphanumeric expression. If there is a problem compiling the regular expression, we&amp;rsquo;ll jump to the error handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we allocate another table to cache values. This is required due to the fact that the connections between the gates form more of a web than a tree, which can cause, if not complete short-circuits, unnecessary multiple executions of the gate to find the value. We call the operation function with the key &amp;ldquo;a&amp;rdquo; as defined in the problem statement, which will recursively call itself with the appropriate gates to calculate the final value at wire &amp;ldquo;a&amp;rdquo;, which we will then print.&lt;/p&gt;

&lt;p&gt;Now that we have solved the first problem, let&amp;rsquo;s see what the second problem will require:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, take the signal you got on wire &lt;code&gt;a&lt;/code&gt;, override wire &lt;code&gt;b&lt;/code&gt; to that signal, and reset the other wires (including wire &lt;code&gt;a&lt;/code&gt;). What new signal is ultimately provided to wire &lt;code&gt;a&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s a good thing we made that cache table! Since we didn&amp;rsquo;t alter the original instructions, all we need to do is destroy the old cache, then set value &amp;ldquo;b&amp;rdquo; in the new cache as directed in the instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once Solution 2 is printed, we can clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting the whole thing together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;pcreposix.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;
#include &amp;quot;esht.h&amp;quot;

static regex_t instr_r;

uint16_t do_op(esht *instrs, esht *cache, char *key)
{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }

    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;

    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }

    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }

    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;

    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}

int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);

    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;

    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;

    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is by far the most complex problem we have dealt with, requiring both a new data structure and the use of recursion to solve.&lt;/p&gt;

&lt;p&gt;As always, feel free to leave a comment if you have constructive feedback. We&amp;rsquo;ll be back for day 8 shortly!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 6: Probably a Fire Hazard</title>
      <link>/post/advent-2015-c-6/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-6/</guid>
      <description>&lt;p&gt;Welcome back to my Advent of Code series. I hope you&amp;rsquo;re enjoying exploring these
problems in depth in C. Let&amp;rsquo;s take a look at the problem for day 6:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because your neighbors keep defeating you in the holiday house decorating contest year after year, you&amp;rsquo;ve decided to deploy one million lights in a 1000x1000 grid.&lt;/p&gt;

&lt;p&gt;Furthermore, because you&amp;rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.&lt;/p&gt;

&lt;p&gt;Lights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at &lt;code&gt;0,0&lt;/code&gt;, &lt;code&gt;0,999&lt;/code&gt;, &lt;code&gt;999,999&lt;/code&gt;, and &lt;code&gt;999,0&lt;/code&gt;. The instructions include whether to &lt;code&gt;turn on&lt;/code&gt;, &lt;code&gt;turn off&lt;/code&gt;, or &lt;code&gt;toggle&lt;/code&gt; various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like &lt;code&gt;0,0 through 2,2&lt;/code&gt; therefore refers to 9 lights in a 3x3 square. The lights all start turned off.&lt;/p&gt;

&lt;p&gt;To defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 999,999&lt;/code&gt; would turn on (or leave on) every light.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,0&lt;/code&gt; would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;turn off 499,499 through 500,500&lt;/code&gt; would turn off (or leave off) the middle four lights.&lt;/li&gt;
&lt;li&gt;After following the instructions, &lt;strong&gt;how many lights are lit&lt;/strong&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s look at our constituent problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Set up a grid&lt;/li&gt;
&lt;li&gt;Parse the input lines&lt;/li&gt;
&lt;li&gt;Follow the input instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We already know how to read our file into memory, so we&amp;rsquo;ll move onto setting up
the grid. As with &lt;a href=&#34;/post/advent-2015-c-3/&#34; target=&#34;_blank&#34;&gt;Day 3&lt;/a&gt;, we will use a
two-dimensional array to represent the grid. Unlike day 3, we know in advance
what the size of the grid is, so we don&amp;rsquo;t need to do an extra loop to size it;
we can just declare &lt;code&gt;bool grid[1000][1000]&lt;/code&gt;, initialize, and move on.&lt;/p&gt;

&lt;p&gt;Likewise, parsing the input lines is also a situation we have previously
encountered. In previous days, we have used &lt;a href=&#34;/post/advent-2015-c-2/&#34; target=&#34;_blank&#34;&gt;scanners&lt;/a&gt; and &lt;a href=&#34;/post/advent-2015-c-5/&#34; target=&#34;_blank&#34;&gt;regular expressions&lt;/a&gt;. While using scanners is ideal for simple situations,
we have to remember the downsides: scanners are tokenized by any whitespace, and
scanners cannot safely be used to scan into strings. Both of these cases are
disqualifiers for our input; we have a component of the input that might have a
space in it, and we also need to scan into a string. For this reason, we&amp;rsquo;ll use
regular expressions to parse our input. Because we can only parse into strings
with regular expressions, we will also need to convert our number strings to
numerical values.&lt;/p&gt;

&lt;p&gt;Once we have our values, we can use them to set up a nested loop to update the
values on the grid.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 6:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is our now familiar check for argument, read input, and print preamble,
included only for completeness at this point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t inst_r;
    int result = regcomp(&amp;amp;inst_r, &amp;quot;\\(turn on\\|turn off\\|toggle\\) \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\) through \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we compile the regular expression to match against. Without the escape
characters, this expression looks like: &lt;code&gt;(turn on|turn off|toggle) ([[:digit:]]{1,}),([[:digit:]]{1,}) through ([[:digit:]]{1,}),([[:digit:]]{1,})&lt;/code&gt;.
Reading this expression aloud, we get &lt;em&gt;Capture a group containing &amp;ldquo;turn on&amp;rdquo;,
&amp;ldquo;turn off&amp;rdquo;, or &amp;ldquo;toggle&amp;rdquo;. Find a space. Capture a group of one or more digits,
then find a comma, then capture a group of one or more digits. Find the phrase
&amp;ldquo; through &amp;ldquo;. Capture a group of one or more digits, then find a comma, then
capture a group of one or more digits.&lt;/em&gt; At the end of it, we have captured five submatches; one for the command, and then one each for the low and high X and Y coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now prepare to start our loop. We create the cursor variable and get the
first line, declare an array to hold the regular expression match coordinates
and initialize it, and declare and initialize the grid array. Note that we use
&lt;code&gt;memset&lt;/code&gt; for the grid array because the &lt;code&gt;{0}&lt;/code&gt; initialization shorthand cannot be
used with multidimensional arrays. Also note that we declared a six member array
for the regular expression matches; the first match is always the full matched
string, so we need room for this plus the five submatches that we actually care
about.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 6 * sizeof(regmatch_t));
        result = regexec(&amp;amp;inst_r, line, 6, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char instr[9] = {0};
        char oxs[4] = {0};
        char oys[4] = {0};
        char dxs[4] = {0};
        char dys[4] = {0};

        strncpy(instr, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(oxs, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);
        strncpy(oys, line + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        strncpy(dxs, line + matches[4].rm_so, matches[4].rm_eo - matches[4].rm_so);
        strncpy(dys, line + matches[5].rm_so, matches[5].rm_eo - matches[5].rm_so);

        unsigned long ox = strtoul(oxs, NULL, 10);
        if (ox == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long oy = strtoul(oys, NULL, 10);
        if (oy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dx = strtoul(dxs, NULL, 10);
        if (dx == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dy = strtoul(dys, NULL, 10);
        if (dy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;

        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = true;
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = false;
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = !grid[x][y];
        }
        else
        {
            goto err_cleanup;
        }

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we perform our loop on each of the input lines, parsing and following the
directions. We&amp;rsquo;ll zero out the match array, then execute the compiled regular
expression against the input line. We then initialize destination variables for
each of the five submatch values, and use the match coordinates to copy the
matched substrings into the destination variables.&lt;/p&gt;

&lt;p&gt;Once the destination variables are populated, we&amp;rsquo;ll use &lt;code&gt;strtoul&lt;/code&gt; to parse the
four numerical values into integral equivalents, giving us the final set of
parsed values to handle our input.&lt;/p&gt;

&lt;p&gt;At this point, we use strcmp to compare the instruction string against the known
instructions, and then set up a nested loop using the X and Y values. Finally,
the interior of the loop sets the value of that coordinate per the instruction.
You&amp;rsquo;ll notice that we parsed the instruction first, requiring the loop to be
specified multiple times, seemingly breaking the &lt;em&gt;don&amp;rsquo;t-repeat-yourself&lt;/em&gt; rule.
In this case, however, this is justified, as if we reversed things, the string
comparison would need to be done for each position, which would be prohibitvely
computationally expensive. Once the loop is complete, the values of the grid
are set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
            if (grid[x][y])
                on++;

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get our solution, we set up a counter variable and then another
nested loop over the entire two-dimensional surface. Each time we encounter
a &lt;code&gt;true&lt;/code&gt; value, we increment the counter. We then print our solution.&lt;/p&gt;

&lt;p&gt;After submitting the solution, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You just finish implementing your winning light pattern when you realize you mistranslated Santa&amp;rsquo;s message from Ancient Nordic Elvish.&lt;/p&gt;

&lt;p&gt;The light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn on&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn off&lt;/code&gt; actually means that you should decrease the brightness of those lights by &lt;code&gt;1&lt;/code&gt;, to a minimum of zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;toggle&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What is the &lt;strong&gt;total brightness&lt;/strong&gt; of all lights combined after following Santa&amp;rsquo;s instructions?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 0,0&lt;/code&gt; would increase the total brightness by 1.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,999&lt;/code&gt; would increase the total brightness by 2000000.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with previous problems, this one is simalar, and we can implement it in the
existing loop to avoid the need to loop the input a second time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    int grid2[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
    memset(grid2, 0, 1000 * 1000 * sizeof(int));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will declare a second grid variable, this time of type &lt;code&gt;int[][]&lt;/code&gt;, since we
need to track more than just on or off.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = true;
                    grid2[x][y]++;
                }
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = false;
                    grid2[x][y] = grid2[x][y] &amp;gt; 0 ? grid2[x][y] - 1 : 0;
                }
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = !grid[x][y];
                    grid2[x][y] += 2;
                }
        }
        else
        {
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The instructions are equivalent for both loops; we just need to add the
application of the instructions to the second grid following the second
transation&amp;rsquo;s directions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    int bright = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
        {
            if (grid[x][y])
                on++;
            bright += grid2[x][y];
        }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, bright);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll add a second counter variable and perform the addition during the same
nested loop as the first solution, and then print both solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    regfree(&amp;amp;inst_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we will clean up. As before, we need to call &lt;code&gt;regfree&lt;/code&gt; to free the
compiled regular expression in addition to freeing the input.&lt;/p&gt;

&lt;p&gt;Our problems are gradually getting more difficult, but we&amp;rsquo;re almost a week
through! Day seven&amp;rsquo;s solution requires implementing a new data structure, so our
next article will take a break to discuss this in detail.&lt;/p&gt;

&lt;p&gt;As always, comments, criticism, and banter are welcome, just leave a comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 5: Doesn&#39;t He Have Intern-Elves For This?</title>
      <link>/post/advent-2015-c-5/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-5/</guid>
      <description>&lt;p&gt;Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we
are going to look at day 5:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa needs help figuring out which strings in his text file are naughty or nice.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;nice string&lt;/strong&gt; is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains at least three vowels (&lt;code&gt;aeiou&lt;/code&gt; only), like &lt;code&gt;aei&lt;/code&gt;, &lt;code&gt;xazegov&lt;/code&gt;, or &lt;code&gt;aeiouaeiouaeiou&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It contains at least one letter that appears twice in a row, like &lt;code&gt;xx&lt;/code&gt;, &lt;code&gt;abcdde&lt;/code&gt; (&lt;code&gt;dd&lt;/code&gt;), or &lt;code&gt;aabbccdd&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;bb&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt;, or &lt;code&gt;dd&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;It does &lt;strong&gt;not&lt;/strong&gt; contain the strings &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;pq&lt;/code&gt;, or &lt;code&gt;xy&lt;/code&gt;, even if they are part of one of the other requirements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ugknbfddgicrmopn&lt;/code&gt; is nice because it has at least three vowels (&lt;code&gt;u...i...o...&lt;/code&gt;), a double letter (&lt;code&gt;...dd...&lt;/code&gt;), and none of the disallowed substrings.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aaa&lt;/code&gt; is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jchzalrnumimnmhp&lt;/code&gt; is naughty because it has no double letter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;haegwjzuvuyypxyu&lt;/code&gt; is naughty because it contains the string &lt;code&gt;xy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dvszwmarrgswjxmb&lt;/code&gt; is naughty because it contains only one vowel.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s begin by breaking down the problem. We need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Split the input into its components&lt;/li&gt;
&lt;li&gt;Determine whether the string meets the naughty or nice requirements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first two parts of this problem are familiar, and generally speaking,
identical. We&amp;rsquo;ll use the variable &lt;code&gt;good&lt;/code&gt; to track the good strings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part, however, is the most difficult problem that has yet been
presented. How are we going to check the strings?&lt;/p&gt;

&lt;p&gt;While it might be tempting to loop over the strings and implement tracking
variables to check these conditions (and, depending on the implementation, might
be faster), the more appropriate tool in this situation is regular expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the three rules can be checked using a valid POSIX basic regular
expression (note that in the code snippet above, the appropriate escape
characters have been added):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;at least 3 vowels: &lt;code&gt;[aeiou].*[aeiou].*[aeiou]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a letter a, e, i, o, or u. Then find
zero or more of any character, then a letter a,e,i,o,u, then zero or more of
any character, then a, e, i, o, or u.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;at least one letter that occurs twice in a row: &lt;code&gt;(.)\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression uses a backreference to refer to a prior character.
It says: &lt;em&gt;find a group containing any one character, then find the first
group&lt;/em&gt;. In this case, the first group is the matched one character.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;does not contain ab, cd, pq, xy: &lt;code&gt;(ab|cd|pq|xy)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;ll actually be looking for a negative result on this one because it is
simpler than trying to do the negation in the expression itself. This
expression says, &lt;em&gt;find the strings ab or cd or pq or xy&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We compile the expressions once to be used to quickly match the strings as we
loop through the input:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);

    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If rule 3 does not match (we put this one in front to short-circuit, since if
it matches the string is automatically invalid) and rules 1 and 2 match, then
the string is a good string. Note that this appears backwards due to &lt;code&gt;regexec&lt;/code&gt;
returning 0 on match and 1 on no match. We output the counted good strings for
our solution.&lt;/p&gt;

&lt;p&gt;Then, we just need to clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our solution submitted, we then get our second problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.&lt;/p&gt;

&lt;p&gt;Now, a nice string is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains a pair of any two letters that appears at least twice in the string without overlapping, like &lt;code&gt;xyxy&lt;/code&gt; (&lt;code&gt;xy&lt;/code&gt;) or &lt;code&gt;aabcdefgaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;), but not like &lt;code&gt;aaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, but it overlaps).&lt;/li&gt;
&lt;li&gt;It contains at least one letter which repeats with exactly one letter between them, like &lt;code&gt;xyx&lt;/code&gt;, &lt;code&gt;abcdefeghi&lt;/code&gt; (&lt;code&gt;efe&lt;/code&gt;), or even &lt;code&gt;aaa&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qjhvhtzxzqqjkmpb&lt;/code&gt; is nice because is has a pair that appears twice (&lt;code&gt;qj&lt;/code&gt;) and a letter that repeats with exactly one letter between them (&lt;code&gt;zxz&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xxyxx&lt;/code&gt; is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uurcxstgmygtbstg&lt;/code&gt; is naughty because it has a pair (&lt;code&gt;tg&lt;/code&gt;) but no repeat with a single letter between them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ieodomkazucvgmuy&lt;/code&gt; is naughty because it has a repeating letter with one between (&lt;code&gt;odo&lt;/code&gt;), but no pair that appears twice.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice under these new rules?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As expected, the problem is very similar, if slightly more complicated. The good
news is that these rules can also be checked with valid POSIX basic regular
expressions, so we can easily add the new rules to the existing loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two new rules are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pair of two letters that appear at least twice in the string without
overlapping: &lt;code&gt;(..).*\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with two of any character, then
find zero or more of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;one letter which repeats with exactly one letter between: &lt;code&gt;(.).\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with one of any character, then
find one of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are again compiled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add a second check for the two new rules, with a separate counter, then print
the second result after the first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we clean up the new compiled regexes in addition to the previous ones.&lt;/p&gt;

&lt;p&gt;All together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);

    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;

    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);

    goto cleanup;

err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just one instance where a problem that is potentially complex can be
simplified with regular expressions (note: this goes both ways!)&lt;/p&gt;

&lt;p&gt;As always, if you have questions, comments, or suggestions, feel free to leave
a comment!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
