<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on e3b0c442.io</title>
    <link>/tags/programming/</link>
    <description>Recent content in Programming on e3b0c442.io</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum</title>
      <link>/post/advent-2015-c-3/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-3/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve made it this far, so either nobody&amp;rsquo;s reading this, you&amp;rsquo;re all masochists,
or I&amp;rsquo;m doing OK. Let&amp;rsquo;s take a look at day 3:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa is delivering presents to an infinite two-dimensional grid of houses.&lt;/p&gt;

&lt;p&gt;He begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (&lt;code&gt;^&lt;/code&gt;), south (&lt;code&gt;v&lt;/code&gt;), east (&lt;code&gt;&amp;gt;&lt;/code&gt;), or west (&lt;code&gt;&amp;lt;&lt;/code&gt;). After each move, he delivers another present to the house at his new location.&lt;/p&gt;

&lt;p&gt;However, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; delivers presents to &lt;code&gt;2&lt;/code&gt; houses: one at the starting location, and one to the east.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; delivers presents to &lt;code&gt;4&lt;/code&gt; houses in a square, including twice to the house at his starting/ending location.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; delivers a bunch of presents to some very lucky children at only 2 houses.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;This problem seems pretty simple on the face of it, but let&amp;rsquo;s break it down. We
will need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input from the file&lt;/li&gt;
&lt;li&gt;Iterate over the input&lt;/li&gt;
&lt;li&gt;Track which locations have been visited&lt;/li&gt;
&lt;li&gt;Count the visited locations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to track the location, we&amp;rsquo;ll need to use a slightly more advanced data
structure. Since we are working with quantities in 2D space, a 2D array makes
sense. Thankfully, in newer versions of the C standard, the array sizes do not
need to be known at compile time, so we can avoid some messy pointer arithmetic.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get to work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this looks familiar, you&amp;rsquo;re catching on. We check that the filename is
provided, read the input file to memory, and handle any errors.&lt;/p&gt;

&lt;p&gt;Now we&amp;rsquo;re ready to get started&amp;hellip; but are we? We still have no idea how big
our grid array needs to be. We could guess, but we run the danger of either
making the arrays too small and going out-of-bounds, or making them too big and
unnecessarily tying up memory. The better plan would be to iterate over the
input and test the constraints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After printing our preamble, we&amp;rsquo;ll create tracking variables for the current x
and y positions, and the minimum and maximums of both. We&amp;rsquo;ll initialize all of
them to zero, and then iterate over the input, adjusting the current value of
x and y and keeping the maximums and minimums updated as needed. Once the loop
is complete, we have enough information to compute the sizes of the arrays. Note
that we need to add 1 to the total; e.g. &lt;code&gt;1 - (-1) = 2&lt;/code&gt;, but that covers the
values &lt;code&gt;-1, 0, 1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the grid and travel again */
    bool grid[w][h];
    memset(grid, 0, w * h * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the sizes, we can declare the two-dimensional array. Again,
older versions of the C standard do not allow runtime determination of the array
sizes for stack declarations; if you are stuck using an old version, you will
need to allocate the array on the heap with &lt;code&gt;malloc&lt;/code&gt; or the like. Since we only
need to track if a house has been visited or not, we&amp;rsquo;ll use the &lt;code&gt;bool&lt;/code&gt; data type
for our grid. The more astute reader might know that &lt;code&gt;bool&lt;/code&gt; is still represented
with a full byte in C, but we can still use the type as a hint to those who
might read your code as to the function.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve declared the array, we will need to initialize it; while we can
declare the array in this fashion now, we still cannot initialize it at
declaration. We&amp;rsquo;ll use the &lt;code&gt;memset&lt;/code&gt; function to zero out the allocated arrays.
This is safe with our &lt;code&gt;bool&lt;/code&gt; data type as &lt;code&gt;false&lt;/code&gt; is represented as 0.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll set our initial indices for x and y for the upcoming run. Since
we cannot have negative indices in an array, we&amp;rsquo;ll need to offset them using the
minimum values previously found.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    grid[x][y] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }
        grid[x][y] = true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re finally ready to gather our data. We&amp;rsquo;ll iterate through the input again,
flipping the value on the grid to true as we visit each space. Notice that we
set the origin space to &lt;code&gt;true&lt;/code&gt; as well per the problem parameters (&lt;code&gt;He begins by delivering a present to the house at his starting location...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve completed the loop, we can count the houses by iterating through the
grid and incrementing a counter for each set of coordinates that is true. The
ternary operator is used as a shortcut here.&lt;/p&gt;

&lt;p&gt;Once we submit our solution, the second problem appears:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The next year, to speed up the process, Santa creates a robot version of himself, &lt;strong&gt;Robo-Santa&lt;/strong&gt;, to deliver presents with him.&lt;/p&gt;

&lt;p&gt;Santa and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.&lt;/p&gt;

&lt;p&gt;This year, how many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^v&lt;/code&gt; delivers presents to &lt;code&gt;3&lt;/code&gt; houses, because Santa goes north, and then Robo-Santa goes south.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; now delivers presents to &lt;code&gt;3&lt;/code&gt; houses, and Santa and Robo-Santa end up back where they started.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; now delivers presents to &lt;code&gt;11&lt;/code&gt; houses, with Santa going one direction and Robo-Santa going the other.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we read, the difference here is that we have a second &amp;ldquo;Santa&amp;rdquo;, and they
alternate directions in the input, rather than one taking all the directions.
This means we will need to implement a toggle, as well as keep two sets of
coordinates on the same grid. As with previous answers, I chose to integrate
this solution into the original problem rather than writing a completely new
set of code to solve problem 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];

        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to the single &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; value for the first problem, I declare
a two-element array to represent the coordinates of both santas for the second
problem. I alse declare and initialize another set of min/max variables.
Finally, a variable is declared to act as a toggle between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now to find our coordinates, we run through the loop. We increment the x and y
of the appropriate Santa, and check that against the x and y minimums and
maximums for the second grid (remember, both Santas share the grid, so there
is only one set of mins and maxes). We&amp;rsquo;ll update the values for the second grid
based on the active Santa, and then once all values have been updated, we use
the bitwise XOR assignment operator to flip the toggle value. Once the loop is
complete, we calculate the width and height of the second grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The grid creation for the second problem is identical to the first problem. The
only difference comes in assigning the initial coordinates; this needs to be
done for both Santas for the second problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During the second iteration of the input, we&amp;rsquo;ll toggle the Santa as we did
during the range finding iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll count the number of visited houses for the second grid, exactly
as we did the first grid.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll free our allocated input array for completeness and return
success:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All together now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];
        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;

    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;

    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }

    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);

    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 2: I Was Told There Would Be No Math</title>
      <link>/post/advent-2015-c-2/</link>
      <pubDate>Mon, 09 Sep 2019 02:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-2/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m going to go ahead and do a second puzzle today since the early ones are
relatively simple. Day 1&amp;rsquo;s puzzles were mostly incrementing, decrementing and
tracking variables; Day 2&amp;rsquo;s have a bit more math involved.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.&lt;/p&gt;

&lt;p&gt;Fortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is &lt;code&gt;2*l*w + 2*w*h + 2*h*l&lt;/code&gt;. The elves also need a little extra paper for each present: the area of the smallest side.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2*6 + 2*12 + 2*8 = 52&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;6&lt;/code&gt; square feet of slack, for a total of &lt;code&gt;58&lt;/code&gt; square feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;2*1 + 2*10 + 2*10 = 42&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;1&lt;/code&gt; square foot of slack, for a total of &lt;code&gt;43&lt;/code&gt; square feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All numbers in the elves&amp;rsquo; list are in feet. How many total &lt;strong&gt;square feet of wrapping paper&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we&amp;rsquo;re going to take a minute to break the problem down. As the
problem states, the input is formatted as XXxYYxZZ, so we will need to parse
the input into usable numbers. Since we need to operate on the smallest
dimensions for the slack, we&amp;rsquo;ll need to be able to sort the inputted values.
Finally, we&amp;rsquo;ll need to do the math and keep a running total.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dig in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preamble to our function is identical to day 1, with the exception of
initializing our return value early as we&amp;rsquo;ll be using our &lt;code&gt;goto&lt;/code&gt; short circuit
pattern to handle some later potential errors. We check that the user provided a
filename and read the file into the &lt;code&gt;input&lt;/code&gt; buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll then print our daily header and initialize the running total for the
wrapping paper.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start getting into some more interesting string handling. Note that the
input has one present per line, so we need to effectively split the string on
the lines. We will use the POSIX &lt;code&gt;strsep&lt;/code&gt; function for this. There is a similar
&lt;code&gt;strtok&lt;/code&gt; function in the C standard librory, but it has the downside of being
non-reentrant. If portability is a concern, you may want to stick use &lt;code&gt;strtok&lt;/code&gt;,
however &lt;code&gt;strsep&lt;/code&gt; is widely supported and should  be used instead of &lt;code&gt;strtok&lt;/code&gt;
wherever possible.&lt;/p&gt;

&lt;p&gt;In order to avoid changing the original value of the pointer to the input, we
make a copy into &lt;code&gt;cursor&lt;/code&gt; which becomes the moving pointer passed as the first
argument of &lt;code&gt;strsep&lt;/code&gt;. Finally, we are splitting on the newline character &lt;code&gt;\n&lt;/code&gt;.
We will not bother to make a copy of the input buffer as we only need to parse
it once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One side effect of &lt;code&gt;strsep&lt;/code&gt; that one needs to be aware of is that if multiple
delimiters are encountered in a row, &lt;code&gt;strsep&lt;/code&gt; will return a pointer to an empty
string instead of consuming all of the delimiters at once. We check for the
empty string and short-circuit the loop if we encounter this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now initialize an array of three &lt;code&gt;int&lt;/code&gt;s to hold the parsed values. We use an
array instead of separate variables because we will need to sort the result.
Once the array is initialized, we use the &lt;code&gt;sscanf&lt;/code&gt; function to scan the
dimensions into the array. As we are not trying to scan &lt;em&gt;into&lt;/em&gt; string variables,
&lt;code&gt;sscanf&lt;/code&gt; is perfectly safe for our usage. As an error check, we will
short-circuit to the function cleanup if we have an invalid line which scans
less than three values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        qsort(dims, 3, sizeof(int), cmp_int_asc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the values are scanned, they need to be sorted so that we can find the
slack using the smallest side. For this we use the standard library function
&lt;code&gt;qsort&lt;/code&gt; with a simple comparator function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int cmp_int_asc(const void *a, const void *b)
{
    int l = *(const int *)a;
    int r = *(const int *)b;

    return l &amp;lt; r ? -1 : l &amp;gt; r ? 1 : 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The comparator dereferences and casts the inputs and then returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a &amp;lt; 
b&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if they are equal. I use the ternary operator here
for conciseness, but I would refrain from using it for anything more complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have our values and we have them sorted by smallest to largest, we
just need to do the math and update our running total. As noted in the problem,
for each present we need to add the area of each side plus the area of the
smallest side as slack: &lt;code&gt;2xy + 2yz + 2xz + xy&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have broken out of the input parsing loop, &lt;code&gt;paper&lt;/code&gt; should have the total
required wrapping paper. We can print the solution and then proceed with
cleanup. As noted in day 1, freeing &lt;code&gt;input&lt;/code&gt; is not strictly necessary in this
case but is good from a habit-forming perspective.&lt;/p&gt;

&lt;p&gt;Once the solution has been input, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.&lt;/p&gt;

&lt;p&gt;The ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don&amp;rsquo;t ask how they tie the bow, though; they&amp;rsquo;ll never tell.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2+2+3+3 = 10&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;2*3*4 = 24&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;34&lt;/code&gt; feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;1+1+1+1 = 4&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;1*1*10 = 10&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;14&lt;/code&gt; feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many total &lt;strong&gt;feet of ribbon&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we already have all of the infrastructure present to handle this
new problem. We&amp;rsquo;ll add a new variable to track the running total of ribbon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int paper = 0;
    int ribbon = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the total ribbon on each loop, following the instructions to add
&lt;code&gt;2x+2y+xyz&lt;/code&gt; to the total:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll print the second solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it&amp;rsquo;s all put together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
    int ribbon = 0;

    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }

        qsort(dims, 3, sizeof(int), cmp_int_asc);

        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, this program will pass all Valgrind checks and does not leak memory.&lt;/p&gt;

&lt;p&gt;Suggestions, questions, and criticism welcome! Comments can be added below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 1: Not Quite Lisp</title>
      <link>/post/advent-2015-c-1/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-1/</guid>
      <description>&lt;p&gt;Yesterday, I talked in general about what I am trying to accomplish with this
series, and wrote a reusable function to read the input files into memory, which
will be used frequently throughout the series. Now it&amp;rsquo;s time to dig in.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa was hoping for a white Christmas, but his weather machine&amp;rsquo;s &amp;ldquo;snow&amp;rdquo; function is powered by stars, and he&amp;rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.&lt;/p&gt;

&lt;p&gt;Collect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an easy puzzle to warm you up.&lt;/p&gt;

&lt;p&gt;Santa is trying to deliver presents in a large apartment building, but he can&amp;rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.&lt;/p&gt;

&lt;p&gt;An opening parenthesis, &lt;code&gt;(&lt;/code&gt;, means he should go up one floor, and a closing parenthesis, &lt;code&gt;)&lt;/code&gt;, means he should go down one floor.&lt;/p&gt;

&lt;p&gt;The apartment building is very tall, and the basement is very deep; he will never find the top or bottom  floors.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(())&lt;/code&gt; and &lt;code&gt;()()&lt;/code&gt; both result in floor &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(((&lt;/code&gt; and &lt;code&gt;(()(()(&lt;/code&gt; both result in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;))(((((&lt;/code&gt; also results in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;())&lt;/code&gt; and &lt;code&gt;))(&lt;/code&gt; both result in floor &lt;code&gt;-1&lt;/code&gt; (the first basement level).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)))&lt;/code&gt; and &lt;code&gt;)())())&lt;/code&gt; both result in floor &lt;code&gt;-3&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To &lt;strong&gt;what floor&lt;/strong&gt; do the instructions take Santa?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before we start writing code, let&amp;rsquo;s think about what needs to happen. We will
need to input a file, read through it, determine which characters are important
(&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) and adjust the floor number accordingly. Then we&amp;rsquo;ll need to output
our solution somehow.&lt;/p&gt;

&lt;p&gt;Generally speaking, each day&amp;rsquo;s puzzle will be its own executable and the input
filename will be a command-line argument.&lt;/p&gt;

&lt;p&gt;Now that we have a plan of attack, let&amp;rsquo;s dig in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First things first, let&amp;rsquo;s check and make sure the user actually provided a
filename. Don&amp;rsquo;t forget that &lt;code&gt;argv[0]&lt;/code&gt; is always the name of the invoked command,
so &lt;code&gt;argc&lt;/code&gt; must be at least &lt;code&gt;2&lt;/code&gt; if the user has provided any arguments at all. If
the argument is not present, we&amp;rsquo;ll print a useful error message to &lt;code&gt;stderr&lt;/code&gt; and
return from &lt;code&gt;main&lt;/code&gt; with a non-zero code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that input file function we wrote yesterday? Now we get to use it. We
declare a pointer to the buffer and pass it into the function, along with the
filename which should be in &lt;code&gt;argv[1]&lt;/code&gt;. If the file doesn&amp;rsquo;t exist, isn&amp;rsquo;t
readable, or any other problem that we handled in the function, it will return
&lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;errno&lt;/code&gt; will be set. In that case, we print the error message to
&lt;code&gt;stderr&lt;/code&gt; and return non-zero. If everything worked, the contents of the file
are now in the location in memory pointed to by our &lt;code&gt;input&lt;/code&gt; pointer. Once we&amp;rsquo;ve
successfully read the file, we&amp;rsquo;ll print our header line for the output.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to solve the problem. The most straightforward way is going to be
to iterate over the contents of the file in memory byte-by-byte and adjust the
floor accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the first puzzle */
    int floor = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We initialize our floor variable to zero as noted in the problem description
(&lt;code&gt;He starts on the ground floor (floor 0)...&lt;/code&gt;), and then construct a &lt;code&gt;for&lt;/code&gt; loop
with the index starting at &lt;code&gt;0&lt;/code&gt; (remember, C arrays are zero-indexed) and
incrementing by one until we reach the file size which was returned by our file
input function. During each iteration of the loop, we check the byte at that
index and either increment or decrement the floor number depending on the
character. In this case, I have chosen to ignore any spurious characters that
may be in the input.&lt;/p&gt;

&lt;p&gt;The object of the problem is to determine which floor we arrive at (&lt;code&gt;To what 
floor do the instructions take Santa?&lt;/code&gt;), so the value of the &lt;code&gt;floor&lt;/code&gt; variable
is our solution.&lt;/p&gt;

&lt;p&gt;Once we input our solution, a second problem appears!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, given the same instructions, find the &lt;strong&gt;position&lt;/strong&gt; of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()())&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;5&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What is the &lt;strong&gt;position&lt;/strong&gt; of the character that causes Santa to first enter the basement?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the interest of saving compute time and code, we will attempt to integrate
the finding of the second solution into the original code. In this case, it&amp;rsquo;s
a matter of finding the index where we first hit floor &lt;code&gt;-1&lt;/code&gt;. We can do this by
setting a variable to a known bad value, and checking whether it has been reset
to a known good value and if not, setting it. So, we&amp;rsquo;ll update our problem logic
as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the puzzles */
    int floor = 0;
    int basement = -1;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == -1)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this updated logic, we set &lt;code&gt;basement&lt;/code&gt; to a sentinel value of &lt;code&gt;-1&lt;/code&gt;; since we
are counting up, the value cannot possibly be negative. Then, in each iteration
of the loop, we check for the floor to be &lt;code&gt;-1&lt;/code&gt; (since we can only move one
floor at a time) and for the basement value to be the sentinel. For those of
you counting instructions, notice that the floor check will short-circuit; i.e.
the basement check will not happen unless the floor is &lt;code&gt;-1&lt;/code&gt;. The net effect is
that on average we are only adding one instruction per loop. Also notice that
we set the value of basement to &lt;code&gt;i + 1&lt;/code&gt; as the positions are one-indexed per
the problem parameters (&lt;code&gt;The first character in the instructions has position 
1...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have solved the problem, we&amp;rsquo;ll clean up and return &lt;code&gt;0&lt;/code&gt;. Note that it
is not strictly necessary to free &lt;code&gt;input&lt;/code&gt;, but it is a good habit to be in.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the whole program for day 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);

    /* solve the puzzles */
    int floor = 0;
    int basement = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == 0)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);

    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program makes proper error checks and manages memory properly, and will
pass all Valgrind checks in a variety of test scenarios.&lt;/p&gt;

&lt;p&gt;If I&amp;rsquo;ve done something horribly wrong or you have questions, please comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code deep dive kickoff</title>
      <link>/post/advent-setup-c/</link>
      <pubDate>Sun, 08 Sep 2019 22:00:00 +0000</pubDate>
      
      <guid>/post/advent-setup-c/</guid>
      <description>&lt;p&gt;In the first technical article for this iteration of the site, I&amp;rsquo;d like to turn
to &lt;a href=&#34;https://adventofcode.com&#34; target=&#34;_blank&#34;&gt;Advent of Code&lt;/a&gt;. These are programming problems
built around a fun Christmas-themed storyline each year. I especially appreciate
that the problems are language-agnostic, so I frequently turn to some of the
easier ones when I&amp;rsquo;m getting familiar with a new language.&lt;/p&gt;

&lt;p&gt;It can be easy to throw together just enough code to make the puzzle work, but
I thought I&amp;rsquo;d revisit these problems from a different angle, looking not only
at how to solve the problem, but how to write high-quality code, including error
handling and memory management. In order to up the challenge, the solutions will
be written in C, and the code will pass all Valgrind tests for memory leaks and
other issues. All code discussed in these posts will be in my &lt;a href=&#34;https://github.com/e3b0c442/advent&#34; target=&#34;_blank&#34;&gt;Advent of Code
solutions repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To kick things off, we&amp;rsquo;ll take a look at code reuse. When you&amp;rsquo;re quickly
prototyping or problem solving, you&amp;rsquo;re frequently going to have identical
snippets of code in multiple places. If we&amp;rsquo;re writing high-quality code, we want
to avoid this wherever possible. One common theme throughout the Advent of Code
problems will be reading an input file into memory. In order to avoid writing
the same code over and over, we&amp;rsquo;re going to start things off by writing a
function to read a file into a memory buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already, just in the function signature, we are making design decisions. We
could have written the function to return the pointer to the memory buffer, and
in most languages this makes the most sense. However, in C, the length of an
array is not an integral part of the data type, so we need to pass that
information back as well. Therefore, I made the decision to pass a pointer to
pointer to char (array) to the function, which will be modified in the function
with the actual pointer to the allocated buffer, and to return the size of the
buffer in the return value (or -1 if there is an error). We use this pattern
rather than passing in the buffer itself because we do not know ahead of time
how the buffer needs to be sized. The caller will be responsible for freeing the
buffer when they are done using it.&lt;/p&gt;

&lt;p&gt;Now, lets think about what actually needs to happen to read a file into memory,
and what can go wrong.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Does the file exist? Is it a valid, readable file?&lt;/li&gt;
&lt;li&gt;How big is the file; consequently, how big does my buffer need to be?&lt;/li&gt;
&lt;li&gt;What happens if we don&amp;rsquo;t succeed in reading the actual data?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can see, when reading a file, there are a lot of potential failure
points. Keeping that in mind, let&amp;rsquo;s start writing our code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we do is initialize variables that will exist for the life of
the function (and be part of the cleanup). &lt;code&gt;rval&lt;/code&gt; will hold our return value,
&lt;code&gt;f&lt;/code&gt; will hold our file pointer, and &lt;code&gt;*buf&lt;/code&gt; is the pointer to the buffer that
will hold the file contents, which is passed in as a parameter. Each is
initialized to a sane default, as variables are not automatically initialized
in C.&lt;/p&gt;

&lt;p&gt;With that out of the way, we&amp;rsquo;ll make our first check. Using the POSIX &lt;code&gt;stat&lt;/code&gt;
function, we query the file for information. Right off the bat, this will tell
us if the file exists; if it does not, &lt;code&gt;stat&lt;/code&gt; will return &lt;code&gt;-1&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;
accordingly. If we see this, we will jump to our error cleanup.&lt;/p&gt;

&lt;p&gt;At this point, I&amp;rsquo;m going to take a sidebar and talk a bit about &lt;code&gt;goto&lt;/code&gt;. For most
programmers, there&amp;rsquo;s a knee-jerk reaction to avoid &lt;code&gt;goto&lt;/code&gt; at all costs.
Generally, I agree with this with one exception: &lt;em&gt;error cleanup.&lt;/em&gt; In this case,
&lt;code&gt;goto&lt;/code&gt; properly used provides an avenue to short-circuit function execution and
provide for cleanup in the case of an error without reusing the same code.&lt;/p&gt;

&lt;p&gt;If the file exists, the &lt;code&gt;struct stat&lt;/code&gt; will be populated with information about
the file, including the type and size. Continuing on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our next check is that we are working with a regular file, as opposed to a
directory, block device, or other file type. (note: &lt;code&gt;stat&lt;/code&gt; follows symlinks!).
We use the &lt;code&gt;S_ISREG&lt;/code&gt; macro to accomplish this. Because this is a check and not
necessarily an error condition, if the provided file is not a regular file we
will set &lt;code&gt;errno&lt;/code&gt; ourselves to indicate an invalid parameter and then jump to our
error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL) 
        goto err_cleanup; /* errno is set by fopen() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the file exists, and that it&amp;rsquo;s a regular file, we will try to
open it for reading. If the file is not readable for any reason, &lt;code&gt;fopen&lt;/code&gt; will
return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; appropriately. We will check for the &lt;code&gt;NULL&lt;/code&gt;
return value and short-circuit as needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve successfully opened the file, we&amp;rsquo;ll allocate the buffer. Even
though we already had the size information from the &lt;code&gt;stat&lt;/code&gt; call, I&amp;rsquo;ve chosen
not to allocate the buffer until we know the file is readable, to avoid
unnecessary allocations. For this problem it doesn&amp;rsquo;t really matter, but it&amp;rsquo;s
a good habit to be in. If there is an error allocating the buffer such as
running out of memory, &lt;code&gt;malloc&lt;/code&gt; will return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;; again we
will check for this and short-circuit the function as necessary. I&amp;rsquo;m using
&lt;code&gt;malloc&lt;/code&gt; instead of &lt;code&gt;calloc&lt;/code&gt; because we have designed the function such that the
buffer will be completely filled by the file, negating the need to initialize
it. The extra +1 is to make room for a null terminator so that we may treat the
buffer as a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we perform the actual read. &lt;code&gt;fread&lt;/code&gt; is a buffered read which calls the
low-level &lt;code&gt;read&lt;/code&gt; syscall, and as such it will block until the requested size
is read unless there is an error, allowing us to avoid need to loop until the
expected data is read. Instead, we will check to make sure the expected size
of data is read (the file size) and check for an error if it is not. If there
is an error reading the file, we&amp;rsquo;ll short-circuit to our error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We finish up the logic of our function by setting the extra allocated byte at
the end of the buffer to a null terminator, then set the return value to the
amount of data read, and finally jumping to our non-error cleanup. Array
indeces have a higher precedence than the indirection operator, so we need to
enclose the indirection in parentheses to avoid writing to the wrong memory
address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for our cleanup. There are two things that need to be cleaned up in this
function: first, the file needs to be closed if it was opened, to avoid file
handle leaks. Also, if there was an error, the data buffer needs to be freed
if it was allocated and the pointer set to NULL. Finally, if we did error,
we set &lt;code&gt;rval&lt;/code&gt; to -1 which indicates the error to the caller, who can then get
more information by inspecting &lt;code&gt;errno.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The whole function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */

    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL)
        goto err_cleanup; /* errno is set by fopen() */

    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */

    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;

    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;

err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve now written a function with appropriate error checking that can be reused
throughout our Advent of Code exercises!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
