<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on e3b0c442.io</title>
    <link>/tags/programming/</link>
    <description>Recent content in Programming on e3b0c442.io</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advent of Code 2015 Day 6: Probably a Fire Hazard</title>
      <link>/post/advent-2015-c-6/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-6/</guid>
      <description>&lt;p&gt;Welcome back to my Advent of Code series. I hope you&amp;rsquo;re enjoying exploring these
problems in depth in C. Let&amp;rsquo;s take a look at the problem for day 6:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because your neighbors keep defeating you in the holiday house decorating contest year after year, you&amp;rsquo;ve decided to deploy one million lights in a 1000x1000 grid.&lt;/p&gt;

&lt;p&gt;Furthermore, because you&amp;rsquo;ve been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.&lt;/p&gt;

&lt;p&gt;Lights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at &lt;code&gt;0,0&lt;/code&gt;, &lt;code&gt;0,999&lt;/code&gt;, &lt;code&gt;999,999&lt;/code&gt;, and &lt;code&gt;999,0&lt;/code&gt;. The instructions include whether to &lt;code&gt;turn on&lt;/code&gt;, &lt;code&gt;turn off&lt;/code&gt;, or &lt;code&gt;toggle&lt;/code&gt; various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like &lt;code&gt;0,0 through 2,2&lt;/code&gt; therefore refers to 9 lights in a 3x3 square. The lights all start turned off.&lt;/p&gt;

&lt;p&gt;To defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 999,999&lt;/code&gt; would turn on (or leave on) every light.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,0&lt;/code&gt; would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;turn off 499,499 through 500,500&lt;/code&gt; would turn off (or leave off) the middle four lights.&lt;/li&gt;
&lt;li&gt;After following the instructions, &lt;strong&gt;how many lights are lit&lt;/strong&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s look at our constituent problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Set up a grid&lt;/li&gt;
&lt;li&gt;Parse the input lines&lt;/li&gt;
&lt;li&gt;Follow the input instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We already know how to read our file into memory, so we&amp;rsquo;ll move onto setting up
the grid. As with &lt;a href=&#34;/post/advent-2015-c-3/&#34; target=&#34;_blank&#34;&gt;Day 3&lt;/a&gt;, we will use a
two-dimensional array to represent the grid. Unlike day 3, we know in advance
what the size of the grid is, so we don&amp;rsquo;t need to do an extra loop to size it;
we can just declare &lt;code&gt;bool grid[1000][1000]&lt;/code&gt;, initialize, and move on.&lt;/p&gt;

&lt;p&gt;Likewise, parsing the input lines is also a situation we have previously
encountered. In previous days, we have used &lt;a href=&#34;/post/advent-2015-c-2/&#34; target=&#34;_blank&#34;&gt;scanners&lt;/a&gt; and &lt;a href=&#34;/post/advent-2015-c-5/&#34; target=&#34;_blank&#34;&gt;regular expressions&lt;/a&gt;. While using scanners is ideal for simple situations,
we have to remember the downsides: scanners are tokenized by any whitespace, and
scanners cannot safely be used to scan into strings. Both of these cases are
disqualifiers for our input; we have a component of the input that might have a
space in it, and we also need to scan into a string. For this reason, we&amp;rsquo;ll use
regular expressions to parse our input. Because we can only parse into strings
with regular expressions, we will also need to convert our number strings to
numerical values.&lt;/p&gt;

&lt;p&gt;Once we have our values, we can use them to set up a nested loop to update the
values on the grid.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 6:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is our now familiar check for argument, read input, and print preamble,
included only for completeness at this point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t inst_r;
    int result = regcomp(&amp;amp;inst_r, &amp;quot;\\(turn on\\|turn off\\|toggle\\) \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\) through \\([[:digit:]]\\{1,\\}\\),\\([[:digit:]]\\{1,\\}\\)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we compile the regular expression to match against. Without the escape
characters, this expression looks like: &lt;code&gt;(turn on|turn off|toggle) ([[:digit:]]{1,}),([[:digit:]]{1,}) through ([[:digit:]]{1,}),([[:digit:]]{1,})&lt;/code&gt;.
Reading this expression aloud, we get &lt;em&gt;Capture a group containing &amp;ldquo;turn on&amp;rdquo;,
&amp;ldquo;turn off&amp;rdquo;, or &amp;ldquo;toggle&amp;rdquo;. Find a space. Capture a group of one or more digits,
then find a comma, then capture a group of one or more digits. Find the phrase
&amp;ldquo; through &amp;ldquo;. Capture a group of one or more digits, then find a comma, then
capture a group of one or more digits.&lt;/em&gt; At the end of it, we have captured five submatches; one for the command, and then one each for the low and high X and Y coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now prepare to start our loop. We create the cursor variable and get the
first line, declare an array to hold the regular expression match coordinates
and initialize it, and declare and initialize the grid array. Note that we use
&lt;code&gt;memset&lt;/code&gt; for the grid array because the &lt;code&gt;{0}&lt;/code&gt; initialization shorthand cannot be
used with multidimensional arrays. Also note that we declared a six member array
for the regular expression matches; the first match is always the full matched
string, so we need room for this plus the five submatches that we actually care
about.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 6 * sizeof(regmatch_t));
        result = regexec(&amp;amp;inst_r, line, 6, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char instr[9] = {0};
        char oxs[4] = {0};
        char oys[4] = {0};
        char dxs[4] = {0};
        char dys[4] = {0};

        strncpy(instr, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(oxs, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);
        strncpy(oys, line + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        strncpy(dxs, line + matches[4].rm_so, matches[4].rm_eo - matches[4].rm_so);
        strncpy(dys, line + matches[5].rm_so, matches[5].rm_eo - matches[5].rm_so);

        unsigned long ox = strtoul(oxs, NULL, 10);
        if (ox == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long oy = strtoul(oys, NULL, 10);
        if (oy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dx = strtoul(dxs, NULL, 10);
        if (dx == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;
        unsigned long dy = strtoul(dys, NULL, 10);
        if (dy == 0 &amp;amp;&amp;amp; errno == EINVAL)
            goto err_cleanup;

        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = true;
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = false;
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                    grid[x][y] = !grid[x][y];
        }
        else
        {
            goto err_cleanup;
        }

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we perform our loop on each of the input lines, parsing and following the
directions. We&amp;rsquo;ll zero out the match array, then execute the compiled regular
expression against the input line. We then initialize destination variables for
each of the five submatch values, and use the match coordinates to copy the
matched substrings into the destination variables.&lt;/p&gt;

&lt;p&gt;Once the destination variables are populated, we&amp;rsquo;ll use &lt;code&gt;strtoul&lt;/code&gt; to parse the
four numerical values into integral equivalents, giving us the final set of
parsed values to handle our input.&lt;/p&gt;

&lt;p&gt;At this point, we use strcmp to compare the instruction string against the known
instructions, and then set up a nested loop using the X and Y values. Finally,
the interior of the loop sets the value of that coordinate per the instruction.
You&amp;rsquo;ll notice that we parsed the instruction first, requiring the loop to be
specified multiple times, seemingly breaking the &lt;em&gt;don&amp;rsquo;t-repeat-yourself&lt;/em&gt; rule.
In this case, however, this is justified, as if we reversed things, the string
comparison would need to be done for each position, which would be prohibitvely
computationally expensive. Once the loop is complete, the values of the grid
are set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
            if (grid[x][y])
                on++;

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get our solution, we set up a counter variable and then another
nested loop over the entire two-dimensional surface. Each time we encounter
a &lt;code&gt;true&lt;/code&gt; value, we increment the counter. We then print our solution.&lt;/p&gt;

&lt;p&gt;After submitting the solution, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You just finish implementing your winning light pattern when you realize you mistranslated Santa&amp;rsquo;s message from Ancient Nordic Elvish.&lt;/p&gt;

&lt;p&gt;The light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn on&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;turn off&lt;/code&gt; actually means that you should decrease the brightness of those lights by &lt;code&gt;1&lt;/code&gt;, to a minimum of zero.&lt;/p&gt;

&lt;p&gt;The phrase &lt;code&gt;toggle&lt;/code&gt; actually means that you should increase the brightness of those lights by &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What is the &lt;strong&gt;total brightness&lt;/strong&gt; of all lights combined after following Santa&amp;rsquo;s instructions?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn on 0,0 through 0,0&lt;/code&gt; would increase the total brightness by 1.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toggle 0,0 through 999,999&lt;/code&gt; would increase the total brightness by 2000000.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with previous problems, this one is simalar, and we can implement it in the
existing loop to avoid the need to loop the input a second time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[6] = {0};
    bool grid[1000][1000];
    int grid2[1000][1000];
    memset(grid, 0, 1000 * 1000 * sizeof(bool));
    memset(grid2, 0, 1000 * 1000 * sizeof(int));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will declare a second grid variable, this time of type &lt;code&gt;int[][]&lt;/code&gt;, since we
need to track more than just on or off.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (strcmp(&amp;quot;turn on&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = true;
                    grid2[x][y]++;
                }
        }
        else if (strcmp(&amp;quot;turn off&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = false;
                    grid2[x][y] = grid2[x][y] &amp;gt; 0 ? grid2[x][y] - 1 : 0;
                }
        }
        else if (strcmp(&amp;quot;toggle&amp;quot;, instr) == 0)
        {
            for (int x = ox; x &amp;lt;= dx; x++)
                for (int y = oy; y &amp;lt;= dy; y++)
                {
                    grid[x][y] = !grid[x][y];
                    grid2[x][y] += 2;
                }
        }
        else
        {
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The instructions are equivalent for both loops; we just need to add the
application of the instructions to the second grid following the second
transation&amp;rsquo;s directions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int on = 0;
    int bright = 0;
    for (int x = 0; x &amp;lt; 1000; x++)
        for (int y = 0; y &amp;lt; 1000; y++)
        {
            if (grid[x][y])
                on++;
            bright += grid2[x][y];
        }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, on);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, bright);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll add a second counter variable and perform the addition during the same
nested loop as the first solution, and then print both solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    regfree(&amp;amp;inst_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we will clean up. As before, we need to call &lt;code&gt;regfree&lt;/code&gt; to free the
compiled regular expression in addition to freeing the input.&lt;/p&gt;

&lt;p&gt;Our problems are gradually getting more difficult, but we&amp;rsquo;re almost a week
through! Day seven&amp;rsquo;s solution requires implementing a new data structure, so our
next article will take a break to discuss this in detail.&lt;/p&gt;

&lt;p&gt;As always, comments, criticism, and banter are welcome, just leave a comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 5: Doesn&#39;t He Have Intern-Elves For This?</title>
      <link>/post/advent-2015-c-5/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-5/</guid>
      <description>&lt;p&gt;Welcome back! I feel refreshed after a few days, hopefully you do too. Today, we
are going to look at day 5:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa needs help figuring out which strings in his text file are naughty or nice.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;nice string&lt;/strong&gt; is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains at least three vowels (&lt;code&gt;aeiou&lt;/code&gt; only), like &lt;code&gt;aei&lt;/code&gt;, &lt;code&gt;xazegov&lt;/code&gt;, or &lt;code&gt;aeiouaeiouaeiou&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It contains at least one letter that appears twice in a row, like &lt;code&gt;xx&lt;/code&gt;, &lt;code&gt;abcdde&lt;/code&gt; (&lt;code&gt;dd&lt;/code&gt;), or &lt;code&gt;aabbccdd&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;bb&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt;, or &lt;code&gt;dd&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;It does &lt;strong&gt;not&lt;/strong&gt; contain the strings &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;pq&lt;/code&gt;, or &lt;code&gt;xy&lt;/code&gt;, even if they are part of one of the other requirements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ugknbfddgicrmopn&lt;/code&gt; is nice because it has at least three vowels (&lt;code&gt;u...i...o...&lt;/code&gt;), a double letter (&lt;code&gt;...dd...&lt;/code&gt;), and none of the disallowed substrings.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aaa&lt;/code&gt; is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jchzalrnumimnmhp&lt;/code&gt; is naughty because it has no double letter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;haegwjzuvuyypxyu&lt;/code&gt; is naughty because it contains the string &lt;code&gt;xy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dvszwmarrgswjxmb&lt;/code&gt; is naughty because it contains only one vowel.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s begin by breaking down the problem. We need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Split the input into its components&lt;/li&gt;
&lt;li&gt;Determine whether the string meets the naughty or nice requirements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first two parts of this problem are familiar, and generally speaking,
identical. We&amp;rsquo;ll use the variable &lt;code&gt;good&lt;/code&gt; to track the good strings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last part, however, is the most difficult problem that has yet been
presented. How are we going to check the strings?&lt;/p&gt;

&lt;p&gt;While it might be tempting to loop over the strings and implement tracking
variables to check these conditions (and, depending on the implementation, might
be faster), the more appropriate tool in this situation is regular expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the three rules can be checked using a valid POSIX basic regular
expression (note that in the code snippet above, the appropriate escape
characters have been added):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;at least 3 vowels: &lt;code&gt;[aeiou].*[aeiou].*[aeiou]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a letter a, e, i, o, or u. Then find
zero or more of any character, then a letter a,e,i,o,u, then zero or more of
any character, then a, e, i, o, or u.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;at least one letter that occurs twice in a row: &lt;code&gt;(.)\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression uses a backreference to refer to a prior character.
It says: &lt;em&gt;find a group containing any one character, then find the first
group&lt;/em&gt;. In this case, the first group is the matched one character.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;does not contain ab, cd, pq, xy: &lt;code&gt;(ab|cd|pq|xy)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;ll actually be looking for a negative result on this one because it is
simpler than trying to do the negation in the expression itself. This
expression says, &lt;em&gt;find the strings ab or cd or pq or xy&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We compile the expressions once to be used to quickly match the strings as we
loop through the input:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);

    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If rule 3 does not match (we put this one in front to short-circuit, since if
it matches the string is automatically invalid) and rules 1 and 2 match, then
the string is a good string. Note that this appears backwards due to &lt;code&gt;regexec&lt;/code&gt;
returning 0 on match and 1 on no match. We output the counted good strings for
our solution.&lt;/p&gt;

&lt;p&gt;Then, we just need to clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our solution submitted, we then get our second problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.&lt;/p&gt;

&lt;p&gt;Now, a nice string is one with all of the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It contains a pair of any two letters that appears at least twice in the string without overlapping, like &lt;code&gt;xyxy&lt;/code&gt; (&lt;code&gt;xy&lt;/code&gt;) or &lt;code&gt;aabcdefgaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;), but not like &lt;code&gt;aaa&lt;/code&gt; (&lt;code&gt;aa&lt;/code&gt;, but it overlaps).&lt;/li&gt;
&lt;li&gt;It contains at least one letter which repeats with exactly one letter between them, like &lt;code&gt;xyx&lt;/code&gt;, &lt;code&gt;abcdefeghi&lt;/code&gt; (&lt;code&gt;efe&lt;/code&gt;), or even &lt;code&gt;aaa&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qjhvhtzxzqqjkmpb&lt;/code&gt; is nice because is has a pair that appears twice (&lt;code&gt;qj&lt;/code&gt;) and a letter that repeats with exactly one letter between them (&lt;code&gt;zxz&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xxyxx&lt;/code&gt; is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uurcxstgmygtbstg&lt;/code&gt; is naughty because it has a pair (&lt;code&gt;tg&lt;/code&gt;) but no repeat with a single letter between them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ieodomkazucvgmuy&lt;/code&gt; is naughty because it has a repeating letter with one between (&lt;code&gt;odo&lt;/code&gt;), but no pair that appears twice.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many strings are nice under these new rules?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As expected, the problem is very similar, if slightly more complicated. The good
news is that these rules can also be checked with valid POSIX basic regular
expressions, so we can easily add the new rules to the existing loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two new rules are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pair of two letters that appear at least twice in the string without
overlapping: &lt;code&gt;(..).*\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with two of any character, then
find zero or more of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;one letter which repeats with exactly one letter between: &lt;code&gt;(.).\1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This regular expression says: &lt;em&gt;find a group with one of any character, then
find one of any character, then find the first group&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are again compiled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add a second check for the two new rules, with a separate counter, then print
the second result after the first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we clean up the new compiled regexes in addition to the previous ones.&lt;/p&gt;

&lt;p&gt;All together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rc = 0;
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 5:\n&amp;quot;);

    regex_t rule1, rule2, rule3, rule4, rule5;
    if (regcomp(&amp;amp;rule1, &amp;quot;[aeiou].*[aeiou].*[aeiou]&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule2, &amp;quot;\\(.\\)\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule3, &amp;quot;\\(ab\\|cd\\|pq\\|xy\\)&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule4, &amp;quot;\\(..\\).*\\1&amp;quot;, 0))
        goto err_cleanup;

    if (regcomp(&amp;amp;rule5, &amp;quot;\\(.\\).\\1&amp;quot;, 0))
        goto err_cleanup;

    int good = 0;
    int great = 0;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        if (regexec(&amp;amp;rule3, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule1, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule2, line, 0, NULL, 0))
            good++;

        if (!regexec(&amp;amp;rule4, line, 0, NULL, 0) &amp;amp;&amp;amp; !regexec(&amp;amp;rule5, line, 0, NULL, 0))
            great++;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, good);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, great);

    goto cleanup;

err_cleanup:
    rc = -1;
    printf(&amp;quot;badman\n&amp;quot;);
cleanup:
    regfree(&amp;amp;rule1);
    regfree(&amp;amp;rule2);
    regfree(&amp;amp;rule3);
    regfree(&amp;amp;rule4);
    regfree(&amp;amp;rule5);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just one instance where a problem that is potentially complex can be
simplified with regular expressions (note: this goes both ways!)&lt;/p&gt;

&lt;p&gt;As always, if you have questions, comments, or suggestions, feel free to leave
a comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 4: The Ideal Stocking Stuffer</title>
      <link>/post/advent-2015-c-4/</link>
      <pubDate>Tue, 10 Sep 2019 03:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-4/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m back for a second time today since this puzzle is fairly straightforward:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.&lt;/p&gt;

&lt;p&gt;To do this, he needs to find MD5 hashes which, in hexadecimal, start with at least &lt;strong&gt;five zeroes&lt;/strong&gt;. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &amp;hellip;) that produces such a hash.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If your secret key is &lt;code&gt;abcdef&lt;/code&gt;, the answer is &lt;code&gt;609043&lt;/code&gt;, because the MD5 hash of &lt;code&gt;abcdef609043&lt;/code&gt; starts with five zeroes &lt;code&gt;(000001dbbfa...&lt;/code&gt;), and it is the lowest such number to do so.&lt;/li&gt;
&lt;li&gt;If your secret key is &lt;code&gt;pqrstuv&lt;/code&gt;, the lowest number it combines with to make an MD5 hash starting with five zeroes is &lt;code&gt;1048970&lt;/code&gt;; that is, the MD5 hash of &lt;code&gt;pqrstuv1048970&lt;/code&gt; looks like &lt;code&gt;000006136ef...&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As always, we&amp;rsquo;ll start with breaking down the problem into discrete parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input&lt;/li&gt;
&lt;li&gt;Convert a number to a string&lt;/li&gt;
&lt;li&gt;Combine the input and the number string&lt;/li&gt;
&lt;li&gt;Get the MD5 digest of the combined string&lt;/li&gt;
&lt;li&gt;Check that the first five digits of the digest are &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rather than write our own MD5 hashing implementation, we will use the well-known
and commonly-installed OpenSSL library&amp;rsquo;s implementation. You&amp;rsquo;ll need to make
sure that your linker pulls in the OpenSSL library.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s write some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the sake of completion, this is our standard prelude of verifying the
command-line argument and reading the input file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 4:\n&amp;quot;);

    /* initialize variables */
    int i = 1;
    char buf[strlen(input) + 11];
    memset(buf, 0, strlen(input) + 11);
    strcpy(buf, input);
    unsigned char digest[16];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We print our preamble, then initialize some variables. Note that I&amp;rsquo;m doing this
outside of a loop so that we do not incur this cost in the loop. Our code will
be written in such a way that the variables do not need to be reinitialized on
every pass. Step by step we have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The declaration of the iteration index &lt;code&gt;i&lt;/code&gt;, which is the number that will be
added to the input string on each pass&lt;/li&gt;
&lt;li&gt;The declaration of the buffer which stores the whole string to be hashed. We
size from the input and then add 11 &amp;ndash; 10 for the maximum number of digits in a
32-bit integer, and 1 for the null terminator.&lt;/li&gt;
&lt;li&gt;The initialization of the string buffer. Ensuring all bytes are set to &lt;code&gt;0&lt;/code&gt; now
will help us not need to re-initialize the variable on every loop&lt;/li&gt;
&lt;li&gt;Copying the input into the buffer&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Creating a buffer for the MD5 digest. MD5 digests are 128 bits, so we need a
16-byte buffer. Note that we do &lt;em&gt;not&lt;/em&gt; have a null terminator here because this
is not a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we begin the loop. W se formatted print to append the string representation
of &lt;code&gt;i&lt;/code&gt; to the buffer. Notice that we are using pointer arithmetic to point to
the first index in the buffer after the original input string. Because the
numbers will only ever increase, we will overwrite this on each loop and not
need to reinitialize the variable. We then get the MD5 digest of the constructed
string.&lt;/p&gt;

&lt;p&gt;At this point, one might be tempted to use formatted print to output the
hexadecimal representation of the digest. &lt;em&gt;Don&amp;rsquo;t!&lt;/em&gt; String formatting operations
are computationally expensive, and we have the information we need to solve
the problem without doing it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] &amp;lt; 16)
            break;
        i++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the ratio of bytes to hex characters is 1:2; that is, each byte of the
digest would translate to two hex characters. With this in mind, remember that
this digest is just one big number; so, rather than convert the number back to
a string, let&amp;rsquo;s just check the number.&lt;/p&gt;

&lt;p&gt;We are searching for a digest where the first five digits of the hexadecimal
representation of the digest are &lt;code&gt;0&lt;/code&gt;. For bytes 0 and 1, this is easy: the value
of the byte must be 0. For byte 2, it requires a little bit more thought, since
only the first digit must be zero. In this case, it&amp;rsquo;s just a matter of places
like in decimal math. There are 16 possible hexadecimal digits, so any value
of the byte that is less than 16 will have the first hex digit as 0.&lt;/p&gt;

&lt;p&gt;By checking this way and avoiding the string conversion, we cut our compute
usage down by 10-100x, which is important in this exercise as hashing is not a
fast operation, relatively speaking.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have our solution, which is the current value of &lt;code&gt;i&lt;/code&gt;. Once this is
validated, our second puzzle appears:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now find one that starts with six zeroes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, that&amp;rsquo;s succinct, isn&amp;rsquo;t it? Literally all we need to do at this point is
resume the loop right where we left off, making one change: we can check that
byte 2 of the digest is equal to zero, rather than less than 16:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (1)
    {
        sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
        MD5((const unsigned char *)buf, strlen(buf), digest);

        if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] == 0)
            break;
        i++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t even need to reset &lt;code&gt;i&lt;/code&gt; here, since by definition a digest can&amp;rsquo;t start
with six zeroes without starting with five. In the circumstance that the first
digest that begins with five zeroes also begins with six zeroes, the first
iteration of our loop will catch it because we broke out of the previous loop
before incrementing the index, and we don&amp;rsquo;t increment until the end of the loop.&lt;/p&gt;

&lt;p&gt;We now have our solution, and can print it and clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, i);

    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we put it all together, we have:&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;c
#include &lt;errno.h&gt;
#include &lt;openssl/md5.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &amp;ldquo;common.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;int main(int argc, char const &lt;em&gt;argv[])
{
    /&lt;/em&gt; check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;ldquo;Must provide filename of input file\n&amp;rdquo;);
        return -1;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* read the file into memory */
char *input;
int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
if (filesize &amp;lt; 0)
{
    fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
    return -1;
}

printf(&amp;quot;Day 4:\n&amp;quot;);

/* initialize variables */
int i = 1;
char buf[strlen(input) + 11];
memset(buf, 0, strlen(input) + 11);
strcpy(buf, input);
unsigned char digest[16];

/* find the first matching digest */
while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);

    if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] &amp;lt; 16)
        break;
    i++;
}

printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, i);

/* find the first matching digest */
while (1)
{
    sprintf(buf + strlen(input), &amp;quot;%d&amp;quot;, i);
    MD5((const unsigned char *)buf, strlen(buf), digest);

    if (digest[0] == 0 &amp;amp;&amp;amp; digest[1] == 0 &amp;amp;&amp;amp; digest[2] == 0)
        break;
    i++;
}

printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, i);

free(input);
return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 3: Perfectly Spherical Houses in a Vacuum</title>
      <link>/post/advent-2015-c-3/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-3/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve made it this far, so either nobody&amp;rsquo;s reading this, you&amp;rsquo;re all masochists,
or I&amp;rsquo;m doing OK. Let&amp;rsquo;s take a look at day 3:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa is delivering presents to an infinite two-dimensional grid of houses.&lt;/p&gt;

&lt;p&gt;He begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (&lt;code&gt;^&lt;/code&gt;), south (&lt;code&gt;v&lt;/code&gt;), east (&lt;code&gt;&amp;gt;&lt;/code&gt;), or west (&lt;code&gt;&amp;lt;&lt;/code&gt;). After each move, he delivers another present to the house at his new location.&lt;/p&gt;

&lt;p&gt;However, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; delivers presents to &lt;code&gt;2&lt;/code&gt; houses: one at the starting location, and one to the east.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; delivers presents to &lt;code&gt;4&lt;/code&gt; houses in a square, including twice to the house at his starting/ending location.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; delivers a bunch of presents to some very lucky children at only 2 houses.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;This problem seems pretty simple on the face of it, but let&amp;rsquo;s break it down. We
will need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input from the file&lt;/li&gt;
&lt;li&gt;Iterate over the input&lt;/li&gt;
&lt;li&gt;Track which locations have been visited&lt;/li&gt;
&lt;li&gt;Count the visited locations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to track the location, we&amp;rsquo;ll need to use a slightly more advanced data
structure. Since we are working with quantities in 2D space, a 2D array makes
sense. Thankfully, in newer versions of the C standard, the array sizes do not
need to be known at compile time, so we can avoid some messy pointer arithmetic.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get to work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this looks familiar, you&amp;rsquo;re catching on. We check that the filename is
provided, read the input file to memory, and handle any errors.&lt;/p&gt;

&lt;p&gt;Now we&amp;rsquo;re ready to get started&amp;hellip; but are we? We still have no idea how big
our grid array needs to be. We could guess, but we run the danger of either
making the arrays too small and going out-of-bounds, or making them too big and
unnecessarily tying up memory. The better plan would be to iterate over the
input and test the constraints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After printing our preamble, we&amp;rsquo;ll create tracking variables for the current x
and y positions, and the minimum and maximums of both. We&amp;rsquo;ll initialize all of
them to zero, and then iterate over the input, adjusting the current value of
x and y and keeping the maximums and minimums updated as needed. Once the loop
is complete, we have enough information to compute the sizes of the arrays. Note
that we need to add 1 to the total; e.g. &lt;code&gt;1 - (-1) = 2&lt;/code&gt;, but that covers the
values &lt;code&gt;-1, 0, 1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the grid and travel again */
    bool grid[w][h];
    memset(grid, 0, w * h * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the sizes, we can declare the two-dimensional array. Again,
older versions of the C standard do not allow runtime determination of the array
sizes for stack declarations; if you are stuck using an old version, you will
need to allocate the array on the heap with &lt;code&gt;malloc&lt;/code&gt; or the like. Since we only
need to track if a house has been visited or not, we&amp;rsquo;ll use the &lt;code&gt;bool&lt;/code&gt; data type
for our grid. The more astute reader might know that &lt;code&gt;bool&lt;/code&gt; is still represented
with a full byte in C, but we can still use the type as a hint to those who
might read your code as to the function.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve declared the array, we will need to initialize it; while we can
declare the array in this fashion now, we still cannot initialize it at
declaration. We&amp;rsquo;ll use the &lt;code&gt;memset&lt;/code&gt; function to zero out the allocated arrays.
This is safe with our &lt;code&gt;bool&lt;/code&gt; data type as &lt;code&gt;false&lt;/code&gt; is represented as 0.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll set our initial indices for x and y for the upcoming run. Since
we cannot have negative indices in an array, we&amp;rsquo;ll need to offset them using the
minimum values previously found.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    grid[x][y] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            break;
        case &#39;v&#39;:
            y--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            break;
        case &#39;^&#39;:
            y++;
            break;
        default:;
        }
        grid[x][y] = true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re finally ready to gather our data. We&amp;rsquo;ll iterate through the input again,
flipping the value on the grid to true as we visit each space. Notice that we
set the origin space to &lt;code&gt;true&lt;/code&gt; as well per the problem parameters (&lt;code&gt;He begins by delivering a present to the house at his starting location...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve completed the loop, we can count the houses by iterating through the
grid and incrementing a counter for each set of coordinates that is true. The
ternary operator is used as a shortcut here.&lt;/p&gt;

&lt;p&gt;Once we submit our solution, the second problem appears:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The next year, to speed up the process, Santa creates a robot version of himself, &lt;strong&gt;Robo-Santa&lt;/strong&gt;, to deliver presents with him.&lt;/p&gt;

&lt;p&gt;Santa and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.&lt;/p&gt;

&lt;p&gt;This year, how many houses receive &lt;strong&gt;at least one present&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^v&lt;/code&gt; delivers presents to &lt;code&gt;3&lt;/code&gt; houses, because Santa goes north, and then Robo-Santa goes south.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&amp;gt;v&amp;lt;&lt;/code&gt; now delivers presents to &lt;code&gt;3&lt;/code&gt; houses, and Santa and Robo-Santa end up back where they started.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^v^v^v^v^v&lt;/code&gt; now delivers presents to &lt;code&gt;11&lt;/code&gt; houses, with Santa going one direction and Robo-Santa going the other.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we read, the difference here is that we have a second &amp;ldquo;Santa&amp;rdquo;, and they
alternate directions in the input, rather than one taking all the directions.
This means we will need to implement a toggle, as well as keep two sets of
coordinates on the same grid. As with previous answers, I chose to integrate
this solution into the original problem rather than writing a completely new
set of code to solve problem 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];

        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to the single &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; value for the first problem, I declare
a two-element array to represent the coordinates of both santas for the second
problem. I alse declare and initialize another set of min/max variables.
Finally, a variable is declared to act as a toggle between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now to find our coordinates, we run through the loop. We increment the x and y
of the appropriate Santa, and check that against the x and y minimums and
maximums for the second grid (remember, both Santas share the grid, so there
is only one set of mins and maxes). We&amp;rsquo;ll update the values for the second grid
based on the active Santa, and then once all values have been updated, we use
the bitwise XOR assignment operator to flip the toggle value. Once the loop is
complete, we calculate the width and height of the second grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The grid creation for the second problem is identical to the first problem. The
only difference comes in assigning the initial coordinates; this needs to be
done for both Santas for the second problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During the second iteration of the input, we&amp;rsquo;ll toggle the Santa as we did
during the range finding iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll count the number of visited houses for the second grid, exactly
as we did the first grid.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll free our allocated input array for completeness and return
success:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All together now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 3:\n&amp;quot;);

    /* size the grid */
    int x = 0, y = 0, min_x = 0, min_y = 0, max_x = 0, max_y = 0;
    int x2[2] = {0}, y2[2] = {0}, min_x2 = 0, min_y2 = 0, max_x2 = 0, max_y2 = 0;
    int s = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }

        if (x &amp;gt; max_x)
            max_x = x;
        if (y &amp;gt; max_y)
            max_y = y;
        if (x &amp;lt; min_x)
            min_x = x;
        if (y &amp;lt; min_y)
            min_y = y;

        if (x2[s] &amp;gt; max_x2)
            max_x2 = x2[s];
        if (y2[s] &amp;gt; max_y2)
            max_y2 = y2[s];
        if (x2[s] &amp;lt; min_x2)
            min_x2 = x2[s];
        if (y2[s] &amp;lt; min_y2)
            min_y2 = y2[s];
        s ^= 1;
    }

    int w = (max_x - min_x) + 1;
    int h = (max_y - min_y) + 1;
    int w2 = (max_x2 - min_x2) + 1;
    int h2 = (max_y2 - min_y2) + 1;

    /* create the grids and travel again */
    bool grid[w][h];
    bool grid2[w2][h2];
    memset(grid, 0, w * h * sizeof(bool));
    memset(grid2, 0, w2 * h2 * sizeof(bool));

    x = 0 - min_x;
    y = 0 - min_y;
    x2[0] = 0 - min_x2;
    x2[1] = 0 - min_x2;
    y2[0] = 0 - min_y2;
    y2[1] = 0 - min_y2;

    s = 0;
    grid[x][y] = true;
    grid[x2[0]][y2[0]] = true;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;&amp;gt;&#39;:
            x++;
            x2[s]++;
            break;
        case &#39;v&#39;:
            y--;
            y2[s]--;
            break;
        case &#39;&amp;lt;&#39;:
            x--;
            x2[s]--;
            break;
        case &#39;^&#39;:
            y++;
            y2[s]++;
            break;
        default:;
        }
        grid[x][y] = true;
        grid2[x2[s]][y2[s]] = true;
        s ^= 1;
    }

    /* count the houses touched */
    int houses = 0;
    for (int i = 0; i &amp;lt; w; i++)
        for (int j = 0; j &amp;lt; h; j++)
            houses += grid[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, houses);

    houses = 0;
    for (int i = 0; i &amp;lt; w2; i++)
        for (int j = 0; j &amp;lt; h2; j++)
            houses += grid2[i][j] ? 1 : 0;
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, houses);

    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 2: I Was Told There Would Be No Math</title>
      <link>/post/advent-2015-c-2/</link>
      <pubDate>Mon, 09 Sep 2019 02:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-2/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m going to go ahead and do a second puzzle today since the early ones are
relatively simple. Day 1&amp;rsquo;s puzzles were mostly incrementing, decrementing and
tracking variables; Day 2&amp;rsquo;s have a bit more math involved.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.&lt;/p&gt;

&lt;p&gt;Fortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is &lt;code&gt;2*l*w + 2*w*h + 2*h*l&lt;/code&gt;. The elves also need a little extra paper for each present: the area of the smallest side.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2*6 + 2*12 + 2*8 = 52&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;6&lt;/code&gt; square feet of slack, for a total of &lt;code&gt;58&lt;/code&gt; square feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;2*1 + 2*10 + 2*10 = 42&lt;/code&gt; square feet of wrapping paper plus &lt;code&gt;1&lt;/code&gt; square foot of slack, for a total of &lt;code&gt;43&lt;/code&gt; square feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All numbers in the elves&amp;rsquo; list are in feet. How many total &lt;strong&gt;square feet of wrapping paper&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we&amp;rsquo;re going to take a minute to break the problem down. As the
problem states, the input is formatted as XXxYYxZZ, so we will need to parse
the input into usable numbers. Since we need to operate on the smallest
dimensions for the slack, we&amp;rsquo;ll need to be able to sort the inputted values.
Finally, we&amp;rsquo;ll need to do the math and keep a running total.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dig in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preamble to our function is identical to day 1, with the exception of
initializing our return value early as we&amp;rsquo;ll be using our &lt;code&gt;goto&lt;/code&gt; short circuit
pattern to handle some later potential errors. We check that the user provided a
filename and read the file into the &lt;code&gt;input&lt;/code&gt; buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll then print our daily header and initialize the running total for the
wrapping paper.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start getting into some more interesting string handling. Note that the
input has one present per line, so we need to effectively split the string on
the lines. We will use the POSIX &lt;code&gt;strsep&lt;/code&gt; function for this. There is a similar
&lt;code&gt;strtok&lt;/code&gt; function in the C standard librory, but it has the downside of being
non-reentrant. If portability is a concern, you may want to stick use &lt;code&gt;strtok&lt;/code&gt;,
however &lt;code&gt;strsep&lt;/code&gt; is widely supported and should  be used instead of &lt;code&gt;strtok&lt;/code&gt;
wherever possible.&lt;/p&gt;

&lt;p&gt;In order to avoid changing the original value of the pointer to the input, we
make a copy into &lt;code&gt;cursor&lt;/code&gt; which becomes the moving pointer passed as the first
argument of &lt;code&gt;strsep&lt;/code&gt;. Finally, we are splitting on the newline character &lt;code&gt;\n&lt;/code&gt;.
We will not bother to make a copy of the input buffer as we only need to parse
it once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One side effect of &lt;code&gt;strsep&lt;/code&gt; that one needs to be aware of is that if multiple
delimiters are encountered in a row, &lt;code&gt;strsep&lt;/code&gt; will return a pointer to an empty
string instead of consuming all of the delimiters at once. We check for the
empty string and short-circuit the loop if we encounter this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now initialize an array of three &lt;code&gt;int&lt;/code&gt;s to hold the parsed values. We use an
array instead of separate variables because we will need to sort the result.
Once the array is initialized, we use the &lt;code&gt;sscanf&lt;/code&gt; function to scan the
dimensions into the array. As we are not trying to scan &lt;em&gt;into&lt;/em&gt; string variables,
&lt;code&gt;sscanf&lt;/code&gt; is perfectly safe for our usage. As an error check, we will
short-circuit to the function cleanup if we have an invalid line which scans
less than three values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        qsort(dims, 3, sizeof(int), cmp_int_asc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the values are scanned, they need to be sorted so that we can find the
slack using the smallest side. For this we use the standard library function
&lt;code&gt;qsort&lt;/code&gt; with a simple comparator function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int cmp_int_asc(const void *a, const void *b)
{
    int l = *(const int *)a;
    int r = *(const int *)b;

    return l &amp;lt; r ? -1 : l &amp;gt; r ? 1 : 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The comparator dereferences and casts the inputs and then returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a &amp;lt; 
b&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if they are equal. I use the ternary operator here
for conciseness, but I would refrain from using it for anything more complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have our values and we have them sorted by smallest to largest, we
just need to do the math and update our running total. As noted in the problem,
for each present we need to add the area of each side plus the area of the
smallest side as slack: &lt;code&gt;2xy + 2yz + 2xz + xy&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have broken out of the input parsing loop, &lt;code&gt;paper&lt;/code&gt; should have the total
required wrapping paper. We can print the solution and then proceed with
cleanup. As noted in day 1, freeing &lt;code&gt;input&lt;/code&gt; is not strictly necessary in this
case but is good from a habit-forming perspective.&lt;/p&gt;

&lt;p&gt;Once the solution has been input, the second problem is presented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.&lt;/p&gt;

&lt;p&gt;The ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don&amp;rsquo;t ask how they tie the bow, though; they&amp;rsquo;ll never tell.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;2x3x4&lt;/code&gt; requires &lt;code&gt;2+2+3+3 = 10&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;2*3*4 = 24&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;34&lt;/code&gt; feet.&lt;/li&gt;
&lt;li&gt;A present with dimensions &lt;code&gt;1x1x10&lt;/code&gt; requires &lt;code&gt;1+1+1+1 = 4&lt;/code&gt; feet of ribbon to wrap the present plus &lt;code&gt;1*1*10 = 10&lt;/code&gt; feet of ribbon for the bow, for a total of &lt;code&gt;14&lt;/code&gt; feet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How many total &lt;strong&gt;feet of ribbon&lt;/strong&gt; should they order?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As with day 1, we already have all of the infrastructure present to handle this
new problem. We&amp;rsquo;ll add a new variable to track the running total of ribbon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int paper = 0;
    int ribbon = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the total ribbon on each loop, following the instructions to add
&lt;code&gt;2x+2y+xyz&lt;/code&gt; to the total:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll print the second solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it&amp;rsquo;s all put together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    int rval = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 2:\n&amp;quot;);

    int paper = 0;
    int ribbon = 0;

    /* tokenize the data into lines */
    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        /* scan each line&#39;s values */
        int dims[3] = {0};

        int scanned = sscanf(line, &amp;quot;%dx%dx%d&amp;quot;, &amp;amp;dims[0], &amp;amp;dims[1], &amp;amp;dims[2]);
        if (scanned != 3)
        {
            fprintf(stderr, &amp;quot;Invalid input line \&amp;quot;%s\&amp;quot;\n&amp;quot;, line);
            goto err_cleanup;
        }

        qsort(dims, 3, sizeof(int), cmp_int_asc);

        paper += 2 * dims[0] * dims[1] + 2 * dims[1] * dims[2] + 2 * dims[2] * dims[0] + dims[0] * dims[1];
        ribbon += 2 * dims[0] + 2 * dims[1] + dims[0] * dims[1] * dims[2];
    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, paper);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, ribbon);

    goto cleanup;

err_cleanup:
    rval = 1;
cleanup:
    free(input);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, this program will pass all Valgrind checks and does not leak memory.&lt;/p&gt;

&lt;p&gt;Suggestions, questions, and criticism welcome! Comments can be added below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2015 Day 1: Not Quite Lisp</title>
      <link>/post/advent-2015-c-1/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-1/</guid>
      <description>&lt;p&gt;Yesterday, I talked in general about what I am trying to accomplish with this
series, and wrote a reusable function to read the input files into memory, which
will be used frequently throughout the series. Now it&amp;rsquo;s time to dig in.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Santa was hoping for a white Christmas, but his weather machine&amp;rsquo;s &amp;ldquo;snow&amp;rdquo; function is powered by stars, and he&amp;rsquo;s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.&lt;/p&gt;

&lt;p&gt;Collect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an easy puzzle to warm you up.&lt;/p&gt;

&lt;p&gt;Santa is trying to deliver presents in a large apartment building, but he can&amp;rsquo;t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.&lt;/p&gt;

&lt;p&gt;An opening parenthesis, &lt;code&gt;(&lt;/code&gt;, means he should go up one floor, and a closing parenthesis, &lt;code&gt;)&lt;/code&gt;, means he should go down one floor.&lt;/p&gt;

&lt;p&gt;The apartment building is very tall, and the basement is very deep; he will never find the top or bottom  floors.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(())&lt;/code&gt; and &lt;code&gt;()()&lt;/code&gt; both result in floor &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(((&lt;/code&gt; and &lt;code&gt;(()(()(&lt;/code&gt; both result in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;))(((((&lt;/code&gt; also results in floor &lt;code&gt;3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;())&lt;/code&gt; and &lt;code&gt;))(&lt;/code&gt; both result in floor &lt;code&gt;-1&lt;/code&gt; (the first basement level).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)))&lt;/code&gt; and &lt;code&gt;)())())&lt;/code&gt; both result in floor &lt;code&gt;-3&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To &lt;strong&gt;what floor&lt;/strong&gt; do the instructions take Santa?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before we start writing code, let&amp;rsquo;s think about what needs to happen. We will
need to input a file, read through it, determine which characters are important
(&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) and adjust the floor number accordingly. Then we&amp;rsquo;ll need to output
our solution somehow.&lt;/p&gt;

&lt;p&gt;Generally speaking, each day&amp;rsquo;s puzzle will be its own executable and the input
filename will be a command-line argument.&lt;/p&gt;

&lt;p&gt;Now that we have a plan of attack, let&amp;rsquo;s dig in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First things first, let&amp;rsquo;s check and make sure the user actually provided a
filename. Don&amp;rsquo;t forget that &lt;code&gt;argv[0]&lt;/code&gt; is always the name of the invoked command,
so &lt;code&gt;argc&lt;/code&gt; must be at least &lt;code&gt;2&lt;/code&gt; if the user has provided any arguments at all. If
the argument is not present, we&amp;rsquo;ll print a useful error message to &lt;code&gt;stderr&lt;/code&gt; and
return from &lt;code&gt;main&lt;/code&gt; with a non-zero code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that input file function we wrote yesterday? Now we get to use it. We
declare a pointer to the buffer and pass it into the function, along with the
filename which should be in &lt;code&gt;argv[1]&lt;/code&gt;. If the file doesn&amp;rsquo;t exist, isn&amp;rsquo;t
readable, or any other problem that we handled in the function, it will return
&lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;errno&lt;/code&gt; will be set. In that case, we print the error message to
&lt;code&gt;stderr&lt;/code&gt; and return non-zero. If everything worked, the contents of the file
are now in the location in memory pointed to by our &lt;code&gt;input&lt;/code&gt; pointer. Once we&amp;rsquo;ve
successfully read the file, we&amp;rsquo;ll print our header line for the output.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to solve the problem. The most straightforward way is going to be
to iterate over the contents of the file in memory byte-by-byte and adjust the
floor accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the first puzzle */
    int floor = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We initialize our floor variable to zero as noted in the problem description
(&lt;code&gt;He starts on the ground floor (floor 0)...&lt;/code&gt;), and then construct a &lt;code&gt;for&lt;/code&gt; loop
with the index starting at &lt;code&gt;0&lt;/code&gt; (remember, C arrays are zero-indexed) and
incrementing by one until we reach the file size which was returned by our file
input function. During each iteration of the loop, we check the byte at that
index and either increment or decrement the floor number depending on the
character. In this case, I have chosen to ignore any spurious characters that
may be in the input.&lt;/p&gt;

&lt;p&gt;The object of the problem is to determine which floor we arrive at (&lt;code&gt;To what 
floor do the instructions take Santa?&lt;/code&gt;), so the value of the &lt;code&gt;floor&lt;/code&gt; variable
is our solution.&lt;/p&gt;

&lt;p&gt;Once we input our solution, a second problem appears!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, given the same instructions, find the &lt;strong&gt;position&lt;/strong&gt; of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()())&lt;/code&gt; causes him to enter the basement at character position &lt;code&gt;5&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What is the &lt;strong&gt;position&lt;/strong&gt; of the character that causes Santa to first enter the basement?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the interest of saving compute time and code, we will attempt to integrate
the finding of the second solution into the original code. In this case, it&amp;rsquo;s
a matter of finding the index where we first hit floor &lt;code&gt;-1&lt;/code&gt;. We can do this by
setting a variable to a known bad value, and checking whether it has been reset
to a known good value and if not, setting it. So, we&amp;rsquo;ll update our problem logic
as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* solve the puzzles */
    int floor = 0;
    int basement = -1;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == -1)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this updated logic, we set &lt;code&gt;basement&lt;/code&gt; to a sentinel value of &lt;code&gt;-1&lt;/code&gt;; since we
are counting up, the value cannot possibly be negative. Then, in each iteration
of the loop, we check for the floor to be &lt;code&gt;-1&lt;/code&gt; (since we can only move one
floor at a time) and for the basement value to be the sentinel. For those of
you counting instructions, notice that the floor check will short-circuit; i.e.
the basement check will not happen unless the floor is &lt;code&gt;-1&lt;/code&gt;. The net effect is
that on average we are only adding one instruction per loop. Also notice that
we set the value of basement to &lt;code&gt;i + 1&lt;/code&gt; as the positions are one-indexed per
the problem parameters (&lt;code&gt;The first character in the instructions has position 
1...&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have solved the problem, we&amp;rsquo;ll clean up and return &lt;code&gt;0&lt;/code&gt;. Note that it
is not strictly necessary to free &lt;code&gt;input&lt;/code&gt;, but it is a good habit to be in.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the whole program for day 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;

int main(int argc, char const *argv[])
{
    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 1:\n&amp;quot;);

    /* solve the puzzles */
    int floor = 0;
    int basement = 0;
    for (int i = 0; i &amp;lt; filesize; i++)
    {
        switch (input[i])
        {
        case &#39;(&#39;:
            floor++;
            break;
        case &#39;)&#39;:
            floor--;
            break;
        default:;
        }
        if (floor == -1 &amp;amp;&amp;amp; basement == 0)
        {
            basement = i + 1;
        }
    }

    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, floor);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, basement);

    free(input);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program makes proper error checks and manages memory properly, and will
pass all Valgrind checks in a variety of test scenarios.&lt;/p&gt;

&lt;p&gt;If I&amp;rsquo;ve done something horribly wrong or you have questions, please comment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code deep dive kickoff</title>
      <link>/post/advent-setup-c/</link>
      <pubDate>Sun, 08 Sep 2019 22:00:00 +0000</pubDate>
      
      <guid>/post/advent-setup-c/</guid>
      <description>&lt;p&gt;In the first technical article for this iteration of the site, I&amp;rsquo;d like to turn
to &lt;a href=&#34;https://adventofcode.com&#34; target=&#34;_blank&#34;&gt;Advent of Code&lt;/a&gt;. These are programming problems
built around a fun Christmas-themed storyline each year. I especially appreciate
that the problems are language-agnostic, so I frequently turn to some of the
easier ones when I&amp;rsquo;m getting familiar with a new language.&lt;/p&gt;

&lt;p&gt;It can be easy to throw together just enough code to make the puzzle work, but
I thought I&amp;rsquo;d revisit these problems from a different angle, looking not only
at how to solve the problem, but how to write high-quality code, including error
handling and memory management. In order to up the challenge, the solutions will
be written in C, and the code will pass all Valgrind tests for memory leaks and
other issues. All code discussed in these posts will be in my &lt;a href=&#34;https://github.com/e3b0c442/advent&#34; target=&#34;_blank&#34;&gt;Advent of Code
solutions repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To kick things off, we&amp;rsquo;ll take a look at code reuse. When you&amp;rsquo;re quickly
prototyping or problem solving, you&amp;rsquo;re frequently going to have identical
snippets of code in multiple places. If we&amp;rsquo;re writing high-quality code, we want
to avoid this wherever possible. One common theme throughout the Advent of Code
problems will be reading an input file into memory. In order to avoid writing
the same code over and over, we&amp;rsquo;re going to start things off by writing a
function to read a file into a memory buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already, just in the function signature, we are making design decisions. We
could have written the function to return the pointer to the memory buffer, and
in most languages this makes the most sense. However, in C, the length of an
array is not an integral part of the data type, so we need to pass that
information back as well. Therefore, I made the decision to pass a pointer to
pointer to char (array) to the function, which will be modified in the function
with the actual pointer to the allocated buffer, and to return the size of the
buffer in the return value (or -1 if there is an error). We use this pattern
rather than passing in the buffer itself because we do not know ahead of time
how the buffer needs to be sized. The caller will be responsible for freeing the
buffer when they are done using it.&lt;/p&gt;

&lt;p&gt;Now, lets think about what actually needs to happen to read a file into memory,
and what can go wrong.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Does the file exist? Is it a valid, readable file?&lt;/li&gt;
&lt;li&gt;How big is the file; consequently, how big does my buffer need to be?&lt;/li&gt;
&lt;li&gt;What happens if we don&amp;rsquo;t succeed in reading the actual data?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can see, when reading a file, there are a lot of potential failure
points. Keeping that in mind, let&amp;rsquo;s start writing our code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we do is initialize variables that will exist for the life of
the function (and be part of the cleanup). &lt;code&gt;rval&lt;/code&gt; will hold our return value,
&lt;code&gt;f&lt;/code&gt; will hold our file pointer, and &lt;code&gt;*buf&lt;/code&gt; is the pointer to the buffer that
will hold the file contents, which is passed in as a parameter. Each is
initialized to a sane default, as variables are not automatically initialized
in C.&lt;/p&gt;

&lt;p&gt;With that out of the way, we&amp;rsquo;ll make our first check. Using the POSIX &lt;code&gt;stat&lt;/code&gt;
function, we query the file for information. Right off the bat, this will tell
us if the file exists; if it does not, &lt;code&gt;stat&lt;/code&gt; will return &lt;code&gt;-1&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;
accordingly. If we see this, we will jump to our error cleanup.&lt;/p&gt;

&lt;p&gt;At this point, I&amp;rsquo;m going to take a sidebar and talk a bit about &lt;code&gt;goto&lt;/code&gt;. For most
programmers, there&amp;rsquo;s a knee-jerk reaction to avoid &lt;code&gt;goto&lt;/code&gt; at all costs.
Generally, I agree with this with one exception: &lt;em&gt;error cleanup.&lt;/em&gt; In this case,
&lt;code&gt;goto&lt;/code&gt; properly used provides an avenue to short-circuit function execution and
provide for cleanup in the case of an error without reusing the same code.&lt;/p&gt;

&lt;p&gt;If the file exists, the &lt;code&gt;struct stat&lt;/code&gt; will be populated with information about
the file, including the type and size. Continuing on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our next check is that we are working with a regular file, as opposed to a
directory, block device, or other file type. (note: &lt;code&gt;stat&lt;/code&gt; follows symlinks!).
We use the &lt;code&gt;S_ISREG&lt;/code&gt; macro to accomplish this. Because this is a check and not
necessarily an error condition, if the provided file is not a regular file we
will set &lt;code&gt;errno&lt;/code&gt; ourselves to indicate an invalid parameter and then jump to our
error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL) 
        goto err_cleanup; /* errno is set by fopen() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know the file exists, and that it&amp;rsquo;s a regular file, we will try to
open it for reading. If the file is not readable for any reason, &lt;code&gt;fopen&lt;/code&gt; will
return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; appropriately. We will check for the &lt;code&gt;NULL&lt;/code&gt;
return value and short-circuit as needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve successfully opened the file, we&amp;rsquo;ll allocate the buffer. Even
though we already had the size information from the &lt;code&gt;stat&lt;/code&gt; call, I&amp;rsquo;ve chosen
not to allocate the buffer until we know the file is readable, to avoid
unnecessary allocations. For this problem it doesn&amp;rsquo;t really matter, but it&amp;rsquo;s
a good habit to be in. If there is an error allocating the buffer such as
running out of memory, &lt;code&gt;malloc&lt;/code&gt; will return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt;; again we
will check for this and short-circuit the function as necessary. I&amp;rsquo;m using
&lt;code&gt;malloc&lt;/code&gt; instead of &lt;code&gt;calloc&lt;/code&gt; because we have designed the function such that the
buffer will be completely filled by the file, negating the need to initialize
it. The extra +1 is to make room for a null terminator so that we may treat the
buffer as a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we perform the actual read. &lt;code&gt;fread&lt;/code&gt; is a buffered read which calls the
low-level &lt;code&gt;read&lt;/code&gt; syscall, and as such it will block until the requested size
is read unless there is an error, allowing us to avoid need to loop until the
expected data is read. Instead, we will check to make sure the expected size
of data is read (the file size) and check for an error if it is not. If there
is an error reading the file, we&amp;rsquo;ll short-circuit to our error cleanup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We finish up the logic of our function by setting the extra allocated byte at
the end of the buffer to a null terminator, then set the return value to the
amount of data read, and finally jumping to our non-error cleanup. Array
indeces have a higher precedence than the indirection operator, so we need to
enclose the indirection in parentheses to avoid writing to the wrong memory
address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for our cleanup. There are two things that need to be cleaned up in this
function: first, the file needs to be closed if it was opened, to avoid file
handle leaks. Also, if there was an error, the data buffer needs to be freed
if it was allocated and the pointer set to NULL. Finally, if we did error,
we set &lt;code&gt;rval&lt;/code&gt; to -1 which indicates the error to the caller, who can then get
more information by inspecting &lt;code&gt;errno.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The whole function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int read_file_to_buffer(char **buf, const char *filename)
{
    int rval = 0;
    FILE *f = NULL;
    *buf = NULL;

    /* check that the file exists and is valid to read */
    struct stat s;
    int rc = stat(filename, &amp;amp;s);
    if (rc == -1)
        goto err_cleanup; /* errno is set by stat() */

    /* check that we are working with an actual file */
    if (!S_ISREG(s.st_mode))
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    /* open the file */
    f = fopen(filename, &amp;quot;r&amp;quot;);
    if (f == NULL)
        goto err_cleanup; /* errno is set by fopen() */

    /* allocate the buffer */
    *buf = malloc(s.st_size + 1);
    if (*buf == NULL)
        goto err_cleanup; /* errno is set by malloc() */

    /* read the file into the buffer */
    size_t rd = fread(*buf, 1, s.st_size, f);
    if (rd &amp;lt; s.st_size)
        if (ferror(f))
            goto err_cleanup;

    /* file is read into the buffer, return the number of bytes read */
    (*buf)[rd] = &#39;\0&#39;;
    rval = rd;
    goto cleanup;

err_cleanup:
    rval = -1;
    if (*buf != NULL)
        free(*buf);
    *buf = NULL;
cleanup:
    if (f != NULL)
        fclose(f);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve now written a function with appropriate error checking that can be reused
throughout our Advent of Code exercises!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
