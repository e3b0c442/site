<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structures on e3b0c442.io</title>
    <link>/tags/data-structures/</link>
    <description>Recent content in Data Structures on e3b0c442.io</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/tags/data-structures/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advent of Code 2015 Day 7: Some Assembly Required</title>
      <link>/post/advent-2015-c-7/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent-2015-c-7/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a few weeks, but I&amp;rsquo;m glad to be able to pick up the Advent of Code series again. In the last post, I took a bit of a digression to discuss hash tables. In today&amp;rsquo;s post, we&amp;rsquo;ll see why. Let&amp;rsquo;s see what we have in store for day 7:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This year, Santa brought little Bobby Tables a set of wires and &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34; target=&#34;_blank&#34;&gt;bitwise logic gates&lt;/a&gt;! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.&lt;/p&gt;

&lt;p&gt;Each wire has an identifier (some lowercase letters) and can carry a &lt;a href=&#34;https://en.wikipedia.org/wiki/16-bit&#34; target=&#34;_blank&#34;&gt;16-bit&lt;/a&gt; signal (a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;65535&lt;/code&gt;). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.&lt;/p&gt;

&lt;p&gt;The included instructions booklet describes how to connect the parts together: &lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means to connect wires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to an AND gate, and then connect its output to wire &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 -&amp;gt; x&lt;/code&gt; means that the signal &lt;code&gt;123&lt;/code&gt; is provided to wire &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x AND y -&amp;gt; z&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#AND&#34; target=&#34;_blank&#34;&gt;bitwise AND&lt;/a&gt; of wire &lt;code&gt;x&lt;/code&gt; and wire &lt;code&gt;y&lt;/code&gt; is provided to wire &lt;code&gt;z&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p LSHIFT 2 -&amp;gt; q&lt;/code&gt; means that the value from wire &lt;code&gt;p&lt;/code&gt; is &lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;left-shifted&lt;/a&gt; by &lt;code&gt;2&lt;/code&gt; and then provided to wire &lt;code&gt;q&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT e -&amp;gt; f&lt;/code&gt; means that the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#NOT&#34; target=&#34;_blank&#34;&gt;bitwise complement&lt;/a&gt; of the value from wire &lt;code&gt;e&lt;/code&gt; is provided to wire &lt;code&gt;f&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other possible gates include &lt;code&gt;OR&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation#OR&#34; target=&#34;_blank&#34;&gt;bitwise OR&lt;/a&gt;) and &lt;code&gt;RSHIFT&lt;/code&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Logical_shift&#34; target=&#34;_blank&#34;&gt;right-shift&lt;/a&gt;). If, for some reason, you&amp;rsquo;d like to &lt;strong&gt;emulate&lt;/strong&gt; the circuit instead, almost all programming languages (for example, &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operations_in_C&#34; target=&#34;_blank&#34;&gt;C&lt;/a&gt;, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&#34; target=&#34;_blank&#34;&gt;JavaScript&lt;/a&gt;, or &lt;a href=&#34;https://wiki.python.org/moin/BitwiseOperators&#34; target=&#34;_blank&#34;&gt;Python&lt;/a&gt;) provide operators for these gates.&lt;/p&gt;

&lt;p&gt;For example, here is a simple circuit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 123 -&amp;gt; x
&amp;gt; 456 -&amp;gt; y
&amp;gt; x AND y -&amp;gt; d
&amp;gt; x OR y -&amp;gt; e
&amp;gt; x LSHIFT 2 -&amp;gt; f
&amp;gt; y RSHIFT 2 -&amp;gt; g
&amp;gt; NOT x -&amp;gt; h
&amp;gt; NOT y -&amp;gt; i
&amp;gt; ```

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After it is run, these are the signals on the wires:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In little Bobby&amp;rsquo;s kit&amp;rsquo;s instructions booklet (provided as your puzzle input), what signal is ultimately provided to &lt;strong&gt;wire &lt;code&gt;a&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a fairly complex problem, and in contrast to previous days&amp;rsquo; entries, there is more than one way to go about solving it successfully and efficiently. I chose to solve this problem by creating &lt;em&gt;hash tables&lt;/em&gt; with the gate statements, and then recursively calling an operator function to find the gate value. Hash tables are approprate for this task for two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Accessing the gate instructions will effectively be random-access since there is no linearity to how the instructions are arranged. Hash tables on average have &lt;em&gt;O(1)&lt;/em&gt; time complexity for searches.&lt;/li&gt;
&lt;li&gt;The gates are named by strings, allowing us to translate them directly into hash table keys.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will utilize the &lt;a href=&#34;/post/esht/&#34; target=&#34;_blank&#34;&gt;esht&lt;/a&gt; implementation discussed in the prior article. As noted in that article, while there is a POSIX hash table implementation, it is non-reentrant, and a re-entrant version included as part of the GNU C library is not present in many UNIX flavors, including macOS. In this case, reentrancy is important as we will soon see that we need to maintain two tables.&lt;/p&gt;

&lt;p&gt;As we examine this problem, what might immediately jump out is that each of these gates is a function that takes one or two 16-bit input values and outputs another value. Indeed, it would be possible, and some might consider elegant, to parse the inputs into a linked tree of function pointers using function pointers. However, I feel like this adds some unnecessary complexity and does not avoid the need for an additional caching mechanism, which is necessary due to the fact that we cannot guarantee that the gates are a true tree.&lt;/p&gt;

&lt;p&gt;Given this, it is much simpler and cleaner to parse the gate definitions into a data structure and make recursive calls to a single executor function to accomplish the goal of the task.&lt;/p&gt;

&lt;p&gt;With that lengthy discussion out of the way, let&amp;rsquo;s break the problem down a bit as we have done in previous weeks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the input file into memory&lt;/li&gt;
&lt;li&gt;Parse the individual gates into a hash table&lt;/li&gt;
&lt;li&gt;Execute the gates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As gates can also be inputs to another gate, we will need to call the gate executor recursively, so we will make this a separate function. We&amp;rsquo;ll start our coding here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uint16_t do_op(esht *instrs, esht *cache, char *key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our gate execution function takes three arguments: the hash table with the gate instructions keyed by gate name, a cache of already-resolved values also keyed by the gate name, and the gate key itself. The return value is &lt;code&gt;uint16_t&lt;/code&gt;, which is an unsigned 16-bit integer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we are going to do is check for a cached value. We use the provided key and cache table pointer to call &lt;code&gt;esht_get()&lt;/code&gt;; we cast the return value to a pointer to &lt;code&gt;uint16_t&lt;/code&gt; as the values are stored in the hash table as void pointers. If a result is found in the cache, we copy the value, clean up the allocated memory (remember that with &lt;code&gt;esht&lt;/code&gt;, the caller is responsible for cleanup of returned values), and return the retrieved value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no value in the cache for the key, it is time to start solving the gate value. We&amp;rsquo;ll first pull the gate definition from the hash table where we&amp;rsquo;ve already stored it. We then declare an array of four matches; the instruction parsing expression has three submatches in addition to the whole string match, which we will discuss later. For now, it is sufficient to know that we are capturing the three components of the gate expression. Finally, we execute the regular expression to populate the match variables. If either the instruction lookup fails or the regular expression execution returns no match, &lt;code&gt;errno&lt;/code&gt; is set appropriately and execution jumps to the error cleanup handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start working on the gate values. First, we set up temporary buffers for the string representations of each of the components of the gate expression: the left operand, the operation, and the right operand. The buffer sizes are chosen specifically; since l and r can be no larger than 65536, we know that 5 characters is the max storage; likewise, the longest gate operation is 6 characters. All buffers have the extra byte for the null terminator, and are initialized appropriately. We then additionally define a &lt;code&gt;char&lt;/code&gt; pointer which is used as part of the &lt;code&gt;strtoul&lt;/code&gt; error check, and finally integral values for the left and right operands of the gate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our variable initalization complete, we&amp;rsquo;ll start checking the values. For the left operand, the first thing we will check is that it is actually there, since some gates only have a single (right) operand. One useful properties of regular expressions in this case is that even if a submatch is conditional, its position in the results is still
preserved, so we know that the right operand will always have match index 3, regardless of whether the left operand and operator exist at all. If the submatch does not actually exist, member &lt;code&gt;rm_so&lt;/code&gt; of the &lt;code&gt;regmatch_t&lt;/code&gt; returned by &lt;code&gt;regexec&lt;/code&gt; will be -1.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve verified the submatch exists, we will copy just the submatch value to our temporary buffer by using the offests returned in the &lt;code&gt;regmatch_t&lt;/code&gt;. We will then attempt to convert the buffer to an unsigned long using &lt;code&gt;strtoul&lt;/code&gt;. We pass &lt;code&gt;check&lt;/code&gt; into the function; if the value of &lt;code&gt;check&lt;/code&gt; is the same as the string pointer once the operation is done and the return value is 0, we know that no number was actually found in the string and we can assume that rather than a value, it is the key to another gate and we can consequently make the recursive call. If the call returns the sentinel value and &lt;code&gt;errno&lt;/code&gt; is set, we&amp;rsquo;ll propogate that up.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we do the same for the right operand; the only difference being that we always expect the right operand to be there; if it is absent, that is considered an error and we will return appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will parse the operator. We know what the expected values are here; if the operator does not exist, we know that we are just returning the value provided by the right operand; else, we find one of the known bitwise operations and perform it, setting the return value accordingly. If the operator exists but is not an expected value, this is an error condition and we jump appropriately.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have gotten this far, we now have a final value for this gate that can be cached. We will add the value to the cache table with the gate&amp;rsquo;s key so that future calls to this gate can just return the cached value. Then we will go to the cleanup, where we make sure to free the instruction we retrieved from the hash table and free our iretrieved instruction.&lt;/p&gt;

&lt;p&gt;Now that we have our operation function implemented, we can look at the containing function for the problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Identically to previous days, we parse the arguments, open the file, and copy it into memory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then compile the regular expression that splits the gate operation from its key. If this returns an unexpected result, we will jump to the error cleanup. This is a fairly simple regex, that captures two submatches: anything to the left of &lt;code&gt;-&amp;gt;&lt;/code&gt;, and then a gate key to the right of &lt;code&gt;-&amp;gt;&lt;/code&gt;, which is only letters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will set up some variables in preparation for looping over the input, including our line cursor and an array of &lt;code&gt;regmatch_t&lt;/code&gt; for capturing the gate operations and keys, which we initialize to all zeroes on declaration. Then we create the table that will hold all of the gates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        int res;
        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we loop over the input, parsing the input lines into the hash table. We first check that there is actually length ta the line; if so, then we zero out the match objects (since we aren&amp;rsquo;t declaring them inside the loop) and execute the regular expression against the line. If there is no match, we&amp;rsquo;ll break the loop and error out.&lt;/p&gt;

&lt;p&gt;Assuming all goes well, we will then declare temporary buffors for the key and value; we chose a sane length for both to avoid the need to allocate on the heap. We then use the offsets in the &lt;code&gt;regmatch_t&lt;/code&gt; to copy the key and gate operation into the buffers. Finally, we add the gate to the hash table, erroring out if there is an unexpected return from the update operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then create the expression for parsing the gate operations, which is stored in a file-local manner as mentioned before. This expression searches for an optional alphanumeric value, followed by an optional operator from the list provided in the problem specification, followed by a &lt;em&gt;required&lt;/em&gt; alphanumeric expression. If there is a problem compiling the regular expression, we&amp;rsquo;ll jump to the error handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we allocate another table to cache values. This is required due to the fact that the connections between the gates form more of a web than a tree, which can cause, if not complete short-circuits, unnecessary multiple executions of the gate to find the value. We call the operation function with the key &amp;ldquo;a&amp;rdquo; as defined in the problem statement, which will recursively call itself with the appropriate gates to calculate the final value at wire &amp;ldquo;a&amp;rdquo;, which we will then print.&lt;/p&gt;

&lt;p&gt;Now that we have solved the first problem, let&amp;rsquo;s see what the second problem will require:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, take the signal you got on wire &lt;code&gt;a&lt;/code&gt;, override wire &lt;code&gt;b&lt;/code&gt; to that signal, and reset the other wires (including wire &lt;code&gt;a&lt;/code&gt;). What new signal is ultimately provided to wire &lt;code&gt;a&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s a good thing we made that cache table! Since we didn&amp;rsquo;t alter the original instructions, all we need to do is destroy the old cache, then set value &amp;ldquo;b&amp;rdquo; in the new cache as directed in the instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once Solution 2 is printed, we can clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting the whole thing together, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;pcreposix.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;common.h&amp;quot;
#include &amp;quot;esht.h&amp;quot;

static regex_t instr_r;

uint16_t do_op(esht *instrs, esht *cache, char *key)
{
    uint16_t rval;
    uint16_t *cached = (uint16_t *)esht_get(cache, key, NULL);
    if (cached != NULL)
    {
        rval = *cached;
        free(cached);
        return rval;
    }

    char *instr = (char *)esht_get(instrs, key, NULL);
    if (instr == NULL)
    {
        errno = ENOKEY;
        goto err_cleanup;
    }
    regmatch_t matches[4] = {0};
    int res = regexec(&amp;amp;instr_r, instr, 4, matches, 0);
    if (res == REG_NOMATCH)
    {
        errno = EINVAL;
        goto err_cleanup;
    }

    char ls[6] = {0};
    char op[7] = {0};
    char rs[6] = {0};

    char *check;
    unsigned long l, r = 0;

    if (matches[1].rm_so != -1)
    {
        strncpy(ls, instr + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        l = strtoul(ls, &amp;amp;check, 10);
        if (strlen(ls) &amp;gt; 0)
            if (l == 0 &amp;amp;&amp;amp; check == ls)
            {
                l = do_op(instrs, cache, ls);
                if (l == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
    }

    if (matches[3].rm_so != -1)
    {
        strncpy(rs, instr + matches[3].rm_so, matches[3].rm_eo - matches[3].rm_so);
        r = strtoul(rs, &amp;amp;check, 10);
        if (strlen(rs) &amp;gt; 0)
        {
            if (r == 0 &amp;amp;&amp;amp; check == rs)
            {
                r = do_op(instrs, cache, rs);
                if (r == UINT16_MAX &amp;amp;&amp;amp; errno != 0)
                    goto err_cleanup;
            }
        }
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }

    if (matches[2].rm_so != -1)
    {
        strncpy(op, instr + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if (!strcmp(op, &amp;quot;LSHIFT&amp;quot;))
            rval = l &amp;lt;&amp;lt; r;
        else if (!strcmp(op, &amp;quot;RSHIFT&amp;quot;))
            rval = l &amp;gt;&amp;gt; r;
        else if (!strcmp(op, &amp;quot;AND&amp;quot;))
            rval = l &amp;amp; r;
        else if (!strcmp(op, &amp;quot;OR&amp;quot;))
            rval = l | r;
        else if (!strcmp(op, &amp;quot;NOT&amp;quot;))
            rval = ~r;
        else
        {
            errno = EINVAL;
            goto err_cleanup;
        }
    }
    else
        rval = r;

    esht_update(cache, key, &amp;amp;rval, sizeof(uint16_t));
    goto cleanup;

err_cleanup:
    rval = UINT16_MAX;
cleanup:
    if (instr != NULL)
        free(instr);
    return rval;
}

int main(int argc, char const *argv[])
{
    int rc, res = 0;

    /* check that filename was provided */
    if (argc &amp;lt; 2)
    {
        fprintf(stderr, &amp;quot;Must provide filename of input file\n&amp;quot;);
        return -1;
    }

    /* read the file into memory */
    char *input;
    int filesize = read_file_to_buffer(&amp;amp;input, argv[1]);
    if (filesize &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;File read failed: %s\n&amp;quot;, strerror(errno));
        return -1;
    }

    printf(&amp;quot;Day 7:\n&amp;quot;);

    /* create the regular expression for parsing into the table */
    regex_t gate_r;
    int result = regcomp(&amp;amp;gate_r, &amp;quot;(.*) -&amp;gt; ([a-z]+)&amp;quot;, 0);
    if (result != 0)
        goto err_cleanup;

    char *cursor = input;
    char *line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    regmatch_t matches[3] = {0};
    esht *inst_table = esht_create();
    if (inst_table == NULL)
        goto err_cleanup;

    /* parse the gates into the hash table */
    while (line != NULL)
    {
        if (strlen(line) == 0)
            goto tokenize;

        memset(matches, 0, 3 * sizeof(regmatch_t));
        result = regexec(&amp;amp;gate_r, line, 3, matches, 0);
        if (result != 0)
            goto err_cleanup;

        char key[4] = {0};
        char val[64] = {0};

        strncpy(val, line + matches[1].rm_so, matches[1].rm_eo - matches[1].rm_so);
        strncpy(key, line + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);

        if ((res = esht_update(inst_table, key, val, strlen(val) + 1)) != 0)
            goto err_cleanup;

    tokenize:
        line = strsep(&amp;amp;cursor, &amp;quot;\n&amp;quot;);
    }

    result = regcomp(&amp;amp;instr_r, &amp;quot;^(?:([a-z0-9]+) )?(?:(AND|OR|RSHIFT|LSHIFT|NOT|) )?([a-z0-9]+)$&amp;quot;, 0);
    if (result)
        goto err_cleanup;

    /* create a cache and perform the recursive operation to get the gate value */
    esht *cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    uint16_t a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 1: %d\n&amp;quot;, a);

    /* clear cache and set b to value of a */
    esht_destroy(cache);
    cache = esht_create();
    if (cache == NULL)
        goto err_cleanup;
    if ((res = esht_update(cache, &amp;quot;b&amp;quot;, &amp;amp;a, sizeof(uint16_t))) != 0)
        goto err_cleanup;

    /* get solution 2 */
    a = do_op(inst_table, cache, &amp;quot;a&amp;quot;);
    printf(&amp;quot;\tSolution 2: %d\n&amp;quot;, a);
    goto cleanup;

err_cleanup:
    rc = -1;
cleanup:
    if (cache != NULL)
        esht_destroy(cache);
    regfree(&amp;amp;instr_r);
    if (inst_table != NULL)
        esht_destroy(inst_table);
    regfree(&amp;amp;gate_r);
    free(input);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is by far the most complex problem we have dealt with, requiring both a new data structure and the use of recursion to solve.&lt;/p&gt;

&lt;p&gt;As always, feel free to leave a comment if you have constructive feedback. We&amp;rsquo;ll be back for day 8 shortly!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>In which Nick creates a hash table</title>
      <link>/post/esht/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/esht/</guid>
      <description>&lt;p&gt;&lt;em&gt;The code discussed here can be found &lt;a href=&#34;https://github.com/e3b0c442/esht&#34; target=&#34;_blank&#34;&gt;on Github&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Before we tackle Day 7, we need to talk a bit about data structures. Choosing the proper data structures for your program&amp;rsquo;s data is extremely important in making your application both performant and easily understood.&lt;/p&gt;

&lt;p&gt;As we will see in Day 7&amp;rsquo;s discussion, we will need to be able to access an item by a provided string key. Storing these items in a linked list or array would work, but would be unnecessarily slow as the array would need to be iterated each time we try to find the item we are searching for. While there are ways to optimize this, such as by using binary search on a sorted array, these still only achieve an average time complexity of O(log(n)).&lt;/p&gt;

&lt;p&gt;The solution in this case is to use a hash table. Hash tables allow for a quick access given a piece of data (generally a string) as a key. This is accomplished by using a hashing algorithm to convert the key into a numerical value which can then be used as an array index. Given a well designed hash table, average search time can be constant time.&lt;/p&gt;

&lt;p&gt;Unfortunately, the C standard library comes with neither a hash table implementation nor a hash algorithm. POSIX defines a hash table, but it is defined and stored globally, making it effectively &lt;em&gt;non-reentrant&lt;/em&gt;. While this is of only a minor concern for us at this time, it also means that only one such table can be defined at a given time, which will likely be an issue in all but the most simple programs. GNU provides an extension which contains reentrant versions of the POSIX algorithm, but it is not available on even all UNIX platforms, most notably macOS.&lt;/p&gt;

&lt;p&gt;For these reasons, we will take some time and thought in this post to design and construct a hash table that gets around these limitations. We will have two primary design motivations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The table will be universal, so it must compile on standard C. I&amp;rsquo;m going to take this a step further and make it valid ANSI C.&lt;/li&gt;
&lt;li&gt;The table will be simple for end users. We will make a clear demarcation of responsibility for memory; each time the user adds something to the table, the key and value are copied, and the hash table owns those copies. When an item is retrieved, it is copied out. Therefore the end user is responsible for freeing all items provided to or retrieved from the table, but &lt;em&gt;not&lt;/em&gt; the copies in the table.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Regardless of platform, there are two important design decisions that need to be made when designing a hash table:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hashing algorithm&lt;/strong&gt;. The choice of hashing algorithm is very important. If a slow algorithm is used, the speed benefits of the hash table are reduced as the time to calculate hashes is high. If an algorithm with poor distributions are used, there will be additional collisions and therefore additional need to iterate over the hash buckets to find the requested item. Realistically, we need a hash algorithm which will produce a hash that fits in a standard numerical data type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Collision handling&lt;/strong&gt;. Even with a proper hash algorithm, unless you are using the full value of a modern cryptographic hash (Hint: don&amp;rsquo;t do this, they are slow and unnecessary, and you can&amp;rsquo;t use the full value anyway!), you will inevitably have collisions &amp;ndash; two identical keys which produce the same hash digest. There are two common ways to handle this: using &lt;em&gt;chaining&lt;/em&gt;, i.e. each hash key points to an array or linked list instead of a single item; or by using &lt;em&gt;open addressing&lt;/em&gt;, in which we make the primary array larger and, if an item already occupies the hash slot, iterating along the array until an open position is found.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For our hash table, we will use Daniel J. Bernstein&amp;rsquo;s DJB2a algorithm. This algorithm is simple and extremely fast, yet has reasonably good distribution. To handle collisions, we will use chaining with a singly-linked list. This reduces the complexity of adding and removing items from the chain with little to no performance penalty over an array iteration.&lt;/p&gt;

&lt;p&gt;In order to implement our hash table, we need to handle five different operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Allocating and initializing the table&lt;/li&gt;
&lt;li&gt;Inserting items into the table (or updating items already in the table)&lt;/li&gt;
&lt;li&gt;Searching for items in the table&lt;/li&gt;
&lt;li&gt;Deleting items from the table&lt;/li&gt;
&lt;li&gt;Destroying the table when we are done using it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on one&amp;rsquo;s use case, there may be a desire to separate the &lt;em&gt;adding&lt;/em&gt; and &lt;em&gt;updating&lt;/em&gt; functions. As we are trying to keep things simple though, we will keep them as one function under the assumption that if an item exists for the key, it will be updated.&lt;/p&gt;

&lt;p&gt;To start things off, we will need to create structures for the data in the table. In addition to the data itself, we need to track the key used to access the data and, since we will not be assuming a data type, the size of the data. In addition, since we are using linked-list chaining to handle collisions, we will need to have a pointer to the next item in the chain.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct esht_entry
{
    char *k;                /* key */
    void *v;                /* value */ 
    size_t l;               /* size */
    struct esht_entry *n;   /* pointer to next item in chain */
} esht_entry;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this structure defined, we can then define the structure for the table. This structures tracks both the current number of entries in the table, and the current size of the array backing the table, as well as the array itself. The size and capacity are used to calculate the &lt;em&gt;load factor&lt;/em&gt;. Generally speaking, the load factor of a hash table should be kept below 80% to ensure minimal collisions, thus keeping performance high.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct esht
{
    size_t len;             /* current size */
    size_t cap;             /* current size of backing array */
    esht_entry **entries;   /* array of pointers to entries */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these structs defined, we now have a place for all of the information that needs to be stored as part of our hash table. Now, we want to define our hash function. As mentioned before, this is Daniel J. Bernstein&amp;rsquo;s DJB2a algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned long esht_hash(char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++))
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) ^ c;

    return hash;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get down to the business of allocating and initializing the hash table. For simplicity&amp;rsquo;s sake, we are going to design our table with an initial capacity of 1. We will allocate the memory for the table struct, set the capacity and length, and allocate the memory for the backing array. We will check for errors after each allocation and return NULL on error, or return a pointer to the table struct if everything goes as planned. Note that we will use an array of pointers to item structs, rather than making an array of item structs themselves; this will simplify the addition and removal of items later on. We also use &lt;code&gt;malloc&lt;/code&gt; to allocate the table, but &lt;code&gt;calloc&lt;/code&gt; to allocate the array. This is because we will explicitly initialize the table members, but the array will just have &lt;code&gt;NULL&lt;/code&gt; pointers to start since there are no items. (The value of a &lt;code&gt;NULL&lt;/code&gt; pointer is &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;esht *esht_create()
{
    esht *table;

    table = malloc(sizeof(esht)); 
    if (table == NULL)
        return NULL;

    table-&amp;gt;cap = 1;
    table-&amp;gt;len = 0;
    table-&amp;gt;entries = calloc(1, sizeof(esht_entry *));
    if (table-&amp;gt;entries == NULL)
    {
        free(table);
        return NULL;
    }

    return table;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a table, we can start doing operations on it. However, there is one common piece of code that can be factored out, and that is the &lt;em&gt;resize&lt;/em&gt; operation, which will resize the backing array and redistribute the elements.&lt;/p&gt;

&lt;p&gt;A bit of explanation: In order to not consume an inordinate amount of memory (e.g. 2**32 * sizeof(esht_entry *)), we don&amp;rsquo;t actually use the full hash value, but the modulus of the hash value against the capacity of the array. The size of the array then becomes the second operand of the modulus. The side effect of this is that the array lookup index will change any time the array is resized, so we need to recompute the lookup index by re-hashing and modulizing the key.&lt;/p&gt;

&lt;p&gt;What this means is that you want to be judicious with resizing, as there will be a performance hit while the entirety of the table&amp;rsquo;s keys are hashed again. For our table, we are setting a maximum load factor of 0.75 and a minimum load factor of 0.25, and then either doubling or cutting in half the size once those limits are breached. This allows for a bit of hysteresis, so that if there are several insert or delete operatinos close to either limit, the table wouldn&amp;rsquo;t be resized on every insert/delete. If we wanted to simplify further, we could remove the minimum load factor and only allow the table to grow, but this potentially causes a memory leak.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_resize(esht *table, size_t new_cap)
{
    /* declare variables at the beginning to conform with ANSI C */
    int i, ii;
    esht_entry *cur, *next, **old;

    /* allocate and zero out a new backing array */
    esht_entry **new_entries = calloc(new_cap, sizeof(esht_entry *));
    if (new_entries == NULL)
        return 1;

    /* iterate over the old array... */
    for (i = 0; i &amp;lt; table-&amp;gt;cap; i++)
    {
        /* ...and then over the chains, recompute the hash index for each item, 
           and insert the item into the new array */
        next = table-&amp;gt;entries[i];
        while (next != NULL)
        {
            cur = next;
            next = cur-&amp;gt;n;

            ii = esht_hash(cur-&amp;gt;k) % new_cap;
            cur-&amp;gt;n = new_entries[ii];
            new_entries[ii] = cur;
        }
    }

    /* replace the old array with the new array, and free the old array */
    old = table-&amp;gt;entries;
    table-&amp;gt;entries = new_entries;
    table-&amp;gt;cap = new_cap;
    free(old);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One additional factored-out operation is finding the value for a key. This is used both by our searching and adding (read: updating) operations, and returns a pointer to the table entry for either updating or copying out a value to return.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;esht_entry *esht_get_entry(esht *table, char *key)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;

    /* hash the key and perform a modulus against the table capacity to get the
       lookup index */
    i = esht_hash(key) % table-&amp;gt;cap;

    /* iterate the chain until a matching key is found and return the entry */
    e = table-&amp;gt;entries[i];
    while (e != NULL)
    {
        if (!strcmp(key, e-&amp;gt;k))
            return e;
        e = e-&amp;gt;n;
    }

    /* if no entry is found, return NULL */
    return NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get down to the meat and potatoes: adding (updating), finding, and removing items from the table. First, we will write our insertion function. This function searches for an existing item with the same key and updates it; absent an existing item for the key, it allocates a new item and inserts it into the table. Finally, if the insertion causes the load factor to be exceeded, the table is resized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_update(esht *table, char *key, void *value, size_t len)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;
    void *v, *k, *old;

    /* find an existing entry for the key... */
    e = esht_get_entry(table, key);
    if (e != NULL)
    {
        /* allocate memory for and copy the value */
        v = malloc(len);
        if (v == NULL)
            return 1;
        memcpy(v, value, len);

        /* replace the value, update the value size, and free the old value */
        old = e-&amp;gt;v;
        e-&amp;gt;l = len;
        e-&amp;gt;v = v;
        free(old);

        return 0;
    }

    /* ...or allocate memory for a new entry */
    e = malloc(sizeof(esht_entry));
    if (e == NULL)
        return 1;

    /* allocate for and copy the value */
    v = malloc(len);
    if (v == NULL)
    {
        free(e);
        return 1;
    }
    memcpy(v, value, len);

    /* allocate for and copy the key */
    k = malloc(strlen(key) + 1);
    if (k == NULL)
    {
        free(e);
        free(v);
        return 1;
    }
    strcpy(k, key);

    /* set the entry variables */
    e-&amp;gt;k = k;
    e-&amp;gt;v = v;
    e-&amp;gt;l = len;

    /* hash the key and perform a modulus against the table capacity to get the
       lookup index */
    i = esht_hash(key) % table-&amp;gt;cap;

    /* insert the item into the table and update the size */
    e-&amp;gt;n = table-&amp;gt;entries[i];
    table-&amp;gt;entries[i] = e;
    table-&amp;gt;len++;

    /* if the load factor has been exceeded, resize the backing array */
    if ((float)table-&amp;gt;len / (float)table-&amp;gt;cap &amp;gt; ESHT_MAX_FACTOR)
        if (esht_resize(table, table-&amp;gt;cap * 2))
            return 1;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve already written most of the logic for finding an item; we&amp;rsquo;ll use that to find the item, then copy the value out to the end user. For end-user friendliness, we return a pointer to the value and not an entry struct. If the caller needs to know the size of the data (i.e. it is not a &lt;code&gt;NULL&lt;/code&gt;-terminated string or known data size), they can pass a pointer to a &lt;code&gt;size_t&lt;/code&gt; value, in which we can place the size of the data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *esht_get(esht *table, char *key, size_t *len)
{
    /* declare variables for ANSI C conformance */
    esht_entry *e;
    void *r;

    /* find an existing entry. If there is no entry matching the key, set the 
       value of the length pointer to 0 and return NULL */
    e = esht_get_entry(table, key);
    if (e == NULL)
    {
        if (len != NULL)
            *len = 0;
        return NULL;
    }

    /* allocate memory for and copy the value of the table entry */
    r = malloc(e-&amp;gt;l);
    if (r == NULL)
    {
        if (len != NULL)
            *len = 0;
        return NULL;
    }
    memcpy(r, e-&amp;gt;v, e-&amp;gt;l);

    /* if a valid pointer was provided, set the length of the return data, then
       return a pointer to the copied value */
    if (len != NULL)
        *len = e-&amp;gt;l;
    return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we will provide a way for end users to remove items from the table that are no longer needed. This function takes the key as an argument and returns &lt;code&gt;1&lt;/code&gt; if no item was found, or &lt;code&gt;0&lt;/code&gt; if the item was found and successfully removed. Then the table is resized if the load factor exceeds the minimum value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int esht_remove(esht *table, char *key)
{
    /* declare variables for ANSI C conformance */
    unsigned long i;
    esht_entry *e;

    /* hash and modulus the key. Note: we are not reusing the esht_get_entry
       function here because we need to know the previous item in the chain */
    i = esht_hash(key) % table-&amp;gt;cap;
    e = table-&amp;gt;entries[i];

    /* if the initial lookup is NULL, the item does not exist */
    if (e == NULL)
        return 1;

    /* otherwise, check the first key, and if the key matches, adjust the chain */
    if (!strcmp(e-&amp;gt;k, key))
    {
        table-&amp;gt;entries[i] = e-&amp;gt;n;
        goto cleanup;
    }

    /* If the first key did not match, iterate the table until it is found and
       adjust the chain */
    while (e-&amp;gt;n != NULL)
    {
        if (!strcmp(e-&amp;gt;n-&amp;gt;k, key))
        {
            e-&amp;gt;n = e-&amp;gt;n-&amp;gt;n;
            goto cleanup;
        }
    }

    return 1;

    /* This jump is only taken if a valid entry is found */
cleanup:
    /* Free the key, value, and entry struct */
    free(e-&amp;gt;k);
    free(e-&amp;gt;v);
    free(e);

    /* adjust the table size and resize if needed */
    table-&amp;gt;len--;
    if ((float)table-&amp;gt;len / (float)table-&amp;gt;cap &amp;lt; ESHT_MIN_FACTOR)
        if (esht_resize(table, table-&amp;gt;cap / 2))
            return 1;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a table to which we can add, find, and remove items. Now, we need to be able to clean the table up. The destroy function iterates the backing array and chains, frees the key and value of every entry and then the entry itself, frees the backing array, then finally frees the table struct.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void esht_destroy(esht *table)
{
    /* declare variables for ANSI C conformance */
    int i;
    esht_entry *e, *n;

    /* iterate the backing array... */
    for (i = 0; i &amp;lt; table-&amp;gt;cap; i++)
    {
        /* and then the chains, freeing all keys, values, and entries */
        e = table-&amp;gt;entries[i];
        while (e != NULL)
        {
            n = e-&amp;gt;n;
            free(e-&amp;gt;k);
            free(e-&amp;gt;v);
            free(e);
            e = n;
        }
    }

    /* free the backing array and then the table itself */
    free(table-&amp;gt;entries);
    free(table);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an ANSI-C compliant, end-user-friendly hash table. The end user is  responsible for managing items provided to or retrieved from the table, and is insulated from accidentally changing internal table values. The end user only needs to know about the table struct itself; the entry struct is internal-only and the find operation returns a pointer to a copy of the value with an optional length.&lt;/p&gt;

&lt;p&gt;We will use this table to complete Day 7 in the next post. Until then, your
comments, criticisms, and inputs are appreciated in the comments.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
